<?xml version="1.0" encoding="UTF-8"?>
<RefData version="1.0" exporter="Geodata Tools">
   <DataSet name="Automation Scripts"
            table="t_script"
            filter="ScriptName='#ScriptName#' and ScriptCategory='#ScriptCategory#'"
            stoplist=";ScriptID;">
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Validation scripts to validate the model against for instance the basic data model rules version 2. &#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-val-data-model-validation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{2D4D14C7-61B2-4792-8F5F-00705AFB7436}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Tools for persons that contribute to the development of the EAMT scripts.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-developer-tools"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in preparing the derivation of physical data schemas, e.g. using [ShapeChange](https://shapechange.net/).&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-data-schema-preparation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Scripts used for keeping scripts developed in EA under version control.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-script-management"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in creating a logical data model in UML. Scripts that prepare the derivation of physical data schemas are not included here.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-data-model-creation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{BF522BAE-AD19-4abb-8EA7-B7A030C7F6EA}"/>
         <Column name="Notes" value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-fda-concept-model-export"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes" value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Utility functions.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-utilities"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{F97C6CA0-F5C0-4659-A8D1-D8251032F1A1}"/>
         <Column name="Notes" value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-scripts"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{FAD5FD80-AFAF-4797-8BFB-44A019438349}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts specific for creating concept models modelled using the FDA profile, see also https://arkitektur.digst.dk/metoder/regler-begrebs-og-datamodellering and https://github.com/digst/model-rules-tool-support.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-fda-concept-model-creation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in exporting a logical data model.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-data-model-export"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{06C9A7C9-C3B9-4146-8EC8-A1618C64B7ED}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_shell-application-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to access to aspects of the Windows Explorer Shell application,&#xA; *       such as managing windows, files and folders, and the current session. This is useful in scripts that call&#xA; *       command line scripts importing or exporting models.&#xA; */&#xA; !INC eamt-utilities._logging-utils&#xA;&#xA;/** &#xA; * Provides access to aspects of the Windows Explorer Shell application, such as managing windows, files and&#xA; * folders, and the current session (from &#34;Windows Powershell Pocket References&#34; by Lee Holmes).&#xA; *&#xA; * See more on [Scriptable Shell Objects](https://docs.microsoft.com/en-us/windows/win32/shell/scriptable-shell-objects-roadmap)&#xA; * (in the Shell Developer's Guide) and&#xA; * [Shell object](https://docs.microsoft.com/en-us/windows/win32/shell/shell) (in the Shell Reference).&#xA; */&#xA;var SHELL_APP = new COMObject(&#34;Shell.Application&#34;);&#xA;&#xA;/**&#xA; * Shows a dialog box (not in the foreground unfortunately...) to the user to choose a folder.&#xA; * Returns the absolute file path of the choosen folder, or an empty string if no folder was selected.&#xA; */&#xA;function chooseFolderWithUI(dialogBoxTitle /* : String */) {&#xA;&#x9;LOGInfo(&#34;Pick a folder with the UI (see new dialog)&#34;);&#xA;&#x9;&#xA;&#x9;/* &#xA;&#x9; * BrowserForFolder method: see https://docs.microsoft.com/en-us/windows/win32/shell/shell-browseforfolder&#xA;&#x9; *&#xA;&#x9; * 4th argument of BrowseForFolder method:&#xA;&#x9; * see https://docs.microsoft.com/en-us/windows/win32/api/shldisp/ne-shldisp-shellspecialfolderconstants:&#xA;&#x9; * 0x11 (17). My Computerâ€”the virtual folder that contains everything on the local computer: storage devices, printers, and Control Panel. &#xA;&#x9; * This folder can also contain mapped network drives.&#xA;&#x9; */&#xA;&#x9;var folder = SHELL_APP.BrowseForFolder(0, dialogBoxTitle, 0x00000040, 0x11);&#xA;&#x9;if (folder == null) {&#xA;&#x9;&#x9;return &#34;&#34;;&#xA;&#x9;} else {&#xA;&#x9;&#x9;return folder.Self.Path;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Opens the folder with the given path in Windows Explorer.&#xA; */&#xA;function openFolderInWindowsExplorer(folderPath) {&#xA;&#x9;SHELL_APP.Explore(folderPath);&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{0CDB9C42-FBBB-43cc-B8EB-A1925B780A68}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_model-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with the retrieving model elements from the EA model.&#xA; */&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Element&gt;} elements in the given package (including elements in all its subpackages)&#xA; */&#xA;function getElementsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var elements = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Elements.Count; i++) {&#xA;&#x9;&#x9;elements[i] = aPackage.Elements.GetAt(i);&#xA;&#x9;}&#xA;&#x9;for (var j = 0; j &lt; aPackage.Packages.Count; j++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;elements = elements.concat(getElementsOfPackageAndSubpackages(aPackage.Packages.GetAt(j)));&#xA;&#x9;}&#xA;&#x9;return elements;&#xA;}&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Diagram&gt;} diagrams in the given package (including diagrams in all its subpackages)&#xA; */&#xA;function getDiagramsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var diagrams = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Diagrams.Count; i++) {&#xA;&#x9;&#x9;diagrams[i] = aPackage.Diagrams.GetAt(i);&#xA;&#x9;}&#xA;&#x9;for (var j = 0; j &lt; aPackage.Packages.Count; j++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;diagrams = diagrams.concat(getDiagramsOfPackageAndSubpackages(aPackage.Packages.GetAt(j)));&#xA;&#x9;}&#xA;&#x9;return diagrams;&#xA;}&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Package&gt;} packages in the given package (including packages in all its subpackages)&#xA; */&#xA;function getSubpackagesOfPackage(aPackage) {&#xA;&#x9;var packages = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Packages.Count; i++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;packages = packages.concat(aPackage.Packages.GetAt(i), getSubpackagesOfPackage(aPackage.Packages.GetAt(i)));&#xA;&#x9;}&#xA;&#x9;return packages;&#xA;}&#xA;&#xA;/**&#xA; * @return Array&lt;EA.Connector&gt; associations (including the aggregations and compositions) that are version&#xA; *         controlled in the given package or one of its subpackages.&#xA; */&#xA;function getAssociationsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var element as EA.Element;&#xA;&#x9;var connector as EA.Connector;&#xA;&#x9;var addToMap;&#xA;&#x9;&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;var connectorMap = new Map();&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;element = elements[i];&#xA;&#x9;&#x9;for (var j = 0; j &lt; element.Connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;connector = element.Connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;addToMap = isConnectorAssociationAndControlledInSamePackageAsElement(connector, element);&#xA;&#x9;&#x9;&#x9;if (addToMap) {&#xA;&#x9;&#x9;&#x9;&#x9;if (!connectorMap.has(connector.ConnectorGUID)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;connectorMap.set(connector.ConnectorGUID, connector);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return connectorMap.values();&#xA;}&#xA;&#xA;/**&#xA; * If a connector is controlled in the same package as a certain element, this means that both the element and the&#xA; * connector can be changed when the package the element belongs to is checked out. See also&#xA; * [Add Connectors To Locked Elements](https://www.sparxsystems.com/search/sphider/search.php?query=%22Add%20Connectors%20To%20Locked%20Elements%22&amp;type=phrase&amp;category=User+Guide+Latest&amp;tab=5&amp;search=1)&#xA; * &#xA; * @return {boolean} whether the given connector is an association (including aggregations and compositions) controlled in the same package&#xA; *         as in the given element&#xA; */&#xA;function isConnectorAssociationAndControlledInSamePackageAsElement(aConnector /* : EA.Connector */, anElement /* : EA.Element */) /* : boolean */ {&#xA;&#x9;var result;&#xA;&#x9;result =&#xA;&#x9;(Repository.GetElementByID(aConnector.ClientID).PackageID == Repository.GetElementByID(aConnector.SupplierID).PackageID &#xA;&#x9;&#x9;&amp;&amp; (aConnector.Type == &#34;Association&#34; || aConnector.Type == &#34;Aggregation&#34;))&#xA;&#x9;||&#xA;&#x9;((aConnector.ClientID == anElement.ElementID &amp;&amp; (aConnector.Type == &#34;Association&#34;))&#xA;&#x9;||&#xA;&#x9;(aConnector.SupplierID == anElement.ElementID &amp;&amp; aConnector.Type == &#34;Aggregation&#34;));&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param {EA.Element}&#xA; * @return {string} full path name of the given element (OCL style, see section 7.5.7 of the specification).&#xA; */&#xA;function getPathnameOfElement(anElement) {&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetPackageByID(anElement.PackageID);&#xA;&#x9;var pathname = package.Name + &#34;::&#34; + anElement.Name;&#xA;&#x9;do {&#xA;&#x9;&#x9;package = Repository.GetPackageByID(package.ParentID);&#xA;&#x9;&#x9;pathname = package.Name + &#34;::&#34; + pathname;&#xA;&#x9;} while (package.ParentID != 0)&#xA;&#x9;return pathname;&#xA;}&#xA;&#xA;/**&#xA; * @return {Array&lt;EA.Element&gt;} parent elements of the given element; the immediate parent is the first element in the array&#xA; */&#xA;function getParents(element) {&#xA;&#x9;// See Local Scripts.EAConstants-JScript for variable rsParents&#xA;&#x9;// Behaviour of GetRelationSet seems to be that the immediate parent is the first element in the array.&#xA;&#x9;elementIdsCommaSeparated = element.GetRelationSet(rsParents);&#xA;&#x9;var elements;&#xA;&#x9;if (elementIdsCommaSeparated.length == 0) {&#xA;&#x9;&#x9;elements = new Array();&#xA;&#x9;} else {&#xA;&#x9;&#x9;var elementIdsArray = elementIdsCommaSeparated.split(&#34;,&#34;);&#xA;&#x9;&#x9;elements = new Array(elementIdsArray.length);&#xA;&#x9;&#x9;for (var i in elementIdsArray) {&#xA;&#x9;&#x9;&#x9;elements[i] = Repository.GetElementByID(elementIdsArray[i]);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return elements;&#xA;}&#xA;&#xA;/**&#xA; * @return {Map&lt;int,EA.ConnectorEnd&gt;} map of the properties of the given element that are not inherited and that are association ends (not attributes)&#xA; *         The key is the connector ID, the value is the connector end.&#xA; */&#xA;function getNonInHeritedPropertiesThatAreAssociationEnds(element) {&#xA;&#x9;var properties = new Map();&#xA;&#x9;for (var i = 0; i &lt; element.Connectors.Count; i++) {&#xA;&#x9;&#x9;connector = element.Connectors.GetAt(i);&#xA;&#x9;&#x9;if (connector.Type == &#34;Association&#34; || connector.Type == &#34;Aggregation&#34;) {&#xA;&#x9;&#x9;&#x9;var property as EA.ConnectorEnd;&#xA;&#x9;&#x9;&#x9;var isOutgoing = false;&#xA;&#x9;&#x9;&#x9;if (element.ElementID == connector.ClientID &amp;&amp; connector.SupplierEnd.IsNavigable) {&#xA;&#x9;&#x9;&#x9;&#x9;isOutgoing = true;&#xA;&#x9;&#x9;&#x9;&#x9;property = connector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;} else if (element.ElementID == connector.SupplierID &amp;&amp; connector.ClientEnd.IsNavigable) {&#xA;&#x9;&#x9;&#x9;&#x9;isOutgoing = true;&#xA;&#x9;&#x9;&#x9;&#x9;property = connector.ClientEnd;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (isOutgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;properties.set(connector.ConnectorID, property);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return properties;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{0F9E91B0-CB24-466f-97C1-398D10320DA6}"/>
         <Column name="ScriptAuthor" value="{FAD5FD80-AFAF-4797-8BFB-44A019438349}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;synchronize-profile&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-fda-concept-models._fda-concept-model-constants&#xA;&#xA;/**&#xA; * Synchronizes the tagged values of the Concept and ConceptModel stereotypes of the FDA profile using the&#xA; * [`Repository.SynchProfile()` method](https://www.sparxsystems.com/search/sphider/search.php?query=synchprofile&amp;type=and&amp;category=User+Guide+Latest&amp;tab=5&amp;search=1).&#xA; *&#xA; * @summary Synchronizes the tagged values of the Concept and ConceptModel stereotypes of the FDA profile&#xA; */&#xA;function main() {&#xA;&#x9;Repository.SynchProfile(PROFILENAME, STEREOTYPE_CONCEPTMODEL);&#xA;&#x9;Repository.SynchProfile(PROFILENAME, STEREOTYPE_CONCEPT);&#xA;&#x9;Repository.RefreshModelView(0);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{1EE8D5D6-6519-4984-B91B-08A12CC7BD98}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_tagged-values-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with the getting and setting of tagged values.&#xA; *       See also https://www.sparxsystems.com/search/sphider/search.php?query=automation+memo+tagged+value&amp;type=and&amp;category=User+Guide+Latest&amp;tab=5&amp;search=1.&#xA; *&#xA; */&#xA;var MAX_LENGTH_TAGGED_VALUE = 255;&#xA;&#xA;/*&#xA; * Do not use Collection.GetByName for searching for tagged values: documentation &#34;If the collection contains items, but it was unable to &#xA; * find an object with the specified name, the method raises an exception&#34; (note: the exception is Index out of bounds).&#xA; */&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueElement(theElement, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Notes;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function setTaggedValueElement(theElement, taggedValueName, taggedValueValue) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = theElement.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function changeTaggedValueElementFromShortToLong(theElement, taggedValueName) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function deleteTaggedValueElement(theElement, taggedValueName) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueAttribute(attribute, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Notes;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function setTaggedValueAttribute(attribute, taggedValueName, taggedValueValue) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = attribute.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function changeTaggedValueAttributeFromShortToLong(attribute, taggedValueName) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function deleteTaggedValueAttribute(attribute, taggedValueName) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueConnectorEnd(connector, taggedValueName, source, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substr(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.substr(16); // the following is removed from the start of the value: &lt;memo&gt;$ea_notes=&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.split(&#34;$ea_notes=&#34;)[0];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param connectorEnd {EA.ConnectorEnd}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueConnectorEndByConnectorEnd(connectorEnd, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#x9;if (taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValues = connectorEnd.TaggedValues;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substr(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.substr(16); // the following is removed from the start of the value: &lt;memo&gt;$ea_notes=&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.split(&#34;$ea_notes=&#34;)[0];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; * @param source {boolean}&#xA; */&#xA;function setTaggedValueConnectorEnd(connector, taggedValueName, taggedValueValue, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = taggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substr(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;$ea_notes=&#34; + taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; */&#xA;function changeTaggedValueConnectorEndFromShortToLong(connector, taggedValueName, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substr(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;$ea_notes=&#34; + taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; */&#xA;function deleteTaggedValueConnectorEnd(connector, taggedValueName, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Truncates the value of a tagged value if it is longer than the maximum.&#xA; *&#xA; * When using a longer value than the maximum, the value cannot be set in the database. EA doesn't show a message&#xA; * but file %appdata%\Sparx Systems\EA\DBError.txt will contain the following:&#xA; * The field is too small to accept the amount of data you attempted to add.  Try inserting or pasting less data.&#xA; *&#xA; * @param taggedValueValue {string}&#xA; * @return {string} truncated value&#xA; */&#xA;function truncateTaggedValueValueIfNeeded(taggedValueValue) {&#xA;&#x9;var newTaggedValueValue;&#xA;&#x9;if (taggedValueValue.length &lt;= MAX_LENGTH_TAGGED_VALUE) {&#xA;&#x9;&#x9;newTaggedValueValue = taggedValueValue;&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGDebug(&#34;Truncate to &#34; + MAX_LENGTH_TAGGED_VALUE + &#34; characters: &#34; + taggedValueValue.substr(0, 30) + &#34;...&#34;);&#xA;&#x9;&#x9;newTaggedValueValue = taggedValueValue.substr(0, MAX_LENGTH_TAGGED_VALUE);&#xA;&#x9;}&#xA;&#x9;return newTaggedValueValue;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{2B5AA69A-C64A-4d2b-8B33-899B9CDD6C0C}"/>
         <Column name="ScriptAuthor" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-data-model-vocabulary-da&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;&#xA;/**&#xA; * Exports a data model to a Danish data vocabulary in the CSV format.&#xA; * The package containing the concept model must be selected in the Project Browser.&#xA; * If a URL is available for the dataset that is described by the data model, it can be provided and will be added to the data model.&#xA; * &#xA; * This script uses template vocabulary_csv.ftl in %EAMT_HOME%/config/templates.&#xA; *&#xA; * @summary Exports a data model to a data vocabulary.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (package != null &amp;&amp; package.ParentID != 0) {&#xA;&#x9;&#xA;&#x9;&#x9;var outputFolder = chooseFolderWithUI(&#34;Folder in which the exported data vocabulary should be saved&#34;);&#xA;&#x9;&#x9;if (outputFolder.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var answer = Session.Prompt(&#34;Should the output file have a header?&#34;, promptYESNO);&#xA;&#x9;&#x9;var hasHeader;&#xA;&#x9;&#x9;if (answer == resultYes) {&#xA;&#x9;&#x9;&#x9;hasHeader = true;&#xA;&#x9;&#x9;} else if (answer == resultNo) {&#xA;&#x9;&#x9;&#x9;hasHeader = false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var answer = Session.Prompt(&#34;Is a link to metadata available for the data?&#34;, promptYESNO);&#xA;&#x9;&#x9;var hasMetadata;&#xA;&#x9;&#x9;var metadataUrl;&#xA;&#x9;&#x9;if (answer == resultYes) {&#xA;&#x9;&#x9;&#x9;hasMetadata = true;&#xA;&#x9;&#x9;&#x9;metadataUrl = Session.Input(&#34;Metadata URL: &#34;);&#xA;&#x9;&#x9;&#x9;if (metadataUrl.length == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;No metadata URL given&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (answer == resultNo) {&#xA;&#x9;&#x9;&#x9;hasMetadata = false;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Unexpected answer&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// cvs format; in Danish&#xA;&#x9;&#x9;var options = '-o &#34;' + outputFolder + '&#34; -pkg ' + package.PackageGUID + ' -t csv -l da -p 10 ';&#xA;&#x9;&#x9;if (hasHeader) {&#xA;&#x9;&#x9;&#x9;options = options + &#34; -h &#34;;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (hasMetadata) {&#xA;&#x9;&#x9;&#x9;options = options + &#34; -m &#34; + metadataUrl;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-data-model-vocabulary.bat&#34;, options);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;openFolderInWindowsExplorer(outputFolder);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{5E129121-7FAF-4a79-A34E-C3BB045C7BA5}"/>
         <Column name="ScriptAuthor" value="{BF522BAE-AD19-4abb-8EA7-B7A030C7F6EA}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-concept-model&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;&#xA;/**&#xA; * Exports a concept model to a specific format. The package containing the concept model must be selected in the Project Browser.&#xA; *&#xA; * This script uses templates concept_model_rdf.ftlx and concept_model_asciidoc.ftl in %EAMT_HOME%/config/templates.&#xA; *&#xA; * @summary Exports a concept model.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (package != null &amp;&amp; package.ParentID != 0) {&#xA;&#x9;&#xA;&#x9;&#x9;var outputFolder = chooseFolderWithUI(&#34;Folder in which the exported concept model should be saved&#34;);&#xA;&#x9;&#x9;if (outputFolder.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;outputFormat = Session.Input(&#34;Output format: &#34;);&#xA;&#x9;&#x9;if (outputFormat.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No output format given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-concept-model.bat&#34;, &#34;-o &#34; + outputFolder + &#34; -pkg &#34; + package.PackageGUID + &#34; -t &#34; + outputFormat + &#34; -p 10&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;openFolderInWindowsExplorer(outputFolder);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{6899B6FC-ED87-4371-A1D7-D1D9EB10798D}"/>
         <Column name="ScriptAuthor" value="{2D4D14C7-61B2-4792-8F5F-00705AFB7436}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;retrieve-process-id-of-running-ea-instance&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._command-line-utils&#xA;&#xA;/**&#xA; * Retrieves the [Windows process id](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/finding-the-process-id) &#xA; * of the EA instance from which this script is invoked. That process id can be used as an argument to one of the applications&#xA; * in the EAMT Modelling Tools Java.&#xA; *&#xA; * @summary Retrieves the Windows process id of this EA instance.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;Session.Output(determineProcessId());&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{69F88BC7-43B2-45b9-BFFB-2A2F76A093D1}"/>
         <Column name="ScriptAuthor" value="{F97C6CA0-F5C0-4659-A8D1-D8251032F1A1}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;link-the-type-on-attributes-to-a-type-in-the-model&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._model-utils&#xA;&#xA;var LOGLEVEL_INFO = 2;&#xA;var LOGLEVEL_WARNING = 1;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA; &#xA; /**&#xA; * Purpose: change types to types found in the model.&#xA; *&#xA; * @author Styrelsen for Dataforsyning og Effektivisering&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var thePackage as EA.Package;&#xA;&#x9;thePackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;LOGInfo(&#34;Working on package '&#34; + thePackage.Name + &#34;' (ID=&#34; + thePackage.PackageID + &#34;)&#34; );&#xA;&#x9;&#xA;&#x9;if (thePackage != null &amp;&amp; thePackage.ParentID != 0) {&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(thePackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Working on &#34; + currentElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Attribute &#34; + currentAttribute.Name + &#34; with classifierId &#34; + currentAttribute.ClassifierID + &#34; and type &#34; + currentAttribute.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttribute.ClassifierID == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var foundElements as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foundElements = Repository.GetElementSet(&#34;SELECT * FROM t_object WHERE Name = '&#34; + currentAttribute.Type + &#34;'&#34;, 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Count: &#34; + foundElements.Count);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (foundElements.Count == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Not found: &#34; + currentAttribute.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (foundElements.Count == 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Found: &#34; + foundElements.GetAt(0).Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = foundElements.GetAt(0).ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'Boolean') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name Boolean, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{8887B7F7-C12C-4c24-99B4-BCA7B303291F}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {8887B7F7-C12C-4c24-99B4-BCA7B303291F} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'CharacterString') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name CharacterString, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{0A614EA9-13B7-4ebe-85ED-AA187D27CBD1}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {0A614EA9-13B7-4ebe-85ED-AA187D27CBD1} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'GM_Point') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name GM_Point, choose the one from ISO 19107!:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{3CC5A3E8-2ECA-4e42-B09C-935BD5D3B64A}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {3CC5A3E8-2ECA-4e42-B09C-935BD5D3B64A} from ISO 19107:2003&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'UomWeight') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name UomWeight, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{22EB37C8-C673-4636-ACFC-6FAF355A619D}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {22EB37C8-C673-4636-ACFC-6FAF355A619D} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;More than one &#34; + currentAttribute.Type + &#34; found in model, update the attributes with that type manually (access them via model search val_attribute_type)&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;thePackage.Elements.Refresh();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;LOGInfo( &#34;Done!&#34; );&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;Session.Prompt(&#34;This script requires a package to be selected in the Project Browser.\n&#34; +&#xA;&#x9;&#x9;&#x9;&#34;Please select a package in the Project Browser and try again.&#34;, promptOK);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{6EDAAE4E-3B45-4bc1-B4D6-2C1740B50233}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_logging-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with logging.&#xA; *&#xA; * You can change the log level at any time during execution by setting the LOGLEVEL variable&#xA; * in your script to the desired value. Valid values for LOGLEVEL are:&#xA; * - LOGLEVEL_ERROR&#xA; * - LOGLEVEL_WARNING&#xA; * - LOGLEVEL_INFO&#xA; * - LOGLEVEL_DEBUG&#xA; * - LOGLEVEL_TRACE&#xA; *&#xA; * This script is a JavaScript version of the original JScript-Logging from Sparx, and with more logical&#xA; * log levels (ERROR - WARNING - INFO - DEBUG - TRACE instead of ERROR - INFO - WARNING - DEBUG - TRACE).&#xA; * See also https://www.sparxsystems.com/forums/smf/index.php/topic,11082.msg149186.html.&#xA; */&#xA;&#xA;// LOGLEVEL values&#xA;var LOGLEVEL_ERROR = 0;&#xA;var LOGLEVEL_WARNING = 1;&#xA;var LOGLEVEL_INFO = 2;&#xA;var LOGLEVEL_DEBUG = 3;&#xA;var LOGLEVEL_TRACE = 4;&#xA;&#xA;// The level to log at; change if needed in your own script.&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Logs a message at the ERROR level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_ERROR or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGError(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_ERROR)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [ERROR]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the INFO level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_INFO or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGInfo(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_INFO)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [INFO]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the WARNING level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_WARNING or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGWarning(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_WARNING)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [WARNING]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the DEBUG level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_DEBUG or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGDebug(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_DEBUG)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [DEBUG]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the TRACE level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_TRACE or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGTrace(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_TRACE)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [TRACE]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Returns the current date/time in a format suitable for logging.&#xA; *&#xA; * @return {string} The current date/time&#xA; * @private&#xA; */&#xA;function _LOGGetDisplayDate() {&#xA;&#x9;var now = new Date();&#xA;&#xA;&#x9;// Pad hour value&#xA;&#x9;var hours = now.getHours();&#xA;&#x9;if (hours &lt; 10)&#xA;&#x9;&#x9;hours = &#34;0&#34; + hours;&#xA;&#xA;&#x9;// Pad minute value&#xA;&#x9;var minutes = now.getMinutes();&#xA;&#x9;if (minutes &lt; 10)&#xA;&#x9;&#x9;minutes = &#34;0&#34; + minutes;&#xA;&#xA;&#x9;// Pad second value&#xA;&#x9;var seconds = now.getSeconds();&#xA;&#x9;if (seconds &lt; 10)&#xA;&#x9;&#x9;seconds = &#34;0&#34; + seconds;&#xA;&#xA;&#x9;var displayDate = now.getFullYear() + &#34;-&#34; + (now.getMonth() + 1) + &#34;-&#34; + now.getDate();&#xA;&#x9;displayDate += &#34; &#34; + hours + &#34;:&#34; + minutes + &#34;:&#34; + seconds;&#xA;&#xA;&#x9;return displayDate;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{758532AB-EBA1-4ea6-B9C3-746814C64568}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_constants&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains constants used by EA or Windows. Taken from EAConstants-JScript in Local Scripts.&#xA; */&#xA;&#xA;/*&#xA; * Prompt types for Session.Prompt().&#xA; */&#xA;var promptOK&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 1;&#xA;var promptYESNO&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 2;&#xA;var promptYESNOCANCEL&#x9;&#x9;&#x9;&#x9;= 3;&#xA;var promptOKCANCEL&#x9;&#x9;&#x9;&#x9;&#x9;= 4;&#xA;&#xA;/*&#xA; * Prompt results from Session.Prompt().&#xA; */&#xA;var resultOK&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 1;&#xA;var resultCancel&#x9;&#x9;&#x9;&#x9;&#x9;= 2;&#xA;var resultYes&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 3;&#xA;var resultNo&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 4;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{7B773725-B9B8-40e5-9D79-FDD5E7F1BDFF}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_guid-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with working with UUIDs (universally unique identifiers).&#xA; */&#xA;&#xA;/**&#xA; * @param guid {string} GUID (Microsoft UUID, enclosed in curly braces {})&#xA; * @return {string} GUID without curly braces&#xA; */&#xA;function convertGuidToStandardRepresentation(guid) {&#xA;&#x9;if (guid.length != 38) {&#xA;&#x9;&#x9;var message = &#34;Length of &#34; + guid + &#34; is not 38, expected a UUID surrounded with curly braces&#34;;&#xA;&#x9;&#x9;throw message;&#xA;&#x9;}&#xA;&#x9;return guid.toLowerCase().substr(1,36);&#xA;}&#xA;&#xA;/**&#xA; * @param connectorGuid {string} GUID of the connector the connector end belongs to&#xA; * @param source {boolean} whether the connector is the source (true) or the target (false) of the connector&#xA; * @return GUID in XML of a connector end&#xA; */&#xA;function determineGuidAsXMLOfConnectorEnd(connectorGuid /* string */, source /* boolean */) {&#xA;&#x9;var connectorGuidAsXML = Repository.GetProjectInterface().GUIDtoXML(connectorGuid);&#xA;&#x9;var connectorGuidAsXML;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;connectorGuidAsXML = connectorGuidAsXML.substr(0, 5) + &#34;src&#34; + connectorGuidAsXML.substr(7);&#xA;&#x9;} else {&#xA;&#x9;&#x9;connectorGuidAsXML = connectorGuidAsXML.substr(0, 5) + &#34;dst&#34; + connectorGuidAsXML.substr(7);&#xA;&#x9;}&#xA;&#x9;return connectorGuidAsXML;&#xA;&#x9;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{81B4C325-AFBA-4885-8A0B-1C6FEE159E72}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_command-line-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains functions to provide the &#34;glue&#34; between a script in EA and a .bat file calling e.g. Java code.&#xA; */&#xA; !INC eamt-utilities._logging-utils&#xA;&#xA;var ENV_VARIABLE_LOCATION_TOOLS = &#34;EAMT_HOME&#34;;&#xA;&#xA;/**&#xA; * Provides access to aspects of the Windows Shell, such as applications, shortscuts, environment variables,&#xA; * the registry, and operating environment (from &#34;Windows Powershell Pocket References&#34; by Lee Holmes).&#xA; *&#xA; * See more on [WshShell Object](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/aew9yb99(v=vs.84))&#xA; */&#xA;var WSH_SHELL = new COMObject(&#34;WScript.Shell&#34;);&#xA;&#xA;/*&#xA; * Possible values for the type of popup (WSH_SHELL.Popup). Values can be added up to combine them.&#xA; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f(v=vs.84).&#xA; */&#xA;var PT_OK = 0;&#xA;var PT_OKCANCEL = 1;&#xA;var PT_ABORTRETRYIGNORE = 2;&#xA;var PT_YESNOCANCEL = 3;&#xA;var PT_YESNO = 4;&#xA;var PT_RETRYCANCEL = 5;&#xA;var PT_CANCELTRYCONTINUE = 6;&#xA;var PT_ICONSTOP = 16;&#xA;var PT_ICONQUESTION = 32;&#xA;var PT_ICONEXCLAMATION = 48;&#xA;var PT_ICONINFORMATION = 64;&#xA;var PT_DEFBUTTON2 = 256;&#xA;var PT_DEFBUTTON3 = 512;&#xA;&#xA;/*&#xA; * Possible return values of WSH_SHELL.Popup method.&#xA; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f(v=vs.84).&#xA; */&#xA;var BTN_NONECLICKED = -1;&#xA;var BTN_OK = 1;&#xA;var BTN_CANCEL = 2;&#xA;var BTN_ABORT = 3;&#xA;var BTN_RETRY = 4;&#xA;var BTN_IGNORE = 5;&#xA;var BTN_YES = 6;&#xA;var BTN_NO = 7;&#xA;var BTN_TRYAGAIN = 10;&#xA;var BTN_CONTINUE = 11;&#xA;&#xA;/**&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} arguments to give to the .bat file&#xA; */&#xA;function runBatFileInDefaultWorkingDirectory(batFileToInvoke, programArguments) {&#xA;&#x9;runBatFileInSpecifiedWorkingDirectory(WSH_SHELL.ExpandEnvironmentStrings(&#34;%&#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34;%&#34;), batFileToInvoke, programArguments);&#xA;}&#xA;&#xA;/**&#xA; * @param {string} workingDirectory working directory&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} arguments to give to the .bat file&#xA; */&#xA;function runBatFileInSpecifiedWorkingDirectory(workingDirectory, batFileToInvoke, programArguments) {&#xA;&#x9;var processId = determineProcessId(workingDirectory);&#xA;&#x9;if (processId != &#34;-1&#34;) {&#xA;&#x9;&#x9;runBatFileInSpecifiedWorkingDirectoryWithProcessId(workingDirectory, batFileToInvoke, processId, programArguments);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(&#34;Cannot proceed, stopping here.&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param {string} workingDirectory working directory&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} processId the process id of the running EA instance&#xA; * @param {string} arguments to give to the .bat file&#xA; * @private&#xA; */&#xA;function runBatFileInSpecifiedWorkingDirectoryWithProcessId(workingDirectory, batFileToInvoke, processId, programArguments) {&#xA;&#x9;var environmentString = &#34;%&#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34;%&#34;;&#xA;&#x9;var locationDMT = WSH_SHELL.ExpandEnvironmentStrings(environmentString);&#xA;&#x9;if (environmentString == locationDMT) {&#xA;&#x9;&#x9;LOGError(&#34;Environment variable &#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34; not set, set this environment variable and restart Enterprise Architect&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;} else {&#xA;&#x9;&#x9;var command = '&#34;' + locationDMT + '\\bin\\' + batFileToInvoke + '&#34;' + &#34; -eapid &#34; + processId + &#34; &#34; + programArguments;&#xA;&#x9;&#x9;LOGInfo(&#34;command: &#34; + command);&#xA;&#x9;&#x9;runCommand(workingDirectory, command);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Determines the process id of the running EA instance based on the Windows tasklist command.&#xA; *&#xA; * @return {string} process id of the running EA instance&#xA; */&#xA;function determineProcessId() {&#xA;&#x9;var processId;&#xA;&#x9;var command = 'TASKLIST /V /FO CSV /NH /FI &#34;IMAGENAME eq EA.exe&#34; /FI &#34;WINDOWTITLE eq ' + getWindowTitleForInstanceOfEA() + '&#34;';&#xA;&#x9;LOGInfo(command);&#xA;&#x9;var wse = WSH_SHELL.Exec(command); // returns WshScriptExec Object, see https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/2f38xsxe%28v%3dvs.84%29&#xA;&#x9;while (wse.Status == 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Retrieving process id&#34;);&#xA;&#x9;&#x9;// alternative way of &#34;sleeping&#34;&#xA;&#x9;&#x9;// see also https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f%28v%3dvs.84%29&#xA;&#x9;&#x9;// see also http://www.sparxsystems.com/forums/smf/index.php/topic,6063.msg127934.html&#xA;&#x9;&#x9;WSH_SHELL.Popup(&#34;Retrieving process id&#34;, 1, &#34;Info message&#34;, PT_OK + PT_ICONINFORMATION);&#xA;&#x9;}&#xA;&#x9;if (!wse.StdOut.AtEndOfStream) {&#xA;&#x9;&#x9;var output = wse.StdOut.ReadAll();&#xA;&#x9;&#x9;LOGInfo(output);&#xA;&#x9;&#x9;if (output.indexOf(&#34;No tasks are running which match the specified criteria&#34;) != -1) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Is the command correct? Check the script.&#34;);&#xA;&#x9;&#x9;&#x9;processId = &#34;-1&#34;;&#xA;&#x9;&#x9;} else if (output.search(/\n&#34;EA.exe&#34;/g) != -1) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;More than one task found. Is the command correct? Check the script.&#34;);&#xA;&#x9;&#x9;&#x9;processId = &#34;-1&#34;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;// process id is the second value: &#34;EA.exe&#34;,&#34;4852&#34;,...&#xA;&#x9;&#x9;&#x9;outputAsArray = output.split(&#34;,&#34;);&#xA;&#x9;&#x9;&#x9;processIdWithQuotes = outputAsArray[1];&#xA;&#x9;&#x9;&#x9;processId = processIdWithQuotes.substring(1, processIdWithQuotes.lastIndexOf('&#34;'));&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;process id=&#34; + processId);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (!wse.StdErr.AtEndOfStream) {&#xA;&#x9;&#x9;LOGError(wse.StdErr.ReadAll());&#xA;&#x9;&#x9;processId = -1;&#xA;&#x9;}&#xA;&#x9;return processId;&#xA;}&#xA;&#xA;/**&#xA; * Use for calling Java, that writes the output back to the Script window.&#xA; * &#xA; * @param directory {string}&#xA; * @param command {string}&#xA; */&#xA;function runCommand(directory, command) {&#xA;&#x9;var commandFinishedSuccessfully;&#xA;&#x9;&#xA;&#x9;WSH_SHELL.CurrentDirectory = directory;&#xA;&#x9;LOGInfo(&#34;Current directory: &#34;+ WSH_SHELL.CurrentDirectory);&#xA;&#xA;&#x9;/*&#xA;&#x9; * The Run command returns an integer.&#xA;&#x9; * The 3rd argument is true: wait for the program to finish executing before continuing to the next statement in your script.&#xA;&#x9; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/d5fk67ky(v=vs.84)&#xA;&#x9; */&#xA;&#x9;var result = WSH_SHELL.Run(command, 1, true);&#xA;&#x9;if (result == 0) {&#xA;&#x9;&#x9;commandFinishedSuccessfully = true;&#xA;&#x9;} else {&#xA;&#x9;&#x9;commandFinishedSuccessfully = false;&#xA;&#x9;}&#xA;&#x9;return commandFinishedSuccessfully;&#xA;}&#xA;&#xA;/**&#xA; * Executes a command in the given directory (currently not used, kept for reference, comes from the earlier _ShellHelperFunctions)&#xA; *&#xA; * @param directory {string}&#xA; * @param command {string}&#xA; * @return {boolean} whether or not the command finished successfully&#xA; */&#xA;function executeCommand(directory, command) {&#xA;&#x9;var commandFinishedSuccessfully = true;&#xA;&#x9;&#xA;&#x9;WSH_SHELL.CurrentDirectory = directory;&#xA;&#x9;LOGInfo(&#34;Current directory: &#34;+ WSH_SHELL.CurrentDirectory);&#xA;&#xA;&#x9;var wse = WSH_SHELL.Exec(command);&#xA;&#x9;while (wse.Status == 0) {&#xA;&#x9;&#x9;// see also https://msdn.microsoft.com/en-us/library/x83z1d9f(v=vs.84).aspx&#xA;&#x9;&#x9;// see also http://www.sparxsystems.com/forums/smf/index.php/topic,6063.msg127934.html&#xA;&#x9;&#x9;var message = 'Waiting for command &#34;' + command + '&#34; to finish.';&#xA;&#x9;&#x9;LOGInfo(message);&#xA;&#x9;&#x9;// alternative way of &#34;sleeping&#34;&#xA;&#x9;&#x9;WSH_SHELL.Popup(message, 1, &#34;Info message&#34;, PT_OK + PT_ICONINFORMATION);&#xA;&#x9;}&#xA;&#x9;if (!wse.StdOut.AtEndOfStream) {&#xA;&#x9;&#x9;LOGInfo(wse.StdOut.ReadAll());&#xA;&#x9;}&#xA;&#x9;if (!wse.StdErr.AtEndOfStream) {&#xA;&#x9;&#x9;LOGError(wse.StdErr.ReadAll());&#xA;&#x9;&#x9;commandFinishedSuccessfully = false;&#xA;&#x9;}&#xA;&#x9;return commandFinishedSuccessfully;&#xA;}&#xA;&#xA;/**&#xA; * @return {string} &#34;test - Enterprise Architect&#34; when the model is located in C:\Users\username\Documents\test.eapx&#xA; * @private&#xA; */&#xA;function getWindowTitleForInstanceOfEA() {&#xA;&#x9;var windowTitle = getFileNameWithoutExtensionForInstanceOfEA() + &#34; - Enterprise Architect&#34;;&#xA;&#x9;return windowTitle;&#xA;}&#xA;&#xA;/**&#xA; * @return {string} &#34;test&#34; when the full path is C:\Users\username\Documents\test.eapx&#xA; * @private&#xA; */&#xA;function getFileNameWithoutExtensionForInstanceOfEA() {&#xA;&#x9;var connectionString = Repository.ConnectionString;&#xA;&#x9;LOGInfo(connectionString);&#xA;&#x9;var fileName = connectionString.substring(connectionString.lastIndexOf(&#34;\\&#34;) + 1, connectionString.lastIndexOf(&#34;.&#34;));&#xA;&#x9;return fileName;&#xA;}&#xA;&#xA;/*&#xA; * Method does not work, but keep code here to document what has been tried.&#xA; */&#xA;// function determineProcessIdDoesNotWork(workingDirectory) {&#xA;&#x9;// var processId;&#xA;&#x9;// var locator = new COMObject(&#34;WbemScripting.SWbemLocator&#34;); // see https://docs.microsoft.com/en-us/windows/win32/wmisdk/swbemlocator&#xA;&#x9;// var service = locator.ConnectServer(&#34;.&#34;, &#34;\\root\\cimv2&#34;);&#xA;&#x9;// var query = &#34;SELECT * FROM Win32_Process WHERE Name = 'EA.exe'&#34;; // see https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process&#xA;&#x9;// var processes = service.ExecQuery(query); // ExecQuery() returns an SWbemObjectSet, see https://docs.microsoft.com/en-us/windows/win32/wmisdk/swbemobjectset&#xA;&#x9;// Session.Output(&#34;count=&#34; + processes.Count);&#xA;&#x9;// /*&#xA;&#x9; // * And now how to iterate over processes? Far from trivial using JavaScript.&#xA;&#x9; // * See https://dentrassi.de/2011/02/04/access-to-wmi-in-java-using-eclipse-swt-ole-integration/&#xA;&#x9; // * and https://stackoverflow.com/questions/20386875/iterating-over-swbempropertyset-objects&#xA;&#x9; // * and https://theroadtodelphi.com/2010/12/01/accesing-the-wmi-from-pascal-code-delphi-oxygene-freepascal/&#xA;&#x9; // * for some inspiration (but no working solution found yet for Javascript).&#xA;&#x9; // * &#xA;&#x9; // * Tried the for/of loop, but &#34;processes is not iterable&#34;.&#xA;&#x9; // */&#xA;&#x9;// return processId;&#xA;// }"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{851C8EBF-17AB-4d25-A6B9-3DD80DF7EE12}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;move-grunddata1-to-grunddata2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;/**&#xA; * Change the stereotypes on package's, element's, attributes and roles from Grundata 1.2 uml-profile to the Grunddata 2.0 uml-profile.&#xA; * Copies data for Grundata 1.2 tags to Grunddata 2.0 when posible&#xA; *&#xA; * Requirement : Grunddata2MDG.xml needs to be installed for the script to work.&#xA; *&#xA; * Not all mandatory Grunddata 2.0 tags can be filled out from Grunddata 1.2 tags, so to be Grunddata 2.0 compliant further Grunddata 2.0 tags needs to be set.&#xA; *&#xA; * @summary Upgrade a model from model rules&#x9;&#34;modelregler for Grunddata version 1.2&#34; &#xA; *&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;  to model rules&#x9;&#34;modelregler for Grunddata version 2.0&#34;&#xA; */&#xA; &#xA;const connectorSet = new Set();&#xA;var elementNumber = 0;&#xA;var attributeNumber = 0;&#xA;var enumNumber = 0;&#xA;var roleNumber = 0;&#xA;&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var packageMain as EA.Package;&#xA;&#x9;packageMain = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (packageMain != null &amp;&amp; packageMain.ParentID != 0) &#xA;&#x9;{&#xA;&#x9;&#x9;var packageElement as EA.Element;&#xA;&#x9;&#x9;packageElement = packageMain.Element;&#xA;&#x9;&#x9;packageElement.StereotypeEx = &#34;DKDomÃ¦nemodel&#34;;&#xA;&#x9;&#x9;Repository.SynchProfile(&#34;Grunddata2&#34;, &#34;DKDomÃ¦nemodel&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34;Upgrade model &#34;+ packageElement.Name + &#34; to modelregler for Grunddata version 2.0&#34; );&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;packageElement.Update;&#xA;&#x9;&#x9;setGrunddata2PackageTags(packageElement)&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;elements = packageMain.Elements;&#xA;&#x9;&#x9;for (var i = 1 ; i &lt; elements.Count ; i++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;currentElement = elements.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;Change Stereotype on: &#34; + currentElement.Name + &#34;Type: &#34; + currentElement.Type + &#34;Stereotype: &#34; + currentElement.FQStereotype);&#xA;&#x9;&#x9;&#x9;if(currentElement.FQStereotype == &#34;Grunddata::DKObjekttype&#34; || currentElement.FQStereotype == &#34;Geodata::DKFeaturetype&#34; || currentElement.FQStereotype == &#34;Geodata::DKObjekttype&#34;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;\nChange stereotype on: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;copyGrunddataTags(currentElement)&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.StereotypeEx = &#34;Grunddata2::DKObjekttype&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;&#x9;changeAttributeTags(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;changeConnectorEndStereotype(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;elementNumber++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(currentElement.FQStereotype == &#34;Grunddata::DKKodeliste&#34;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;\nChange stereotype on: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;copyGrunddataTags(currentElement)&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.StereotypeEx = &#34;Grunddata2::DKKodeliste&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;&#x9;elementNumber++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(currentElement.FQStereotype == &#34;Grunddata::DKDatatype&#34;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;\nChange stereotype on: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;copyGrunddataTags(currentElement)&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.StereotypeEx = &#34;Grunddata2::DKDatatype&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;&#x9;changeAttributeTags(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;elementNumber++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(currentElement.FQStereotype == &#34;Grunddata::DKEnumeration&#34; )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;\nChange stereotype on: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;var newPackage as EA.Package;&#xA;&#x9;&#x9;&#x9;&#x9;newPackage = packageMain.Packages.AddNew(currentElement.Name, null );&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;newPackage.Update();&#xA;&#x9;&#x9;&#x9;&#x9;newPackage.StereotypeEx = &#34;DKKlassifikationsmodel&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;newPackage.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;  Create new Pakage DKKlassifikationsmodel: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var PI = newPackage.PackageID;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.PackageID = PI;&#xA;&#x9;&#x9;&#x9;&#x9;copyGrunddataTags(currentElement);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.StereotypeEx = &#34;Grunddata2::DKEnumeration&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;&#x9;changeEnumTags(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;elementNumber++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;for (var j = 0 ; j &lt; elements.Count ; j++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;currentElement = elements.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(currentElement.FQStereotype == &#34;Grunddata2::DKObjekttype&#34; || currentElement.FQStereotype == &#34;Grunddata2::DKEnumeration&#34; || currentElement.FQStereotype == &#34;Grunddata2::DKKodeliste&#34; || currentElement.FQStereotype == &#34;Grunddata2::DKDatatype&#34;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;Copy tags on: &#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var definition = getTaggedValueElement(currentElement, &#34;definition_copy&#34;, &#34;&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;setTaggedValueElement(currentElement, &#34;definition (da)&#34;, definition);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;definition_copy&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;definition&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var description = getTaggedValueElement(currentElement, &#34;description_copy&#34;, &#34;&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;setTaggedValueElement(currentElement, &#34;comment (da)&#34;, description);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;description_copy&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;note&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var description = getTaggedValueElement(currentElement, &#34;legalSource_copy&#34;, &#34;&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;setTaggedValueElement(currentElement, &#34;legalSource&#34;, description);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;legalSource_copy&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;lovgrundlag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var description = getTaggedValueElement(currentElement, &#34;example_copy&#34;, &#34;&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;setTaggedValueElement(currentElement, &#34;example (da)&#34;, description);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;example_copy&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;eksempel&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var description = getTaggedValueElement(currentElement, &#34;alternativLabel_copy&#34;, &#34;&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;setTaggedValueElement(currentElement, &#34;altLabel (da)&#34;, description);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;alternativLabel_copy&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, &#34;alternativtNavn&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34;\nSummary&#34; );&#xA;&#x9;&#x9;Session.Output(&#34;Changed stereotype on &#34;+ elementNumber + &#34; elements&#34; );&#xA;&#x9;&#x9;Session.Output(&#34;Changed stereotype on &#34;+ attributeNumber + &#34; attributes&#34; );&#xA;&#x9;&#x9;Session.Output(&#34;Changed tags on &#34;+ enumNumber + &#34; enums&#34; );&#xA;&#x9;&#x9;Session.Output(&#34;Changed stereotype on &#34;+ roleNumber + &#34; roles&#34; );&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Repository.RefreshModelView(packageMain.PackageID);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;} else &#xA;&#x9;{&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Copies grunddata element tags to a temporary copy&#xA;*&#xA;*/&#xA;function copyGrunddataTags(currentElement)&#xA;{&#xA;&#x9;var definition = getTaggedValueElement(currentElement, &#34;definition&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentElement, &#34;definition_copy&#34;, definition);&#xA;&#x9;&#xA;&#x9;var description = getTaggedValueElement(currentElement, &#34;note&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentElement, &#34;description_copy&#34;, description);&#xA;&#x9;&#xA;&#x9;var legalSource = getTaggedValueElement(currentElement, &#34;lovgrundlag&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentElement, &#34;legalSource_copy&#34;, legalSource);&#xA;&#x9;&#xA;&#x9;var example = getTaggedValueElement(currentElement, &#34;eksempel&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentElement, &#34;example_copy&#34;, example);&#xA;&#x9;&#xA;&#x9;var alternativLabel = getTaggedValueElement(currentElement, &#34;alternativtNavn&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentElement, &#34;alternativLabel_copy&#34;, alternativLabel);&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Copies grunddata attribute tags to a temporary copy&#xA;*&#xA;*/&#xA;function copyGrunddataTagsAttribute(currentAttribute)&#xA;{&#xA;&#x9;var definition = getTaggedValueAttribute(currentAttribute, &#34;definition&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;definition_copy&#34;, definition);&#xA;&#x9;&#xA;&#x9;var description = getTaggedValueAttribute(currentAttribute, &#34;note&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;description_copy&#34;, description);&#xA;&#x9;&#xA;&#x9;var legalSource = getTaggedValueAttribute(currentAttribute, &#34;lovgrundlag&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;legalSource_copy&#34;, legalSource);&#xA;&#x9;&#xA;&#x9;var example = getTaggedValueAttribute(currentAttribute, &#34;eksempel&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;example_copy&#34;, example);&#xA;&#x9;&#xA;&#x9;var alternativLabel = getTaggedValueAttribute(currentAttribute, &#34;alternativtNavn&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;alternativLabel_copy&#34;, alternativLabel);&#xA;}&#xA;&#xA;&#xA;/**&#x9;&#xA;* Updates grunddata2 attribute tags from the temporary copy&#xA;*&#xA;*/&#xA;function updateGrunddata2TagsAttribute(currentAttribute)&#xA;{&#xA;&#x9;//Session.Output(&#34;currentAttribute update: &#34; + currentAttribute.Name );&#xA;&#x9;&#xA;&#x9;var definition = getTaggedValueAttribute(currentAttribute, &#34;definition_copy&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;definition (da)&#34;, definition);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;definition_copy&#34;);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;definition&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;var description = getTaggedValueAttribute(currentAttribute, &#34;description_copy&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;comment (da)&#34;, description);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;description_copy&#34;);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;note&#34;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;var legalSource = getTaggedValueAttribute(currentAttribute, &#34;legalSource_copy&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;legalSource&#34;, legalSource);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;legalSource_copy&#34;);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;lovgrundlag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;var example = getTaggedValueAttribute(currentAttribute, &#34;example_copy&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;example (da)&#34;, example);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;example_copy&#34;);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;eksempel&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;var alternativLabel = getTaggedValueAttribute(currentAttribute, &#34;alternativLabel_copy&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueAttribute(currentAttribute, &#34;altLabel (da)&#34;, alternativLabel);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;alternativLabel_copy&#34;);&#xA;&#x9;deleteTaggedValueAttribute(currentAttribute, &#34;alternativtNavn&#34;);&#xA;&#x9;&#xA;&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Change Stereotype on attributes from Grunddata::DKEgenskab to Grunddata2::DKEgenskab&#xA;*&#xA;*/&#xA;function changeAttributeTags(currentElement)&#xA;{&#xA;&#x9;var attributes as EA.Collection;&#xA;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;for (var i = 0; i &lt; attributes.Count; i++) &#xA;&#x9;{&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(i);&#xA;&#x9;&#x9;Session.Output(&#34;  Change stereotype on attribute: &#34; + currentAttribute.Name );&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;copyGrunddataTagsAttribute(currentAttribute);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;currentAttribute.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;attributeNumber++;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;Repository.SynchProfile(&#34;Grunddata2&#34;, &#34;DKEgenskab&#34;);&#xA;&#x9;&#xA;&#x9;for (var j = 0; j &lt; attributes.Count; j++) &#xA;&#x9;{&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;updateGrunddata2TagsAttribute(currentAttribute);&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Change tags on enums from Grunddata::DKEgenskab to Grunddata2::DKEgenskab&#xA;*&#xA;*/&#xA;function changeEnumTags(currentElement)&#xA;{&#xA;&#x9;var attributes as EA.Collection;&#xA;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;for (var i = 0; i &lt; attributes.Count; i++) &#xA;&#x9;{&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(i);&#xA;&#x9;&#x9;Session.Output(&#34;  Change tags on enum: &#34; + currentAttribute.Name );&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;copyGrunddataTagsAttribute(currentAttribute);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;currentAttribute.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;Repository.SynchProfile(&#34;Grunddata2&#34;, &#34;DKEgenskab&#34;);&#xA;&#x9;&#xA;&#x9;for (var j = 0; j &lt; attributes.Count; j++) &#xA;&#x9;{&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;updateGrunddata2TagsAttribute(currentAttribute);&#xA;&#x9;}&#xA;&#xA;&#x9;for (var i = 0; i &lt; attributes.Count; i++) &#xA;&#x9;{&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(i);&#xA;&#x9;&#xA;&#x9;&#x9;currentAttribute.StereotypeEx = &#34;&#34;;&#xA;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;enumNumber++;&#xA;&#x9;}&#xA;&#xA;&#x9;&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Change stereotype on roles on association connectors from Grunddata::DKEgenskab to Grunddata2::DKEgenskab&#xA;*&#xA;*/&#xA;function changeConnectorEndStereotype(currentElement)&#xA;{&#xA;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;var clientEnd as EA.ConnectorEnd;&#xA;&#x9;var supplierEnd as EA.ConnectorEnd;&#xA;&#x9;&#xA;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;for (var i = 0 ; i &lt; connectors.Count ; i++)&#xA;&#x9;{&#xA;&#x9;&#x9;currentConnector = connectors.GetAt(i);&#xA;&#x9;&#x9;if(currentConnector.Type == &#34;Association&#34; )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;  Association name: &#34; + currentConnector.Name );&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Role.length &gt; 0)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Repository.SynchProfile(&#34;Grunddata2&#34;, &#34;DKEgenskab&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;changeConnectorEndTag(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;  Change stereotype on role: &#34; + clientEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;roleNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Role.length &gt; 0)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Repository.SynchProfile(&#34;Grunddata2&#34;, &#34;DKEgenskab&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;changeConnectorEndTag(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;  Change stereotype on role: &#34; + supplierEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;roleNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#x9;&#xA;/**&#x9;&#xA;* Copy role tags from grunddata1 tags to grunddata2 tags&#xA;*&#xA;*/&#xA;function changeConnectorEndTag(connector, source)&#xA;{&#xA;&#x9;//Session.Output(&#34;currentAttribute update: &#34; + currentAttribute.Name );&#xA;&#x9;&#xA;&#x9;var definition = getTaggedValueConnectorEnd(connector, &#34;definition&#34;, source, &#34;&#34;);&#xA;&#x9;if (definition.length &gt; 0)&#xA;&#x9;{&#xA;&#x9;&#x9;//Session.Output(&#34;   Source &#34; + source +&#34;  Definition role: &#34; + definition );&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, &#34;definition (da)&#34;, definition, source)&#xA;&#x9;}&#xA;&#x9;deleteTaggedValueConnectorEnd(connector, &#34;definition&#34;, source)&#xA;&#x9;&#xA;&#x9;var description = getTaggedValueConnectorEnd(connector, &#34;note&#34;, source, &#34;&#34;);&#xA;&#x9;if (description.length &gt; 0)&#xA;&#x9;{&#x9;&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, &#34;comment (da)&#34;, description, source)&#xA;&#x9;}&#xA;&#x9;deleteTaggedValueConnectorEnd(connector, &#34;note&#34;, source)&#xA;&#x9;&#xA;&#x9;var legalSource = getTaggedValueConnectorEnd(connector, &#34;lovgrundlag&#34;, source, &#34;&#34;);&#xA;&#x9;if (legalSource.length &gt; 0)&#xA;&#x9;{&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, &#34;legalSource&#34;, legalSource, source)&#xA;&#x9;}&#xA;&#x9;deleteTaggedValueConnectorEnd(connector, &#34;lovgrundlag&#34;, source)&#xA;&#x9;&#xA;&#x9;var example = getTaggedValueConnectorEnd(connector, &#34;eksempel&#34;, source, &#34;&#34;);&#xA;&#x9;if (example.length &gt; 0)&#xA;&#x9;{&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, &#34;example (da)&#34;, example, source)&#xA;&#x9;}&#xA;&#x9;deleteTaggedValueConnectorEnd(connector, &#34;eksempel&#34;, source)&#xA;&#x9;&#x9;&#xA;&#x9;var alternativLabel = getTaggedValueConnectorEnd(connector, &#34;alternativtNavn&#34;, source, &#34;&#34;);&#xA;&#x9;if (example.length &gt; 0)&#xA;&#x9;{&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, &#34;altLabel (da)&#34;, alternativLabel, source)&#xA;&#x9;}&#xA;&#x9;deleteTaggedValueConnectorEnd(connector, &#34;alternativtNavn&#34;, source)&#xA;}&#xA;&#xA;/**&#x9;&#xA;* Sets the Grunddata2 package tags using Grundata1 Tags&#xA;*&#xA;*/&#xA;function setGrunddata2PackageTags(currentPackageElement)&#xA;{&#xA;&#x9;var responsibleEntity = getTaggedValueElement(currentPackageElement, &#34;registermyndighed&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentPackageElement, &#34;responsibleEntity&#34;, responsibleEntity);&#xA;&#x9;deleteTaggedValueElement(currentPackageElement, &#34;registermyndighed&#34;);&#xA;&#x9;&#xA;&#x9;var versionInfo = getTaggedValueElement(currentPackageElement, &#34;version&#34;, &#34;&#34;);&#xA;&#x9;setTaggedValueElement(currentPackageElement, &#34;versionInfo&#34;, versionInfo);&#xA;&#x9;deleteTaggedValueElement(currentPackageElement, &#34;version&#34;);&#xA;&#x9;&#xA;&#x9;deleteTaggedValueElement(currentPackageElement, &#34;status&#34;);&#xA;&#x9;&#xA;&#x9;deleteTaggedValueElement(currentPackageElement, &#34;modeldomÃ¦ne&#34;);&#xA;&#x9;&#xA;&#x9;deleteTaggedValueElement(currentPackageElement, &#34;forvaltingsopgave&#34;);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{947114B1-6376-4c46-A6DE-E5E039EF48F9}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validate-model-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;!INC eamt-val-data-model-validation.validation-scripts-basic-data2&#xA;&#xA;/**&#xA; * Script to validate any model against the basic data model rules version 2 &#xA; * (http://grunddatamodel.datafordeler.dk/modelregler/grunddatamodelregler.html).&#xA; * &#xA; * Select a model in the Project Browser and run this script in order to validate it.&#xA; *&#xA; * @summary Validate a model against the basic data model rules version 2.&#xA; */&#xA;function main() {&#xA;&#x9;&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;var selectedPackage as EA.Package;&#x9;&#xA;&#x9;var now = new Date();&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#x9;&#xA;&#x9;&#xA;&#x9;// set log level to error as the output should only contain the validation report, no log messages&#xA;&#x9;LOGLEVEL = -1;&#xA;&#x9;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Dette er valideringsrapporten for modellen '&#34; + selectedPackage.Name + &#34;' udarbejdet af Modelsekretariatet d. &#34; + now.getDate() + &#34;/&#34; + (now.getMonth() + 1) + &#34; &#34; + now.getFullYear() + &#34;.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;________________________________________________________________________________________________________________&#34;)&#xA;&#x9;&#x9;/*&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.1: Brug UML som det visuelle modelsprog&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.2: Brug kun udvalgte UML-elementer&#34;);&#xA;&#x9;&#x9;umlElementer(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.3: Brug UML-stereotyper&#34;);&#xA;&#x9;&#x9;stereotypes(selectedPackage,elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.4: Angiv meningsfyldte navne og beskrivelser for modellen&#34;);&#xA;&#x9;&#x9;modeltags1(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Beskrivelser og titler bÃ¸r kontrolleres manuelt, for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.5: Angiv identifikation af modeller&#34;);&#xA;&#x9;&#x9;modeltags2(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.6: Angiv den modelansvarlige organisation&#34;);&#xA;&#x9;&#x9;modeltags3(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.7: Angiv emneomrÃ¥de for modellen&#34;);&#xA;&#x9;&#x9;modeltags4(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.8: Angiv modellens version&#34;);&#xA;&#x9;&#x9;modeltags5(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.9: Modellen skal godkendes&#34;);&#xA;&#x9;&#x9;modeltags6(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Efter endt kontrol og konformanstjek, bÃ¸r modellens status tilrettes.&#34;);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.10: Angiv modellens modelstatus&#34;);&#x9;&#xA;&#x9;&#x9;modeltags7(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.11: Angiv modellens lovgrundlag og kilde&#34;);&#xA;&#x9;&#x9;modeltags8(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens 'legalSource' bÃ¸r tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.12: Modeller klassifikationer til genbrug&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.13: God diagrammeringsskik&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.1: Angiv meningsfyldte UML-navne for modelelementer&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;*/&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.2: Giv alle modelelementer en identifikator&#34;);&#xA;&#x9;&#x9;identifikator(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'URI' bÃ¸r tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;/*&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.3: Angiv termer i et naturligt sprog&#34;);&#xA;&#x9;&#x9;sprog(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'prefLabelValue' bÃ¸r tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.4: Brug standardiserede konventioner for angivelse af navne&#34;);&#xA;&#x9;&#x9;checkCamel(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.5: Udarbejd definitioner eller beskrivelser af modellens elementer&#34;);&#xA;&#x9;&#x9;checkDef(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.6: Udarbejd strukturerede definitioner pÃ¥ en standardiseret mÃ¥de&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.7: Udarbejd anvendelsesneutrale definitioner&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.8: Angiv modelelementers lovgrundlag&#34;);&#xA;&#x9;&#x9;checkLegal(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'legalSource' bÃ¸r tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.9: Brug standardiserede primitive datatyper&#34;);&#xA;&#x9;&#x9;ISOtype(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.10: Angiv historikmodel for grunddataobjekttyper&#34;);&#xA;&#x9;&#x9;historik(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.1: Alle grunddataobjekttyper skal modelleres med persistent, unik identifikation&#34;);&#xA;&#x9;&#x9;checkID(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.2: Alle grunddataobjekttyper skal understÃ¸tte registreringstid&#34;);&#xA;&#x9;&#x9;checkReg(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.3: Grunddataobjekttyper bÃ¸r understÃ¸tte virkningstid&#34;);&#xA;&#x9;&#x9;checkVirk(elements);&#xA;&#x9;&#x9;historikReg(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.4: Alle grunddataobjekttyper bÃ¸r modelleres med status&#34;);&#xA;&#x9;&#x9;Session.Output(checkAttr(elements,&#34;status&#34;));&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.5: Alle modelentiteter bÃ¸r understÃ¸tte beskedfordeling&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;ForretningshÃ¦ndelse: &#34; + checkAttr(elements,&#34;forretningshÃ¦ndelse&#34;));&#xA;&#x9;&#x9;Session.Output(&#34;Forretningsproces: &#34; + checkAttr(elements,&#34;forretningsproces&#34;));&#xA;&#x9;&#x9;*/&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;***** Rapport afsluttet &#34; + _LOGGetDisplayDate() +&#34; *****&#34;);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;LOGInfo(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{B99975E0-30D7-4a05-9528-FC67CE1785EA}"/>
         <Column name="ScriptAuthor" value="{FAD5FD80-AFAF-4797-8BFB-44A019438349}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_fda-concept-model-constants&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="var PROFILENAME = &#34;FDAprofil&#34;;&#xA;var STEREOTYPE_CONCEPTMODEL = &#34;FDAprofil::ConceptModel&#34;;&#xA;var STEREOTYPE_CONCEPT = &#34;FDAprofil::Concept&#34;;&#xA;&#xA;var TAG_URI = &#34;URI&#34;;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{BE325D69-1748-4ce6-A3EF-ACEC83808D26}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validation-scripts-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/*&#xA; * @file Functions specifically made to test the validity of a model against the model data rules version 2.0.&#xA; */&#xA;const upperCamel = [&#34;Class&#34;, &#34;Association class&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;]; &#xA;const lowerCamel = [&#34;Aggregation&#34;, &#34;Association&#34;, &#34;Role&#34;, &#34;Attribute&#34;]; &#xA;const allowedUMLelements = [&#34;Aggregation&#34;, &#34;Class&#34;, &#34;Generalization&#34;, &#34;Association class&#34;, 'Association', &#34;Composition&#34;, &#34;Role&#34;, &#34;Attribute&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;, &#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;]; &#xA;const omitUMLelements = [&#34;ProxyConnector&#34;,&#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;];&#xA;const allowedstereotypesModel = [&#34;Grunddata2::DKDomÃ¦nemodel&#34;, &#34;Grunddata2::DKKlassifikationsmodel&#34;, &#34;DKDomÃ¦nemodel&#34;, &#34;DKKlassifikationsmodel&#34;];&#xA;const allowedstereotypesElement = [&#34;Grunddata2::DKObjekttype&#34;, &#34;Grunddata2::DKDatatype&#34;,&#34;Grunddata2::DKEnumeration&#34;, &#34;Grunddata2::DKKodeliste&#34;];&#xA;const allowedstereotypesAttributeRole = &#34;DKEgenskab&#34;;&#xA;var elementIDlist = [];&#xA;&#xA;/**&#xA; * Validate if the selected model uses the correct UML model elements following the basic data model rules version 2.&#xA; */&#xA;function umlElementer(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' og type '&#34; + currentElement.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------connectors---------------&#34;)&#xA;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//do nothing;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' og type '&#34; + currentConnector.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation'){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Name == null || currentConnector.Name == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No name on connector associated with element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Navn pÃ¥ connector tilknyttet elementet '&#34; + currentElement.Name + &#34;' mangler.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Direction == &#34;Unspecified&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No direction on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Retning mangler pÃ¥ connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((clientEnd.Role == null || clientEnd.Role == &#34;&#34;) &amp;&amp; (supplierEnd.Role == null || supplierEnd.Role== &#34;&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No roles on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Rolle(r) mangler pÃ¥ connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Cardinality == null || clientEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + clientEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + clientEnd.Role + &#34;' pÃ¥ connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Cardinality == null || supplierEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + supplierEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + supplierEnd.Role + &#34;' pÃ¥ connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------attributes multiplicitet---------------&#34;)&#xA;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attrMultiUpper = currentElement.Attributes.GetAt(k).UpperBound;&#xA;&#x9;&#x9;&#x9;&#x9;var attrMultiLower = currentElement.Attributes.GetAt(k).LowerBound;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// No need to test for empty upper and lower bounds, 'cos EA defaults to 1 if no value is put in. Thus I will not be able to catch this error.&#xA;&#x9;&#x9;&#x9;&#x9;if (attrMultiUpper != &#34;*&#34; &amp;&amp; (/\d+/.test(attrMultiLower) == false || /\d+/.test(attrMultiUpper) == false)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig pÃ¥ attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (attrMultiUpper != &#34;*&#34; &amp;&amp; attrMultiUpper &lt; attrMultiLower ){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig pÃ¥ attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'. Ret grÃ¦nsevÃ¦rdier.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the selected model has stereotype following the basic data model rules version 2.&#xA; */&#xA;function stereotypes(selectedPackage,elements){&#xA;&#x9;&#xA;&#x9;//Tjek af modellens stereotype&#xA;&#x9;var j = checkStereotypeModel(selectedPackage);&#x9;&#xA;&#x9;if (j==1){&#xA;&#x9;&#x9;LOGInfo(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens stereotype: OK&#34;);&#xA;&#x9;} else if (j&gt;1){&#xA;&#x9;&#x9;LOGError(&#34;Too many stereotypes on model '&#34;+ selectedPackage.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;//Tjek af modelelementernes stereotype&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Hov, hvorfor tjekker jeg kun pÃ¥ de tre typer af elementer?? Nok fordi at stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var k = checkStereotypeElement(currentElement);&#xA;&#x9;&#x9;&#x9;if (k==1){&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;} else if (k&gt;1){&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Too many stereotypes on element '&#34; + currentElement.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} else if (currentElement.Type == &#34;ProxyConnector&#34;){q += 1;}&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;if (q == elements.length){&#xA;&#x9;&#x9;Session.Output(&#34;Alle elementers stereotype: OK&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;//Tjek af attributternes stereotype, sÃ¥ vi looper igen&#x9;&#xA;&#x9;var o = 0;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Hov, hvorfor tjekker jeg kun pÃ¥ de to typer af elementer?? Fordi der kun er attributter pÃ¥ Class og Datatype, ikke Enumeration o.a. (her er det modelelementer, men lÃ¦ses som attributter, sÃ¥ de skal lige sorteres fra)&#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;let param = checkStereotypeAttribute(currentElement);&#xA;&#x9;&#x9;&#x9;var antalKorrekteAttributterPrElement = param[0];&#xA;&#x9;&#x9;&#x9;var antalAttributterPrElement = param[1];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (antalKorrekteAttributterPrElement==antalAttributterPrElement){&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on attributes in element '&#34; + currentElement.Name + &#34;': OK.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;o += 1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {o += 1;}&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o == elements.length){&#xA;&#x9;&#x9;Session.Output(&#34;Alle attributters stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;//Tjek af rollernes stereotype ogsÃ¥&#xA;&#x9;var b = 0;&#xA;&#x9;var c = 0;&#xA;&#x9;var d = 0;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//ProxyConnectoren er et element for forbindelser mellem element, men forbindelsernes egenskaber og endernes egenskaber ligger pÃ¥ elementerne.&#xA;&#x9;&#x9;if (currentElement.Type != &#34;ProxyConnector&#34;){&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;Alle&#34;);&#xA;&#x9;&#x9;&#x9;let param = checkStereotypeConnectorEnd(currentElement);&#xA;&#x9;&#x9;&#x9;var korrektClientRollePrElement = param[0];&#xA;&#x9;&#x9;&#x9;var korrektSupplierRollePrElement = param[1];&#xA;&#x9;&#x9;&#x9;var akkLenAfConnectorSet = param[2];&#xA;&#x9;&#x9;&#x9;var stereotypeUdenRolle = param[3];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;b = b + korrektClientRollePrElement;&#xA;&#x9;&#x9;&#x9;c = c + korrektSupplierRollePrElement;&#xA;&#x9;&#x9;&#x9;d = d + stereotypeUdenRolle;&#xA;&#x9;&#x9;} &#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;//Session.Output(&#34;Alle2&#34;);&#xA;&#x9;if (b == c &amp;&amp; c == d &amp;&amp; d == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Der findes ingen roller i denne pakke.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;else if ((b + c) == akkLenAfConnectorSet &amp;&amp; d == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Alle rollers stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given model has an allowed stereotype. A number is returned; if the number is 0 the model has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the model has too many stereotypes.&#xA; *&#xA; * @param package {EA.Package}&#xA; * @return variable defining whether or not the model has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeModel(package){&#xA;&#x9;// Check if the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesModel.length; i++){&#xA;&#x9;&#x9;if (package.Element.HasStereotype(allowedstereotypesModel[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given element has an allowed stereotype. A number is returned; if the number is 0 the element has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the element has too many stereotypes.&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variable defining whether or not the element has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeElement(element){&#xA;&#x9;// Check if the elements of the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesElement.length; i++){&#xA;&#x9;&#x9;if (element.HasStereotype(allowedstereotypesElement[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the attributes of a given element have an allowed stereotype. Two numbers are returned; the number of attributes &#xA; * with correct stereotypes, and the total count of attributes&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variables [a,b] depicting the number of attributes with correct stereotypes, a, and the total count of attributes, b&#xA; */&#xA;function checkStereotypeAttribute(element){&#xA;&#x9;var j=0;&#xA;&#x9;for (var k=0; k &lt; element.Attributes.Count; k++){&#xA;&#x9;&#x9;var attr = element.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;if (String(attr.StereotypeEx).includes(',')){&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;} &#xA;&#x9;&#x9;else if (attr.Stereotype.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, element.Attributes.Count]&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the connector ends of a given element have an allowed stereotype. Four numbers are returned; the number of connector ends (client and supplier) with correct stereotypes, &#xA; * the total count of unique connector ends, and a count of instances with applied stereotype but no role.&#xA; * &#xA; * @param element {EA.Element}&#xA; * @return variables [a, b, c, d]. Depicting a, b: the number of connector ends (client and supplier) with correct stereotypes, c; the total count&#xA; * of unique connector ends, and d; a count of instances with applied stereotype but no role.&#xA; */&#xA;function checkStereotypeConnectorEnd(element){&#xA;&#xA;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;var clientEnd as EA.ConnectorEnd;&#xA;&#x9;var supplierEnd as EA.ConnectorEnd;&#xA;&#x9;var j=0;&#xA;&#x9;var m=0;&#xA;&#x9;var n=0; &#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;connectors = element.Connectors;&#xA;&#x9;for (var i = 0 ; i &lt; connectors.Count ; i++)&#xA;&#x9;{&#xA;&#x9;&#x9;currentConnector = connectors.GetAt(i);&#xA;&#xA;&#x9;&#x9;if(currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation')&#xA;&#x9;&#x9;{&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis der er tastet et navn ind pÃ¥ rollen, sÃ¥ skal der ogsÃ¥ vÃ¦re en stereotype tilknyttet &#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(clientEnd.StereotypeEx.includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(String(supplierEnd.StereotypeEx).includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;m+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Hvis der er en stereotype, men intet rollenavn, sÃ¥ er det en fejl&#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Stereotype.length &gt; 0 &amp;&amp; clientEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;n+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Stereotype.length &gt; 0 &amp;&amp; supplierEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;n+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, m, connectorSet.size, n];&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [title (da), description (da), language, modelScope]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags1(selectedPackage){&#xA;&#x9;&#xA;&#x9;var title = checkTagPackage(selectedPackage, &#34;title (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var desc = checkTagPackage(selectedPackage, &#34;description (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var lang = checkTagPackage(selectedPackage, &#34;language&#34;, &#34;noTag&#34;);&#xA;&#x9;var mscope = checkTagPackage(selectedPackage, &#34;modelScope&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (title == null || title == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'title (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'title (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (desc == null || desc == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'description (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'description (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (lang != &#34;da&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'language' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'language' med \&#34;da\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (mscope != &#34;application model&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'modelScope' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'model scope' med \&#34;application model\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==4) {Session.Output(&#34;OK&#34;)}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [namespace, namespacePrefix]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags2(selectedPackage){&#xA;&#x9;&#xA;&#x9;var nspace = checkTagPackage(selectedPackage, &#34;namespace&#34;, &#34;noTag&#34;);&#xA;&#x9;var nspacepf = checkTagPackage(selectedPackage, &#34;namespacePrefix&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (nspace == null || nspace == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespace'.&#34;)&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile/g.test(nspace) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'namespace' starter ikke med \&#34;https://data.gov.dk/model/profile\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (nspacepf == null || nspacepf == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespacePrefix' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespacePrefix'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==3) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [responsibleEntity]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags3(selectedPackage){&#xA;&#x9;&#xA;&#x9;var respent = checkTagPackage(selectedPackage, &#34;responsibleEntity&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(selectedPackage.Name + &#34;: 'responsibleEntity' = &#34; + respent);&#x9;&#xA;&#x9;if (respent == &#34;noTag&#34;){&#xA;&#x9;&#x9;//do nothing&#xA;&#x9;}&#xA;&#x9;else if (respent == null || respent == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'responsibleEntity' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'responsibleEntity'.&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;)}&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [theme]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags4(selectedPackage){&#xA;&#x9;&#xA;&#x9;var theme = checkTagPackage(selectedPackage, &#34;theme&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (theme == &#34;&#34; ){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'theme'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttp/.test(theme) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'theme' starter ikke med \&#34;https\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modified, versionInfo]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags5(selectedPackage){&#xA;&#x9;&#xA;&#x9;var modified = checkTagPackage(selectedPackage, &#34;modified&#34;, &#34;noTag&#34;);&#xA;&#x9;var versionInfo = checkTagPackage(selectedPackage, &#34;versionInfo&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;//Vi skal lige have set pÃ¥ den her tag. Kan den lÃ¦ses bÃ¥de som yyyy-mm-dd OG dd-mm-yyyy??&#xA;&#x9;if (/20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]/.test(modified) == false &amp;&amp; /[0-3][0-9]-[0-1][0-9]-20[0-9][0-9]/.test(modified) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modified' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modified' er ikke opbygget iht. xsd:date 26 (YYYY-MM-DD).&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(versionInfo) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'versionInfo' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'versionInfo' er ikke opbygget iht. (0-9).(0-9).(0-9)&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [approvalStatus,approvedBy]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags6(selectedPackage){&#xA;&#x9;&#xA;&#x9;var apprStatus = checkTagPackage(selectedPackage, &#34;approvalStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;var apprBy = checkTagPackage(selectedPackage, &#34;approvedBy&#34;, &#34;noTag&#34;);&#x9;&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;Modellens nuvÃ¦rende status: &#34; + apprStatus);&#xA;&#x9;if (/approved/.test(apprStatus) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvalStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvalStatus' har ikke vÃ¦rdi approved&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (apprBy != &#34;Grunddata Arkitekturforum&#34; &amp;&amp; apprBy != &#34;Grunddata Modelsekretariatet&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvedBy' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvedBy' har ikke vÃ¦rdi fra listen (Grunddata Arkitekturforum, Grunddata Modelsekretariatet).&#34;);&#xA;&#x9;} else {j += 1}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modelStatus]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags7(selectedPackage){&#xA;&#x9;&#xA;&#x9;var mstatus = checkTagPackage(selectedPackage, &#34;modelStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;&#xA;&#x9;if (mstatus != &#34;development&#34; &amp;&amp; mstatus != &#34;stable&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modelStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modelStatus' har ikke vÃ¦rdi fra listen (development, stable).&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [legalSource,source]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags8(selectedPackage){&#x9;&#xA;&#x9;&#xA;&#x9;var legalSource = checkTagPackage(selectedPackage, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;var source = checkTagPackage(selectedPackage, &#34;source&#34;, &#34;noTag&#34;);&#xA;&#x9;var j=0&#xA;&#x9;&#xA;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'legalSource' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34;.&#34;);&#xA;&#x9;} else {j +=1 }&#xA;&#x9;if (source.trim().length == 0){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'source' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'source' er tom for pakken &#34;+ selectedPackage.Name);&#xA;&#x9;} else {j +=1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Script to check if a tag on a package exists. If it does, the value of the tag is returned.&#xA; *&#xA; * @param package, tag, default value&#xA; * @return the tagged value&#xA; */&#xA;function checkTagPackage(package, tag, defaultval) {&#xA;&#x9;var result=getTaggedValueElement(package.Element, tag, defaultval);&#xA;&#x9;if (result==defaultval){&#xA;&#x9;&#x9;LOGError(&#34;No tag called &#34;+ tag + &#34; on package &#34; + package.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Tagget '&#34; + tag + &#34;' pÃ¥ pakken '&#34; + package.Name+ &#34;' findes ikke.&#34;);&#xA;&#x9;&#x9;return result;&#xA;&#x9;} else { &#xA;&#x9;&#x9;LOGTrace(&#34;Value of '&#34; + tag + &#34;' on package '&#34; + package.Name + &#34;: &#34; + result);&#xA;&#x9;&#x9;return result;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'URI'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function identifikator(elements)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;var URI_list = [];&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var URI = getTaggedValueElement(currentElement, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URI) == false){&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on element '&#34;+ currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34; i elementet med navn '&#34; + currentElement.Name + &#34;'.&#34;)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; URI_list.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (URI == URI_list[j]) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' i elementet med navn '&#34; + currentElement.Name + &#34;' er ikke unik i modellen.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;URI_list.push(URI);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters URI&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;var URIAttr = getTaggedValueAttribute(attr, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URIAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on the attribute '&#34; + attr + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' pÃ¥ attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34;.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0 &amp;&amp; r==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'prefLabel (da)'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function sprog(elements)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Hov, hvorfor tjekker jeg kun pÃ¥ de tre typer af elementer?? Nok fordi at stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var prefLabelValue = getTaggedValueElement(currentElement, &#34;prefLabel (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;if (prefLabelValue == null || prefLabelValue == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'prefLabel (da)' on element '&#34; + currentElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' mangler vÃ¦rdi for 'prefLabel (da)'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate whether or not an element name is in upper camel case and an attribute name is in lower camel case.&#xA; * Only Danish letters and numbers are allowed.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkCamel(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#x9;&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#xA;&#x9;&#x9;&#x9;if (upperCamel.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;if (/^[A-Z]|^Ã†|^Ã˜|^Ã…|^[0-9]/.test(currentElement.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Name not in upper camel case: &#34;+ currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' er ikke i UpperCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Tjek af connectors navne&#xA;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (lowerCamel.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^Ã¦|^Ã¸|^Ã¥|^[0-9])/.test(currentConnector.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Connector element not in lower camel case: (GUID) &#34;+ currentConnector.ConnectorGUID);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase.&#34;); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^Ã¦|^Ã¸|^Ã¥|^[0-9])/.test(clientEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ clientEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + clientEnd.Role + &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^Ã¦|^Ã¸|^Ã¥|^[0-9])/.test(supplierEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ supplierEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + supplierEnd.Role +  &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters navne&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k).Name; &#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^Ã¦|^Ã¸|^Ã¥)/.test(attr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Attribute not in lower camel case: '&#34; + attr + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten med navn '&#34; + attr + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' er ikke i lowerCamelCase.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'definition (da)' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkDef(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer og tekstfelter.&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector' &amp;&amp; currentElement.Type != 'Text'){&#xA;&#x9;&#x9;&#x9;var defElement = getTaggedValueElement(currentElement, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (defElement == &#34;noTag&#34; || defElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition pÃ¥ elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^Ã¦|^Ã¸|^Ã¥|^[0-9]/.test(defElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (defElement.trim().length != defElement.length){//not an error, but inform the user (r is not increased)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (defElement.charAt(defElement.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name + &#34;' ends with a period &#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var defAttr = getTaggedValueAttribute(attr, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;if (defAttr == &#34;noTag&#34; || defAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition pÃ¥ attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^Ã¦|^Ã¸|^Ã¥|^[0-9]/.test(defAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet pÃ¥ attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.trim().length != defAttr.length){ //not an error, but inform the user (r is not increased) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet pÃ¥ attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.charAt(defAttr.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' ends with a period.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet pÃ¥ attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'legalSource' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkLegal(elements){&#xA;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;if (omitUMLelements.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;var legalSourceElement = getTaggedValueElement(currentElement, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;if (legalSourceElement == &#34;noTag&#34; || legalSourceElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen 'legalSource' pÃ¥ elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'legalSource' on element '&#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34; pÃ¥ elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the data types of the attributes. It has to be ISO types.&#xA; *&#xA; * @param element&#xA; */&#xA;function ISOtype(elements)&#xA;{&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer og enumerationer&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector' &amp;&amp; currentElement.Type != &#34;Enumeration&#34;){&#xA;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (attr.ClassifierID == null || attr.ClassifierID == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Datatype pÃ¥ attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;' er ikke en ISO-type.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the tag 'historikmodel' for model elements is valid. It has to be either &#34;registreringshistorik&#34; or &#34;bitemporalitet&#34;&#xA; *&#xA; * @param element&#xA; */&#xA;function historik(elements)&#xA;{&#x9;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#x9;&#x9;&#x9;if (histTag == &#34;bitemporalitet&#34; || histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;alt er godt&#34;);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong or no 'historikmodel' on element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Forkert angivet 'historikmodel' for elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Check if the object type elements have an attribute called 'id' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkID(elements)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var IDcount = 0; //no. id attributes&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var r = 0;&#xA;&#x9;&#x9;&#x9;var multifejl = 0;&#xA;&#x9;&#x9;&#x9;var typefejl = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (r==0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten id.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben id pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben id pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;IDcount = IDcount + r&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} &#x9;&#xA;&#x9;} &#xA;&#xA;&#x9;if (IDcount == count &amp;&amp; multifejl == 0 &amp;&amp; typefejl == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the object type elements have attributes called 'registreringFra', 'registreringTil' and 'registreringsaktÃ¸r' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkReg(elements)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var regcountFra = 0; //no. registreringFra attributes&#xA;&#x9;var regcountTil = 0; //no. registreringTil attributes&#xA;&#x9;var regcountAkt = 0; //no. registreringsaktÃ¸r attributes&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;var multifejlFra = 0;&#xA;&#x9;&#x9;&#x9;var multifejlTil = 0;&#xA;&#x9;&#x9;&#x9;var multifejlAkt = 0;&#xA;&#x9;&#x9;&#x9;var typefejlFra = 0;&#xA;&#x9;&#x9;&#x9;var typefejlTil = 0;&#xA;&#x9;&#x9;&#x9;var typefejlAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringsaktÃ¸r.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktÃ¸r pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktÃ¸r pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;regcountFra = regcountFra + rFra&#xA;&#x9;&#x9;&#x9;regcountTil = regcountTil + rTil&#xA;&#x9;&#x9;&#x9;regcountAkt = regcountAkt + rAkt&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} &#x9;&#xA;&#x9;} &#xA;&#xA;&#x9;if (regcountFra == count &amp;&amp; regcountTil == count &amp;&amp; regcountAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * If a modelelement is labelled with 'bitemporalitet' virkningstid is mandatory. &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkVirk(elements)&#xA;{&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with bitemporalitet&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktÃ¸r attributes&#x9;&#xA;&#x9;var multifejlFra = 0;&#xA;&#x9;var multifejlTil = 0;&#xA;&#x9;var multifejlAkt = 0;&#xA;&#x9;var typefejlFra = 0;&#xA;&#x9;var typefejlTil = 0;&#xA;&#x9;var typefejlAkt = 0;&#xA;&#xA;&#x9;var missing = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#x9;&#x9;//Session.Output(&#34;Tagget: &#34;+histTag + &#34;    Elementet: &#34; +currentElement.Name + &#34;     Stereotypen: &#34; +currentElement.Stereotype)&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;bitemporalitet&#34;) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;var mFra = 0;&#xA;&#x9;&#x9;&#x9;var mTil = 0;&#xA;&#x9;&#x9;&#x9;var mAkt = 0;&#xA;&#x9;&#x9;&#x9;var tFra = 0;&#xA;&#x9;&#x9;&#x9;var tTil = 0;&#xA;&#x9;&#x9;&#x9;var tAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningFra' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningFra' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningTil' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningTil' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningsaktÃ¸r.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningsaktÃ¸r' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'virkningsaktÃ¸r' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;&#x9;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;&#x9;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#x9;&#x9;multifejlFra = multifejlFra + mFra;&#xA;&#x9;&#x9;&#x9;multifejlTil = multifejlTil + mTil;&#xA;&#x9;&#x9;&#x9;multifejlAkt = multifejlAkt + mAkt;&#xA;&#x9;&#x9;&#x9;typefejlFra = typefejlFra +tFra;&#xA;&#x9;&#x9;&#x9;typefejlTil = typefejlTil + tTil;&#xA;&#x9;&#x9;&#x9;typefejlAkt = typefejlAkt + tAkt;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;&#34; &amp;&amp; currentElement.Type != &#34;Text&#34;){&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke en vÃ¦rdi for tagget 'historikmodel'.&#34;);&#xA;&#x9;&#x9;&#x9;missing += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = bitemporalitet.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == count &amp;&amp; countVirkTil == count &amp;&amp; countVirkAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0 &amp;&amp; missing == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = bitemporalitet: OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = bitemporalitet: OK&#34;);}&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * If modelelement is labelled with 'registreringshistorik' no virkningstid is allowed.  &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function historikReg(elements)&#xA;{&#x9;&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with registreringshistorik&#x9;&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktÃ¸r attributes&#xA;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTagValue');&#xA;&#x9;&#x9;//Session.Output(&#34;Tagget: &#34;+histTag + &#34;    Elementet: &#34; +currentElement.Name + &#34;     Stereotypen: &#34; +currentElement.Stereotype)&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktÃ¸r&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningsaktÃ¸r.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = registreringshistorik.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == 0 &amp;&amp; countVirkTil == 0 &amp;&amp; countVirkAkt == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = registreringshistorik: OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = registreringshistorik: OK&#34;);}&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * If a model element has attribute 'status', 'forretningshÃ¦ndelse' or 'forretningsproces' the attribute has to have datatype 'DKEnumeration' or 'DKKodeliste'.&#x9;&#xA; * This function checks if the datatype for a given attribute is correct (input parameter).&#xA; *&#xA; * @param element, attribute name &#xA; * @return variables: OK (string)&#xA; */&#xA;function checkAttr(elements,attributnavn)&#xA;{&#x9;&#x9;&#xA;&#x9;var fejl = 0;&#xA;&#x9;&#xA;&#x9;var elementIDlistAll = [];&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;elementIDlistAll.push(currentElement.ElementID);&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == attributnavn){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlistAll.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;ElementType: &#34;+currentElementTemp.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){ &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.Type != &#34;Enumeration&#34; &amp;&amp; currentElementTemp.Type != &#34;Kodeliste&#34; ){//Er det type eller stereotype? For navnet pÃ¥ en kodelistes type er ogsÃ¥ en Enumeration...&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' har ikke datatypen DKEnumeration eller DKKodeliste&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' pÃ¥ elementet '&#34;+ currentElement.Name + &#34;' er ikke linket til korrekt datatypeelement.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (fejl == 0){&#xA;&#x9;&#x9;return &#34;OK&#34;;&#xA;&#x9;&#x9;//Uncomment this line if run locally&#xA;&#x9;&#x9;//Session.Output(&#34;OK&#34;); &#xA;&#x9;}&#xA;}&#xA;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{BFFAE836-A1AC-411c-A687-C100853E32C6}"/>
         <Column name="ScriptAuthor" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;transliterate-names&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._guid-utils&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var TAG_NAME_TRANSLITERATED_NAME = &#34;transliteratedName&#34;;&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;&#xA;/**&#xA; * Transliterates the Danish characters and the letter e with acute to &#xA; * [Basic Latin](https://unicode-table.com/en/blocks/basic-latin/) characters&#xA; * for all model elements, and puts the transliterated name in tagged value&#xA; * `transliteratedName`. Enumeration literals are not transliterated, and if&#xA; * an enumeration literal has that tagged value, it is removed.&#xA; *&#xA; * - Ã¸ â†’ oe&#xA; * - Ã¦ â†’ ae&#xA; * - Ã¥ â†’ aa&#xA; * - Ã© â†’ e&#xA; *&#xA; * @summary Transliterates the names of the model elements.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueElement(currentElement);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueAttribute(currentAttribute);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueConnectorEnd(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueConnectorEnd(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else if (currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueElement(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;/*&#xA;&#x9;&#x9;&#x9;&#x9; * next lines of code: update models that actually contain transliterated names for enumeration values, from earlier modelling&#xA;&#x9;&#x9;&#x9;&#x9; */&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeTaggedValueIfPresent(attributes.GetAt(j));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param element {EA.Element}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueElement(element) {&#xA;&#x9;LOGDebug(&#34;Element: &#34; + element.Name);&#xA;&#x9;if (mustBeTransliterated(element.Name)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(element.Name);&#xA;&#x9;&#x9;setTaggedValueElement(element, TAG_NAME_TRANSLITERATED_NAME, transliteratedName);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of element &#34; + element.Name);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueIfPresent(element);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param element {EA.Attribute}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueAttribute(attribute) {&#xA;&#x9;LOGDebug(&#34;Attribute: &#34; + attribute.Name);&#xA;&#x9;if (mustBeTransliterated(attribute.Name)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(attribute.Name);&#xA;&#x9;&#x9;setTaggedValueAttribute(attribute, TAG_NAME_TRANSLITERATED_NAME, transliteratedName);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of attribute &#34; + attribute.Name);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueIfPresent(attribute);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param source {boolean}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueConnectorEnd(connector, source) {&#xA;&#x9;var roleName = null;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;roleName = connector.ClientEnd.Role;&#xA;&#x9;} else {&#xA;&#x9;&#x9;roleName = connector.SupplierEnd.Role;&#xA;&#x9;}&#xA;&#x9;LOGDebug(&#34;Connector end role: &#34; + roleName);&#xA;&#x9;if (mustBeTransliterated(roleName)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(roleName);&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, TAG_NAME_TRANSLITERATED_NAME, transliteratedName, source);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of connector end &#34; + roleName);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueConnectorEndIfPresent(connector, source);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param name {string}&#xA; * @return boolean&#xA; */&#xA;function mustBeTransliterated(name) {&#xA;&#x9;return name.search(/Ã¦|Ã¸|Ã¥|Ã©/i) != -1;&#xA;}&#xA;&#xA;/**&#xA; * @param name {string}&#xA; * @return {string}&#xA; */&#xA;function transliterate(name) {&#xA;&#x9;return name.replace(/Ã¦/g, &#34;ae&#34;).replace(/Ã†/g, &#34;Ae&#34;).replace(/Ã¸/g, &#34;oe&#34;).replace(/Ã˜/g, &#34;Oe&#34;).replace(/Ã¥/g, &#34;aa&#34;).replace(/Ã…/g, &#34;Aa&#34;).replace(/Ã©/g, &#34;e&#34;).replace(/Ã‰/g, &#34;E&#34;);&#xA;}&#xA;&#xA;/**&#xA; * @param object {EA.Element or EA.Attribute}&#xA; */&#xA;function removeTaggedValueIfPresent(object) {&#xA;&#x9;for (var i = 0; i &lt; object.TaggedValues.Count; i++) {&#xA;&#x9;&#x9;var tag = object.TaggedValues.GetAt(i);&#xA;&#x9;&#x9;if (tag.Name == TAG_NAME_TRANSLITERATED_NAME) {&#xA;&#x9;&#x9;&#x9;object.TaggedValues.DeleteAt(i, true);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;object.TaggedValues.Refresh();&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param source {boolean}&#xA; */&#xA;function removeTaggedValueConnectorEndIfPresent(connector, source /* boolean, false =&gt; target */ ) {&#xA;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;} else {&#xA;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;}&#xA;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;var tag = taggedValues.GetAt(i);&#xA;&#x9;&#x9;if (tag.Tag == TAG_NAME_TRANSLITERATED_NAME) {&#xA;&#x9;&#x9;&#x9;taggedValues.DeleteAt(i, true);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;taggedValues.Refresh();&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{C346DE00-4F08-4dc2-A972-9B0692521132}"/>
         <Column name="ScriptAuthor" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-eamt-scripts&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Exports the scripts in the EAMT scripts groups as&#xA; *&#xA; * 1. a EA reference data file for import in another EA instance &#xA; * 2. seperate script files&#xA; * 3. a separate README.md file, containing the documentation extracted from the scripts&#xA; * &#xA; * The scripts should be saved in folder `ea-modelling-tools-javascript/src`.&#xA; *&#xA; * @summary Exports the EAMT scripts&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;/*&#xA;&#x9; * A backslash must be escaped in Javascript, therefore two backslashes:&#xA;&#x9; * - one because the asterisk must be escaped with a backslash when calling a Java program from the command line&#xA;&#x9; * - one because the backslash to escape the asterisk must be escaped itself when the regex is constructed in a script&#xA;&#x9; */&#xA;&#x9;var scriptGroupNameOrRegex = &#34;eamt-\\*&#34;;&#xA;&#x9;&#xA;&#x9;var scriptFolderPath = chooseFolderWithUI(&#34;Folder in which the script files should be saved (ea-modelling-tools-javascript/src)&#34;);&#xA;&#x9;if (scriptFolderPath.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-scripts.bat&#34;, '-sg &#34;' + scriptGroupNameOrRegex + '&#34; -o ' + scriptFolderPath + &#34; -doc -p 5&#34;);&#xA;&#x9;&#xA;&#x9;openFolderInWindowsExplorer(scriptFolderPath);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{CB885391-7623-4417-B78A-A735D90DD3DE}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_messages&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="var MESSAGE_PACKAGE_REQUIRED = &#34;This script requires a package to be selected in the Project Browser.\n&#34; +&#xA;&#x9;&#x9;&#x9;&#34;Please select a package in the Project Browser and try again.&#34;;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{E4D53B7B-8414-40b9-9DF0-426261C791F3}"/>
         <Column name="ScriptAuthor" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-scripts&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Exports the scripts in one or more scripts groups as&#xA; *&#xA; * 1. a EA reference data file for import in another EA instance &#xA; * 2. seperate script files&#xA; * 3. a separate README.md file, containing the documentation extracted from the scripts&#xA; *&#xA; * An asterisk (*) in a regex must be escaped with a backslash, see also Java class&#xA; * `dk.gov.data.modellingtools.app.ExportScripts`.&#xA; *&#xA; * So use `xyz\*` instead of `xyz*` to export all script groups that have a name starting with xyz.&#xA; *&#xA; * The name/regex is used in a LIKE expression in the database of the .eapx file.&#xA; * See [The LIKE operator in Microsoft Jet SQL](https://docs.microsoft.com/en-us/previous-versions/office/developer/office2000/aa140015(v=office.10)#the-like-operator)&#xA; * and below for the syntax.&#xA; *&#xA; *  - asterisk (`*`): matches any number of characters and can be used anywhere in the pattern string.&#xA; *  - question mark (`?`) matches any single character and can be used anywhere in the pattern string.&#xA; *  - number sign (`#`): matches any single digit and can be used anywhere in the pattern string.&#xA; *  - square brackets (`[]`): matches any single character within the list that is enclosed within brackets, and can be used anywhere in the pattern string.&#xA; *  - exclamation mark (`!`): matches any single character not in the list that is enclosed within the square brackets.&#xA; *  - hyphen (`-`): matches any one of a range of characters that is enclosed within the square brackets.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;// a backslash must be escaped in Javascript, therefore two backslashes&#xA;&#x9;var scriptGroupNameOrRegex = Session.Input(&#34;Script group name or regex for a collection of scripts groups&#34;);&#xA;&#x9;if (scriptGroupNameOrRegex.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No script group given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;var scriptFolderPath = chooseFolderWithUI(&#34;Folder in which the script files should be saved&#34;);&#xA;&#x9;if (scriptFolderPath.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-scripts.bat&#34;, '-sg &#34;' + scriptGroupNameOrRegex + '&#34; -o ' + scriptFolderPath + &#34; -p 5&#34;);&#xA;&#x9;&#xA;&#x9;openFolderInWindowsExplorer(scriptFolderPath);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
   </DataSet>
</RefData>
