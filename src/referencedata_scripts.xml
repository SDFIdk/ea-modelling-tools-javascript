<?xml version="1.0" encoding="UTF-8"?>
<RefData version="1.0" exporter="ea-modelling-tools">
   <DataSet name="Automation Scripts"
            table="t_script"
            filter="ScriptName='#ScriptName#' and ScriptCategory='#ScriptCategory#'"
            stoplist=";ScriptID;">
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Validation scripts to validate the model against for instance the basic data model rules version 2. &#34;/&gt;"/>
         <Column name="Script" value="eamt-data-model-validation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{2D4D14C7-61B2-4792-8F5F-00705AFB7436}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Tools for persons that contribute to the development of the EAMT scripts.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-developer-tools"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in preparing the derivation of physical data schemas, e.g. using [ShapeChange](https://shapechange.net/).&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-data-schema-preparation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{70C0A695-3A03-4816-8FBB-A157114FA8E8}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;PROJBROWSER&#34; Notes=&#34;Scripts that assist in managing profiles of data models.&#34;/&gt;"/>
         <Column name="Script" value="eamt-profile-management"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Scripts used for keeping scripts developed in EA under version control.&#34;/&gt;&#xA;"/>
         <Column name="Script" value="eamt-script-management"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in creating a logical data model in UML. Scripts preparing the derivation of physical data schemas are **not** included here.&#34;/&gt;"/>
         <Column name="Script" value="eamt-data-model-creation"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;NORMAL&#34; Notes=&#34;Scripts containing utility functions, that are used by other scripts.&#34;/&gt;"/>
         <Column name="Script" value="eamt-utilities"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782"/>
         <Column name="ScriptName" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Group Type=&#34;CONTEXTPACKAGE&#34; Notes=&#34;Scripts that assist in importing and exporting a logical data model.&amp;#xA;&amp;#xA;Certain scripts import or export CSV files. CSV files can be opened, edited and exported using an application capable of dealing with spreadsheets, such as LibreOffice Calc or Microsoft Excel. Use &amp;quot;UTF-8&amp;quot; as character set and a comma (&amp;quot;,&amp;quot;) as separator. For more information, see&amp;#xA;&amp;#xA;- https://help.libreoffice.org/latest/en-US/text/scalc/guide/csv_files.html?&amp;amp;amp;DbPAR=CALC&amp;amp;amp;System=WIN&amp;#xA;- https://help.libreoffice.org/latest/en-US/text/shared/00/00000208.html?&amp;amp;amp;DbPAR=SHARED&amp;amp;amp;System=WIN&amp;#xA;- https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba&amp;#xA;&amp;#xA;Warning: Never change the contents of column GUID, as this information is required to link a row in the CSV file to the corresponding UML model element.&amp;#xA;&amp;#xA;Tip: Convert a set of CSV files to one spreadsheet when the data has to be edited by someone else. When the editing is finished, the spreadsheets are converted again to a set of CSV files and imported into EA. The conversion can be done manually, via your spreadsheet application GUI. Another option is to convert the files programmatically, for example by using [ogr2ogr](https://gdal.org/programs/ogr2ogr.html).&amp;#xA;&amp;#xA;```bat&amp;#xA;ogr2ogr -f ODS -nln Classifiers -oo HEADERS=YES documentation.ods &amp;quot;Model_Elements.csv&amp;quot;&amp;#xA;ogr2ogr -update -f ODS -nln Attributes -oo HEADERS=YES documentation.ods &amp;quot;Model_Attributes.csv&amp;quot;&amp;#xA;ogr2ogr -update -f ODS -nln AssociationEnds -oo HEADERS=YES documentation.ods &amp;quot;Model_Associationends.csv&amp;quot;&amp;#xA;ogr2ogr -update -f ODS -nln EnumerationLiterals -oo HEADERS=YES documentation.ods &amp;quot;Model_EnumerationLiterals.csv&amp;quot;&amp;#xA;```&#34;/&gt;"/>
         <Column name="Script" value="eamt-data-model-import-export"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{06C9A7C9-C3B9-4146-8EC8-A1618C64B7ED}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_shell-application-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to access to aspects of the Windows Explorer Shell application,&#xA; *       such as managing windows, files and folders, and the current session. This is useful in scripts that call&#xA; *       command line scripts importing or exporting models.&#xA; */&#xA; !INC eamt-utilities._logging-utils&#xA;&#xA;/** &#xA; * Provides access to aspects of the Windows Explorer Shell application, such as managing windows, files and&#xA; * folders, and the current session (from &#34;Windows Powershell Pocket References&#34; by Lee Holmes).&#xA; *&#xA; * See more on [Scriptable Shell Objects](https://docs.microsoft.com/en-us/windows/win32/shell/scriptable-shell-objects-roadmap)&#xA; * (in the Shell Developer's Guide) and&#xA; * [Shell object](https://docs.microsoft.com/en-us/windows/win32/shell/shell) (in the Shell Reference).&#xA; */&#xA;var SHELL_APP = new COMObject(&#34;Shell.Application&#34;);&#xA;&#xA;/**&#xA; * Shows a dialog box (not in the foreground unfortunately...) to the user to choose a folder.&#xA; * Returns the absolute file path of the choosen folder, or an empty string if no folder was selected.&#xA; */&#xA;function chooseFolderWithUI(dialogBoxTitle /* : String */) {&#xA;&#x9;LOGInfo(&#34;Pick a folder with the UI (see new dialog)&#34;);&#xA;&#x9;&#xA;&#x9;/* &#xA;&#x9; * BrowserForFolder method: see https://docs.microsoft.com/en-us/windows/win32/shell/shell-browseforfolder&#xA;&#x9; *&#xA;&#x9; * 4th argument of BrowseForFolder method:&#xA;&#x9; * see https://docs.microsoft.com/en-us/windows/win32/api/shldisp/ne-shldisp-shellspecialfolderconstants:&#xA;&#x9; * 0x11 (17). My Computer—the virtual folder that contains everything on the local computer: storage devices, printers, and Control Panel. &#xA;&#x9; * This folder can also contain mapped network drives.&#xA;&#x9; */&#xA;&#x9;var folder = SHELL_APP.BrowseForFolder(0, dialogBoxTitle, 0x00000040, 0x11);&#xA;&#x9;if (folder == null) {&#xA;&#x9;&#x9;return &#34;&#34;;&#xA;&#x9;} else {&#xA;&#x9;&#x9;return folder.Self.Path;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Opens the folder with the given path in Windows Explorer.&#xA; */&#xA;function openFolderInWindowsExplorer(folderPath) {&#xA;&#x9;SHELL_APP.Explore(folderPath);&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{0A06099C-7665-4ec6-A664-C3262C7D1E4A}"/>
         <Column name="ScriptAuthor" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;set-database-names&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var TAG_NAME_TRANSLITERATED_NAME = &#34;transliteratedName&#34;;&#xA;var TAG_NAME_ORACLE_NAME = &#34;oracleName&#34;;&#xA;var TAG_NAME_DATABASE_NAME = &#34;dbName&#34;;&#xA; &#xA;/**&#xA; * Adds tagged value &#34;dbName&#34; containing the name to be used in the database &#xA; * for all relevant model elements (not on enumeration values).&#xA; *&#xA; * The database name is set using the following logic: &#xA; *&#xA; * ```mermaid&#xA;flowchart LR&#xA;    %% decisions&#xA;    oracleNameSet{&#34;Is tagged value&lt;br /&gt;oracleName set?&#34;}&#xA;    transliteratedNameSet{Is tagged value&lt;br /&gt;transliteratedName set?}&#xA;    %% outcomes&#xA;    useOracleName[Use the value of tagged value oracleName as value of tagged value dbName]&#xA;    usetransliteratedName[Use tagged value transliteratedName as value of tagged value dbName]&#xA;    useModelElementName[Use model element name as value of tagged value dbName]&#xA;    %% arrows&#xA;    Start --&gt; oracleNameSet&#xA;    oracleNameSet --&gt; | yes | useOracleName --&gt; End&#xA;    oracleNameSet --&gt; | no | transliteratedNameSet&#xA;    transliteratedNameSet --&gt; | yes | usetransliteratedName --&gt; End&#xA;    transliteratedNameSet --&gt; | no | useModelElementName --&gt; End&#xA; ```&#xA; *&#xA; * A special mapping is done for the following attributes:&#xA; *&#xA; * - geometry → geometri&#xA; * - beginLifespanVersion → registreringFra&#xA; * - endLifespanVersion → registreringTil&#xA; *&#xA; * @summary Adds tagged values with database name.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;setDatabaseNameTaggedValueElement(currentElement);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;setDatabaseNameTaggedValueAttribute(currentAttribute);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;setDatabaseNameTaggedValueConnectorEnd(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;setDatabaseNameTaggedValueConnectorEnd(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else if (currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;setDatabaseNameTaggedValueElement(currentElement);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;function setDatabaseNameTaggedValueElement(element) {&#xA;&#x9;LOGDebug(&#34;Element: &#34; + element.Name);&#xA;&#x9;var oracleName, transliteratedName;&#xA;&#x9;oracleName = getTaggedValueElement(element, TAG_NAME_ORACLE_NAME, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueElement(element, TAG_NAME_TRANSLITERATED_NAME, &#34;&#34;);&#xA;&#x9;var dbName = getDatabaseName(oracleName, transliteratedName, element.Name);&#xA;&#x9;setTaggedValueElement(element, TAG_NAME_DATABASE_NAME, dbName);&#xA;&#x9;LOGDebug(&#34;Database name: &#34; + dbName);&#xA;}&#xA;&#xA;function getDatabaseName(oracleName, transliteratedName, name) {&#xA;&#x9;var dbName;&#xA;&#xA;&#x9;if (name == &#34;geometry&#34;) {&#xA;&#x9;&#x9;dbName = &#34;geometri&#34;;&#xA;&#x9;&#x9;LOGInfo(&#34;Special mapping used        Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else if (name == &#34;lokalid&#34;) {&#xA;&#x9;&#x9;dbName = &#34;id_lokalid&#34;;&#xA;&#x9;&#x9;LOGInfo(&#34;Special mapping used        Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else if (name == &#34;beginLifespanVersion&#34;) {&#xA;&#x9;&#x9;dbName = &#34;registreringFra&#34;;&#xA;&#x9;&#x9;LOGInfo(&#34;Special mapping used        Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else if (name == &#34;endLifespanVersion&#34;) {&#xA;&#x9;&#x9;dbName = &#34;registreringTil&#34;;&#xA;&#x9;&#x9;LOGInfo(&#34;Special mapping used        Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else if (oracleName != &#34;&#34;) {&#xA;&#x9;&#x9;dbName = oracleName;&#xA;&#x9;&#x9;LOGInfo(&#34;Oracle name used           Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else if (transliteratedName != &#34;&#34;) {&#xA;&#x9;&#x9;dbName = transliteratedName;&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name used   Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;} else {&#xA;&#x9;&#x9;dbName = name;&#xA;&#x9;&#x9;if (dbName.length &gt; 0) {&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Standard name used           Name: &#34; + name + &#34;   dbName: &#34; + dbName);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return dbName;&#xA;}&#xA;&#xA;function setDatabaseNameTaggedValueAttribute(attribute) {&#xA;&#x9;LOGDebug(&#34;Attribute: &#34; + attribute.Name);&#xA;&#x9;var oracleName, transliteratedName;&#xA;&#x9;oracleName = getTaggedValueAttribute(attribute, TAG_NAME_ORACLE_NAME, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueAttribute(attribute, TAG_NAME_TRANSLITERATED_NAME, &#34;&#34;);&#xA;&#x9;var dbName = getDatabaseName(oracleName, transliteratedName, attribute.Name);&#xA;&#x9;setTaggedValueAttribute(attribute, TAG_NAME_DATABASE_NAME, dbName);&#xA;&#x9;LOGDebug(&#34;Database name: &#34; + dbName);&#xA;}&#xA;&#xA;function setDatabaseNameTaggedValueConnectorEnd(connector, source) {&#xA;&#x9;var roleName = null;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;roleName = connector.ClientEnd.Role;&#xA;&#x9;} else {&#xA;&#x9;&#x9;roleName = connector.SupplierEnd.Role;&#xA;&#x9;}&#xA;&#x9;LOGDebug(&#34;Connector end role: &#34; + roleName);&#xA;&#x9;var oracleName, transliteratedName;&#xA;&#x9;oracleName = getTaggedValueConnectorEnd(connector, TAG_NAME_ORACLE_NAME, source, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueConnectorEnd(connector, TAG_NAME_TRANSLITERATED_NAME, source, &#34;&#34;);&#xA;&#x9;var dbName = getDatabaseName(oracleName, transliteratedName, roleName);&#xA;&#x9;setTaggedValueConnectorEnd(connector, TAG_NAME_DATABASE_NAME, dbName, source);&#xA;&#x9;LOGDebug(&#34;Database name: &#34; + dbName);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{0CDB9C42-FBBB-43cc-B8EB-A1925B780A68}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_model-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with the retrieving model elements from the EA model.&#xA; */&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Element&gt;} elements in the given package (including elements in all its subpackages)&#xA; */&#xA;function getElementsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var elements = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Elements.Count; i++) {&#xA;&#x9;&#x9;elements[i] = aPackage.Elements.GetAt(i);&#xA;&#x9;}&#xA;&#x9;for (var j = 0; j &lt; aPackage.Packages.Count; j++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;elements = elements.concat(getElementsOfPackageAndSubpackages(aPackage.Packages.GetAt(j)));&#xA;&#x9;}&#xA;&#x9;return elements;&#xA;}&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Diagram&gt;} diagrams in the given package (including diagrams in all its subpackages)&#xA; */&#xA;function getDiagramsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var diagrams = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Diagrams.Count; i++) {&#xA;&#x9;&#x9;diagrams[i] = aPackage.Diagrams.GetAt(i);&#xA;&#x9;}&#xA;&#x9;for (var j = 0; j &lt; aPackage.Packages.Count; j++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;diagrams = diagrams.concat(getDiagramsOfPackageAndSubpackages(aPackage.Packages.GetAt(j)));&#xA;&#x9;}&#xA;&#x9;return diagrams;&#xA;}&#xA;&#xA;/**&#xA; * @param aPackage {EA.Package}&#xA; * @return {Array&lt;EA.Package&gt;} packages in the given package (including packages in all its subpackages)&#xA; */&#xA;function getSubpackagesOfPackage(aPackage) {&#xA;&#x9;var packages = [];&#xA;&#x9;for (var i = 0; i &lt; aPackage.Packages.Count; i++) {&#xA;&#x9;&#x9;// recursive function&#xA;&#x9;&#x9;packages = packages.concat(aPackage.Packages.GetAt(i), getSubpackagesOfPackage(aPackage.Packages.GetAt(i)));&#xA;&#x9;}&#xA;&#x9;return packages;&#xA;}&#xA;&#xA;/**&#xA; * @return Array&lt;EA.Connector&gt; associations (including the aggregations and compositions) that are version&#xA; *         controlled in the given package or one of its subpackages.&#xA; */&#xA;function getAssociationsOfPackageAndSubpackages(aPackage) {&#xA;&#x9;var element as EA.Element;&#xA;&#x9;var connector as EA.Connector;&#xA;&#x9;var addToMap;&#xA;&#x9;&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;var connectorMap = new Map();&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;element = elements[i];&#xA;&#x9;&#x9;for (var j = 0; j &lt; element.Connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;connector = element.Connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;addToMap = isConnectorAssociationAndControlledInSamePackageAsElement(connector, element);&#xA;&#x9;&#x9;&#x9;if (addToMap) {&#xA;&#x9;&#x9;&#x9;&#x9;if (!connectorMap.has(connector.ConnectorGUID)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;connectorMap.set(connector.ConnectorGUID, connector);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return Array.from(connectorMap.values());&#xA;}&#xA;&#xA;/**&#xA; * If a connector is controlled in the same package as a certain element, this means that both the element and the&#xA; * connector can be changed when the package the element belongs to is checked out. See also&#xA; * [Add Connectors To Locked Elements](https://www.sparxsystems.com/search/sphider/search.php?query=%22Add%20Connectors%20To%20Locked%20Elements%22&amp;type=phrase&amp;category=User+Guide+Latest&amp;tab=5&amp;search=1)&#xA; * &#xA; * @return {boolean} whether the given connector is an association (including aggregations and compositions) controlled in the same package&#xA; *         as in the given element&#xA; */&#xA;function isConnectorAssociationAndControlledInSamePackageAsElement(aConnector /* : EA.Connector */, anElement /* : EA.Element */) /* : boolean */ {&#xA;&#x9;var result;&#xA;&#x9;result =&#xA;&#x9;(Repository.GetElementByID(aConnector.ClientID).PackageID == Repository.GetElementByID(aConnector.SupplierID).PackageID &#xA;&#x9;&#x9;&amp;&amp; (aConnector.Type == &#34;Association&#34; || aConnector.Type == &#34;Aggregation&#34;))&#xA;&#x9;||&#xA;&#x9;((aConnector.ClientID == anElement.ElementID &amp;&amp; (aConnector.Type == &#34;Association&#34;))&#xA;&#x9;||&#xA;&#x9;(aConnector.SupplierID == anElement.ElementID &amp;&amp; aConnector.Type == &#34;Aggregation&#34;));&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param {EA.Element}&#xA; * @return {string} full path name of the given element (OCL style, see section 7.5.7 of the specification).&#xA; */&#xA;function getPathnameOfElement(anElement) {&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetPackageByID(anElement.PackageID);&#xA;&#x9;var pathname = package.Name + &#34;::&#34; + anElement.Name;&#xA;&#x9;do {&#xA;&#x9;&#x9;package = Repository.GetPackageByID(package.ParentID);&#xA;&#x9;&#x9;pathname = package.Name + &#34;::&#34; + pathname;&#xA;&#x9;} while (package.ParentID != 0)&#xA;&#x9;return pathname;&#xA;}&#xA;&#xA;/**&#xA; * @return {Array&lt;EA.Element&gt;} parent elements of the given element; the immediate parent is the first element in the array&#xA; */&#xA;function getParents(element) {&#xA;&#x9;// See Local Scripts.EAConstants-JScript for variable rsParents&#xA;&#x9;// Behaviour of GetRelationSet seems to be that the immediate parent is the first element in the array.&#xA;&#x9;elementIdsCommaSeparated = element.GetRelationSet(rsParents);&#xA;&#x9;var elements;&#xA;&#x9;if (elementIdsCommaSeparated.length == 0) {&#xA;&#x9;&#x9;elements = new Array();&#xA;&#x9;} else {&#xA;&#x9;&#x9;var elementIdsArray = elementIdsCommaSeparated.split(&#34;,&#34;);&#xA;&#x9;&#x9;elements = new Array(elementIdsArray.length);&#xA;&#x9;&#x9;for (var i in elementIdsArray) {&#xA;&#x9;&#x9;&#x9;elements[i] = Repository.GetElementByID(elementIdsArray[i]);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return elements;&#xA;}&#xA;&#xA;/**&#xA; * @return {Map&lt;int,EA.ConnectorEnd&gt;} map of the properties of the given element that are not inherited and that are association ends (not attributes)&#xA; *         The key is the connector ID, the value is the connector end.&#xA; */&#xA;function getNonInHeritedPropertiesThatAreAssociationEnds(element) {&#xA;&#x9;var properties = new Map();&#xA;&#x9;for (var i = 0; i &lt; element.Connectors.Count; i++) {&#xA;&#x9;&#x9;connector = element.Connectors.GetAt(i);&#xA;&#x9;&#x9;if (connector.Type == &#34;Association&#34; || connector.Type == &#34;Aggregation&#34;) {&#xA;&#x9;&#x9;&#x9;var property as EA.ConnectorEnd;&#xA;&#x9;&#x9;&#x9;var isOutgoing = false;&#xA;&#x9;&#x9;&#x9;if (element.ElementID == connector.ClientID &amp;&amp; connector.SupplierEnd.IsNavigable) {&#xA;&#x9;&#x9;&#x9;&#x9;isOutgoing = true;&#xA;&#x9;&#x9;&#x9;&#x9;property = connector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;} else if (element.ElementID == connector.SupplierID &amp;&amp; connector.ClientEnd.IsNavigable) {&#xA;&#x9;&#x9;&#x9;&#x9;isOutgoing = true;&#xA;&#x9;&#x9;&#x9;&#x9;property = connector.ClientEnd;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (isOutgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;properties.set(connector.ConnectorID, property);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return properties;&#xA;}&#xA;&#xA;/**&#xA; * @return {Array&lt;String&gt;} array containing the [UML classifiers](https://www.uml-diagrams.org/classifier.html) used in data modelling.&#xA; */&#xA;function getDataModellingClassifiers() {&#xA;&#x9;/* &#xA;&#x9; * Interface added, as interfaces occur in TC 211 abstract schemas.&#xA;&#x9; * Interfaces are not used in regular data modelling.&#xA;&#x9; */&#xA;&#x9;return Array.of(&#34;Class&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;, &#34;Interface&#34;);&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @return {boolean} whether the given connector is a kind of association&#xA; * (according to the UML metamodel, aggregations and compositions are kinds of associations)&#xA; */&#xA;function isConnectorKindOfAssociation(connector) {&#xA;&#x9;// in EA: a composition has Type aggregation (and subtype strong)&#xA;&#x9;return (connector.Type == &#34;Association&#34; || connector.Type == &#34;Aggregation&#34;);&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{165C7CCF-41B6-49b5-9159-AB71F1FD1F27}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validate-model-profile-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;!INC profile-test.validation-scripts-profile&#xA;&#xA;/**&#xA; * Validates any model against the&#xA; * [basic data model rules version 2](http://grunddatamodel.datafordeler.dk/modelregler/grunddatamodelregler.html)&#xA; * for a specific profile.&#xA; */&#xA;function main() {&#xA;&#x9;&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;var selectedPackage as EA.Package;&#x9;&#xA;&#x9;var now = new Date();&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#x9;&#xA;&#x9;&#xA;&#x9;var profile = Session.Input(&#34;Angiv profilen, der skal valideres: &#34;);&#xA;&#x9;&#xA;&#x9;// set log level to error as the output should only contain the validation report, no log messages&#xA;&#x9;LOGLEVEL = -1;&#xA;&#x9;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Dette er valideringsrapporten for modellen '&#34; + selectedPackage.Name + &#34;' udarbejdet af Modelsekretariatet d. &#34; + now.getDate() + &#34;/&#34; + (now.getMonth() + 1) + &#34; &#34; + now.getFullYear() + &#34;.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;OBS: Dette script validerer KUN for modeller lavet på MDG'en Grunddata2!&#34;);&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Vi tjekker på elementer med profilen: &#34;+profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;count = countHistorikmodel(elements,profile);&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;Session.Output(&#34;Der findes &#34; + count + &#34; element i modellen med denne profil.&#34;);&#xA;&#x9;&#x9;} else {Session.Output(&#34;Der findes &#34; + count + &#34; elementer i modellen med denne profil.&#34;);};&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34;________________________________________________________________________________________________________________&#34;)&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.1: Brug UML som det visuelle modelsprog&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.2: Brug kun udvalgte UML-elementer&#34;);&#xA;&#x9;&#x9;umlElementer(elements, profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.3: Brug UML-stereotyper&#34;);&#xA;&#x9;&#x9;stereotypes(selectedPackage,elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.4: Angiv meningsfyldte navne og beskrivelser for modellen&#34;);&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34;title (da) og description (da): &#34;);&#xA;&#x9;&#x9;modeltags1(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;language og modelScope: &#34;);&#xA;&#x9;&#x9;modeltags1_2(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Beskrivelser og titler bør kontrolleres manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.5: Angiv identifikation af modeller&#34;);&#xA;&#x9;&#x9;modeltags2(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.6: Angiv den modelansvarlige organisation&#34;);&#xA;&#x9;&#x9;modeltags3(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.7: Angiv emneområde for modellen&#34;);&#xA;&#x9;&#x9;modeltags4(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.8: Angiv modellens version&#34;);&#xA;&#x9;&#x9;modeltags5(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.9: Modellen skal godkendes&#34;);&#xA;&#x9;&#x9;modeltags6(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Efter endt kontrol og konformanstjek bør modellens status tilrettes.&#34;);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.10: Angiv modellens modelstatus&#34;);&#x9;&#xA;&#x9;&#x9;modeltags7(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.11: Angiv modellens lovgrundlag og kilde&#34;);&#xA;&#x9;&#x9;modeltags8(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens 'legalSource' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.12: Modeller klassifikationer til genbrug&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.13: God diagrammeringsskik&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.1: Angiv meningsfyldte UML-navne for modelelementer&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.2: Giv alle modelelementer en identifikator&#34;);&#xA;&#x9;&#x9;identifikator(elements,profile);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'URI' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.3: Angiv termer i et naturligt sprog&#34;);&#xA;&#x9;&#x9;prefLabel(elements,profile);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'prefLabel (da)' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.4: Brug standardiserede konventioner for angivelse af navne&#34;);&#xA;&#x9;&#x9;checkCamel(elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.5: Udarbejd definitioner eller beskrivelser af modellens elementer&#34;);&#xA;&#x9;&#x9;checkDef(elements,profile);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.6: Udarbejd strukturerede definitioner på en standardiseret måde&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.7: Udarbejd anvendelsesneutrale definitioner&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.8: Angiv modelelementers lovgrundlag&#34;);&#xA;&#x9;&#x9;checkLegal(elements,profile);&#xA;&#x9;&#x9;checkSource(elements,profile);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'legalSource' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.9: Brug standardiserede primitive datatyper&#34;);&#xA;&#x9;&#x9;ISOtype(elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.10: Angiv historikmodel for grunddataobjekttyper&#34;);&#xA;&#x9;&#x9;historik(elements,profile);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.1: Alle grunddataobjekttyper skal modelleres med persistent, unik identifikation&#34;);&#xA;&#x9;&#x9;checkID(elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.2: Alle grunddataobjekttyper skal understøtte registreringstid&#34;);&#xA;&#x9;&#x9;checkReg(elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.3: Grunddataobjekttyper bør understøtte virkningstid&#34;);&#xA;&#x9;&#x9;checkVirk(elements,profile);&#xA;&#x9;&#x9;historikReg(elements,profile);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.4: Alle grunddataobjekttyper bør modelleres med status&#34;);&#xA;&#x9;&#x9;Session.Output(checkAttr(elements,&#34;status&#34;,profile));&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.5: Alle modelentiteter bør understøtte beskedfordeling&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Forretningshændelse: &#34; + checkAttr(elements,&#34;forretningshændelse&#34;));&#xA;&#x9;&#x9;Session.Output(&#34;Forretningsproces: &#34; + checkAttr(elements,&#34;forretningsproces&#34;));&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;***** Rapport afsluttet &#34; + _LOGGetDisplayDate() +&#34; *****&#34;);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;LOGInfo(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{1C832A63-20DE-41b2-83D4-BB4A78B54191}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;change-tagged-value-from-single-line-to-multi-line&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;/**&#xA; * Converts single-line tagged values with the given name to multi-line tagged values.&#xA; * Multi-line tagged values are also known as &#34;memo&#34; tagged values.&#xA; *&#xA; * This can be useful when custom tagged values, not defined in a UML profile, have been added to &#xA; * model elements, and it becomes clear that they can contain a large amount of text&#xA; * and/or line breaks and new lines.&#xA; *&#xA; * @summary Converts single-line tagged values to multi-line tagged values.&#xA; */&#xA;function main() {&#xA;    // Show the script output window&#xA;    Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;    // Get the currently selected package in the tree to work on&#xA;    var aPackage as EA.Package;&#xA;    aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;    LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;    if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;        LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;        var taggedValueName = Session.Input(&#34;Tagged value to update&#34;);&#xA;        if (taggedValueName == null || taggedValueName == &#34;&#34;) {&#xA;            throw new Error(&#34;No tagged value given&#34;);&#xA;        } else {&#xA;            LOGInfo(&#34;Tagged value to update: &#34; + taggedValueName);&#xA;        }&#xA;&#xA;        var elements as EA.Collection;&#xA;        var currentElement as EA.Element;&#xA;        var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;        for (var i = 0; i &lt; elements.length; i++) {&#xA;            currentElement = elements[i];&#xA;            if (getDataModellingClassifiers().includes(currentElement.Type)) {&#xA;                changeTaggedValueElementFromSingleLineToMultiLine(currentElement, taggedValueName);&#xA;&#xA;                var attributes as EA.Collection;&#xA;                attributes = currentElement.Attributes;&#xA;                for (var j = 0; j &lt; attributes.Count; j++) {&#xA;                    var currentAttribute as EA.Attribute;&#xA;                    currentAttribute = attributes.GetAt(j);&#xA;                    changeTaggedValueAttributeFromSingleLineToMultiLine(currentAttribute, taggedValueName);&#xA;                }&#xA;&#xA;                var connectors as EA.Collection;&#xA;                connectors = currentElement.Connectors;&#xA;                for (var j = 0; j &lt; connectors.Count; j++) {&#xA;                    var currentConnector as EA.Connector;&#xA;                    currentConnector = connectors.GetAt(j);&#xA;                    var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;                    if (proceed) {&#xA;                        changeTaggedValueConnectorEndFromSingleLineToMultiLine(currentConnector, taggedValueName, true);&#xA;                        changeTaggedValueConnectorEndFromSingleLineToMultiLine(currentConnector, taggedValueName, false);&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        LOGInfo(&#34;Done!&#34;);&#xA;    } else {&#xA;        throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;    }&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{1EE8D5D6-6519-4984-B91B-08A12CC7BD98}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_tagged-values-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with the getting and setting of tagged values.&#xA; *       See also https://www.sparxsystems.com/search/sphider/search.php?query=automation+memo+tagged+value&amp;type=and&amp;category=User+Guide+Latest&amp;tab=5&amp;search=1.&#xA; *&#xA; */&#xA;var MAX_LENGTH_TAGGED_VALUE = 255;&#xA;&#xA;/*&#xA; * Do not use Collection.GetByName for searching for tagged values: documentation &#34;If the collection contains items, but it was unable to &#xA; * find an object with the specified name, the method raises an exception&#34; (note: the exception is Index out of bounds).&#xA; */&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueElement(theElement, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Notes;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function setTaggedValueElement(theElement, taggedValueName, taggedValueValue) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = theElement.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @return {boolean}&#xA; */&#xA;function hasElementTaggedValue(element, taggedValueName) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function changeTaggedValueElementFromSingleLineToMultiLine(theElement, taggedValueName) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Adds a new tagged value with the given name and value to the element. If the tagged&#xA; * value already exist, it is not updated.&#xA; *&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function addTaggedValueToElement(theElement, taggedValueName, taggedValueValue) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = theElement.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGDebug(&#34;Tagged value &#34; + taggedValueName + &#34; is already present on &#34; + theElement.Name);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param theElement {EA.Element}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function deleteTaggedValueElement(theElement, taggedValueName) {&#xA;&#x9;if (theElement != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.TaggedValue;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = theElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;theElement.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueAttribute(attribute, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Notes;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function setTaggedValueAttribute(attribute, taggedValueName, taggedValueValue) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = attribute.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @return {boolean}&#xA; */&#xA;function hasAttributeTaggedValue(attribute, taggedValueName) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function changeTaggedValueAttributeFromSingleLineToMultiLine(attribute, taggedValueName) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Adds a new tagged value with the given name and value to the attribute. If the tagged&#xA; * value already exist, it is not updated.&#xA; *&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; */&#xA;function addTaggedValueToAttribute(attribute, taggedValueName, taggedValueValue) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = attribute.TaggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Notes = taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Tagged value &#34; + taggedValueName + &#34; is already present on &#34; + attribute.Name);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param attribute {EA.Attribute}&#xA; * @param taggedValueName {string}&#xA; */&#xA;function deleteTaggedValueAttribute(attribute, taggedValueName) {&#xA;&#x9;if (attribute != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValue as EA.AttributeTag;&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#x9;&#x9;taggedValues = attribute.TaggedValues;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Name == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;attribute.TaggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueConnectorEnd(connector, taggedValueName, source, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substring(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.substring(16); // the following is removed from the start of the value: &lt;memo&gt;$ea_notes=&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.split(&#34;$ea_notes=&#34;)[0];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param connectorEnd {EA.ConnectorEnd}&#xA; * @param taggedValueName {string}&#xA; * @param defaultValue {string}&#xA; * @return {string}&#xA; */&#xA;function getTaggedValueConnectorEndByConnectorEnd(connectorEnd, taggedValueName, defaultValue) {&#xA;&#x9;var result = defaultValue;&#xA;&#x9;if (taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValues = connectorEnd.TaggedValues;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substring(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.substring(16); // the following is removed from the start of the value: &lt;memo&gt;$ea_notes=&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;result = taggedValue.Value.split(&#34;$ea_notes=&#34;)[0];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; * @param source {boolean}&#xA; */&#xA;function setTaggedValueConnectorEnd(connector, taggedValueName, taggedValueValue, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = taggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substring(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;$ea_notes=&#34; + taggedValueValue;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = truncateTaggedValueValueIfNeeded(taggedValueValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; * @return {boolean}&#xA; */&#xA;function hasConnectorEndTaggedValue(connector, taggedValueName, source) {&#xA;&#x9;var result = defaultValue;&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (taggedValue = null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; */&#xA;function changeTaggedValueConnectorEndFromSingleLineToMultiLine(connector, taggedValueName, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue != null) {&#xA;&#x9;&#x9;&#x9;if (taggedValue.Value.substring(0, 6) == &#34;&lt;memo&gt;&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;var taggedValueValue = taggedValue.Value;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Value = &#34;&lt;memo&gt;$ea_notes=&#34; + taggedValueValue;&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Adds a new tagged value with the given name and value to the source or target&#xA; * of te given connector. If the tagged value already exist, it is not updated.&#xA; *&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param taggedValueValue {string}&#xA; * @param source {boolean}&#xA; */&#xA;function addTaggedValueToConnectorEnd(connector, taggedValueName, taggedValueValue, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValue = taggedValues.GetAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (taggedValue == null) {&#xA;&#x9;&#x9;&#x9;taggedValue = taggedValues.AddNew(taggedValueName, truncateTaggedValueValueIfNeeded(taggedValueValue));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGDebug(&#34;Tagged value &#34; + taggedValueName + &#34; is already present on the &#34; + (source ? &#34;source&#34; : &#34;target&#34;) + &#34; end of &#34; + connector.Name);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;taggedValue.Update();&#xA;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param taggedValueName {string}&#xA; * @param source {boolean}&#xA; */&#xA;function deleteTaggedValueConnectorEnd(connector, taggedValueName, source) {&#xA;&#x9;if (connector != null &amp;&amp; taggedValueName.length &gt; 0) {&#xA;&#x9;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;&#x9;if (source) {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var taggedValue as EA.RoleTag;&#xA;&#x9;&#x9;taggedValue = null;&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;&#x9;if (taggedValues.GetAt(i).Tag == taggedValueName) {&#xA;&#x9;&#x9;&#x9;&#x9;taggedValues.Delete(i);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;taggedValues.Refresh();&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Truncates the value of a tagged value if it is longer than the maximum.&#xA; *&#xA; * When using a longer value than the maximum, the value cannot be set in the database. EA doesn't show a message&#xA; * but file %appdata%\Sparx Systems\EA\DBError.txt will contain the following:&#xA; * The field is too small to accept the amount of data you attempted to add.  Try inserting or pasting less data.&#xA; *&#xA; * Note that the above was true for eap(x) files. It seems that this does not occur anymore for qea (SQLite) files.&#xA; *&#xA; * @param taggedValueValue {string}&#xA; * @return {string} truncated value&#xA; */&#xA;function truncateTaggedValueValueIfNeeded(taggedValueValue) {&#xA;&#x9;var newTaggedValueValue;&#xA;&#x9;if (taggedValueValue.length &lt;= MAX_LENGTH_TAGGED_VALUE) {&#xA;&#x9;&#x9;newTaggedValueValue = taggedValueValue;&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGDebug(&#34;Truncate to &#34; + MAX_LENGTH_TAGGED_VALUE + &#34; characters: &#34; + taggedValueValue.substring(0, 30) + &#34;...&#34;);&#xA;&#x9;&#x9;newTaggedValueValue = taggedValueValue.substring(0, MAX_LENGTH_TAGGED_VALUE);&#xA;&#x9;}&#xA;&#x9;return newTaggedValueValue;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{2B5AA69A-C64A-4d2b-8B33-899B9CDD6C0C}"/>
         <Column name="ScriptAuthor" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-data-model-vocabulary-da&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;&#xA;/**&#xA; * Exports a data model to a Danish data vocabulary in the CSV format.&#xA; * The package containing the concept model must be selected in the Project Browser.&#xA; * If a URL is available for the dataset that is described by the data model, it can be provided and will be added to the data model.&#xA; * &#xA; * This script uses template vocabulary_csv.ftl in %EAMT_HOME%/config/templates.&#xA; *&#xA; * @summary Exports a data model to a data vocabulary.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;verifyEaModellingToolsJavaInstallation();&#xA;&#x9;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (package != null &amp;&amp; package.ParentID != 0) {&#xA;&#x9;&#xA;&#x9;&#x9;var outputFolder = chooseFolderWithUI(&#34;Folder in which the exported data vocabulary should be saved&#34;);&#xA;&#x9;&#x9;if (outputFolder.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var answer = Session.Prompt(&#34;Should the output file have a header?&#34;, promptYESNO);&#xA;&#x9;&#x9;var hasHeader;&#xA;&#x9;&#x9;if (answer == resultYes) {&#xA;&#x9;&#x9;&#x9;hasHeader = true;&#xA;&#x9;&#x9;} else if (answer == resultNo) {&#xA;&#x9;&#x9;&#x9;hasHeader = false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var answer = Session.Prompt(&#34;Is a link to metadata available for the data?&#34;, promptYESNO);&#xA;&#x9;&#x9;var hasMetadata;&#xA;&#x9;&#x9;var metadataUrl;&#xA;&#x9;&#x9;if (answer == resultYes) {&#xA;&#x9;&#x9;&#x9;hasMetadata = true;&#xA;&#x9;&#x9;&#x9;metadataUrl = Session.Input(&#34;Metadata URL: &#34;);&#xA;&#x9;&#x9;&#x9;if (metadataUrl.length == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;No metadata URL given&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (answer == resultNo) {&#xA;&#x9;&#x9;&#x9;hasMetadata = false;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Unexpected answer&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// cvs format; in Danish&#xA;&#x9;&#x9;var options = '-o &#34;' + outputFolder + '&#34; -pkg ' + package.PackageGUID + ' -t csv -l da -p 10 ';&#xA;&#x9;&#x9;if (hasHeader) {&#xA;&#x9;&#x9;&#x9;options = options + &#34; -h &#34;;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (hasMetadata) {&#xA;&#x9;&#x9;&#x9;options = options + &#34; -m &#34; + metadataUrl;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-data-model-vocabulary.bat&#34;, options);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;openFolderInWindowsExplorer(outputFolder);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{2BE390EC-AC6A-42fb-9829-BD93511F45A3}"/>
         <Column name="ScriptAuthor" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-data-model-configurable&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;&#xA;/**&#xA; * Exports a data model to a CSV file.&#xA; * The package containing the data model must be selected in the Project Browser.&#xA; *&#xA; * It is possible to choose the language:&#xA; * choose between da (Danish), en (English) and und (all available languages).&#xA; *&#xA; * It is possible to choose the strictness mode: choose between strict (fail when a tag is&#xA; * missing in the model), moderate (print _MISSING TAG_ in the output file when a tag is missing&#xA; * in the model) and lenient (output an empty string in the output file when a tag is missing in&#xA; * in the model. Use lenient when you are dealing with a model that you cannot change right now.&#xA; * Use moderate to identify the missing tags, and them in the model, and run this script again,&#xA; * now with strictness mode strict.&#xA; * &#xA; * This script uses one of the templates data_model_profile_csv.ftl in %EAMT_HOME%/config/templates.&#xA; *&#xA; * @summary Exports a data model with the user-defined settings.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;verifyEaModellingToolsJavaInstallation();&#xA;&#x9;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (package != null &amp;&amp; package.ParentID != 0) {&#xA;&#x9;&#xA;&#x9;&#x9;var outputFolder = chooseFolderWithUI(&#34;Folder in which the exported data model should be saved&#34;);&#xA;&#x9;&#x9;if (outputFolder.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var language = Session.Input(&#34;Language: da, en, und&#34;);&#xA;&#x9;&#x9;if (language == null || language == &#34;&#34;) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No language given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Chosen language: &#34; + language);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var mode = Session.Input(&#34;Strictness mode: strict, moderate, lenient&#34;);&#xA;&#x9;&#x9;if (mode == null || mode == &#34;&#34;) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No strictness mode given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Chosen mode: &#34; + mode);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// cvs format; in Danish; strict mode&#xA;&#x9;&#x9;var options = '-o &#34;' + outputFolder + '&#34; -pkg ' + package.PackageGUID + ' -t csv -l ' + language + ' -m ' + mode;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-data-model.bat&#34;, options);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;openFolderInWindowsExplorer(outputFolder);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{3655FF9C-3CD1-4760-A74F-4F0B743D0C4F}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;set-language-none&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;var NO_LANGUAGE = &#34;&lt;none&gt;&#34;;&#xA;&#xA;/**&#xA; * Sets the language of all clasess, datatypes, enumerations, interfaces and packages&#xA; * in the selected package to `&lt;none&gt;`, to indicate that the model element is not language-specific.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;).&#34;);&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;var element as EA.Element;&#xA;&#x9;&#x9;for (var i in elements) {&#xA;&#x9;&#x9;&#x9;element = elements[i];&#xA;&#x9;&#x9;&#x9;if (element.Type == &#34;Class&#34; || element.Type == &#34;Enumeration&#34; || element.Type == &#34;DataType&#34; || element.Type == 'Interface') {&#xA;&#x9;&#x9;&#x9;&#x9;element.Gentype = NO_LANGUAGE;&#xA;&#x9;&#x9;&#x9;&#x9;element.Update();&#xA;&#x9;&#x9;&#x9;&#x9;element.Refresh();&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Set language to &#34; + NO_LANGUAGE + &#34; on &#34; + element.Name);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;var packages = getSubpackagesOfPackage(aPackage).concat(aPackage);&#xA;&#x9;&#x9;var element as EA.Element;&#xA;&#x9;&#x9;for (var i in packages) {&#xA;&#x9;&#x9;&#x9;element = packages[i].Element;&#xA;&#x9;&#x9;&#x9;element.Gentype = NO_LANGUAGE;&#xA;&#x9;&#x9;&#x9;element.Update();&#xA;&#x9;&#x9;&#x9;element.Refresh();&#xA;&#x9;&#x9;&#x9;LOGDebug(&#34;Set language to &#34; + NO_LANGUAGE + &#34; on &#34; + aPackage.Name);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done.&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{411F9902-09C6-41bc-AD53-5786557967A6}"/>
         <Column name="ScriptAuthor" value="{70C0A695-3A03-4816-8FBB-A157114FA8E8}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;chg-add-new-profile&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;var PROFILES_TAG = &#34;profiles&#34;;&#xA;var PROFILES_SEPARATOR = &#34;,&#34;;&#xA;&#xA;var DEFAULT_VALUE_NO_TAG = &#34;noprofiles&#34;;&#xA;&#xA;/**&#xA; * Adds a new profile to the package and/or classifier (including the classifier's properties)&#xA; * selected in the project browser.&#xA; *&#xA; * @summary Adds a new profile to model elements, if not yet present.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;var profileToAdd = Session.Input(&#34;Give the name of the profile to add:&#34;);&#xA;&#x9;LOGInfo(&#34;Profile to add: &#34; + profileToAdd);&#xA;&#x9;&#xA;&#x9;var treeSelectedType = Repository.GetTreeSelectedItemType();&#xA;    switch (treeSelectedType) {&#xA;&#x9;&#x9;case otElement:&#xA;&#x9;&#x9;&#x9;var selectedElement as EA.Element;&#xA;&#x9;&#x9;&#x9;selectedElement = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;addProfileToElementAttributeAndConnectorEnds(selectedElement, profileToAdd);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case otPackage:&#xA;&#x9;&#x9;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;&#x9;&#x9;selectedPackage = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;addProfileToPackage(selectedPackage, profileToAdd);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default: LOGWarn(&#34;This script requires a package or an element to be selected in the Browser&#34;);&#xA;&#x9;}&#xA;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;}&#xA;&#xA;function addProfileToPackage(aPackage, profileToAdd) {&#xA;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#x9;var elements as EA.Collection;&#xA;&#x9;var currentElement as EA.Element;&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;addProfileToElementAttributeAndConnectorEnds(currentElement, profileToAdd);&#xA;&#x9;}&#xA;}&#xA;&#xA;function addProfileToElementAttributeAndConnectorEnds(element, profileToAdd) {&#xA;&#x9;if (getDataModellingClassifiers().includes(element.Type)) {&#xA;&#x9;&#x9;addProfileToElement(element, profileToAdd);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;attributes = element.Attributes;&#xA;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;addProfileToAttribute(currentAttribute, profileToAdd);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;connectors = element.Connectors;&#xA;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;if (isConnectorKindOfAssociation(currentConnector)) {&#xA;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, element);&#xA;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addProfileToConnectorEnd(currentConnector, profileToAdd, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addProfileToConnectorEnd(currentConnector, profileToAdd, false);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;function addProfileToElement(element, profileToAdd) {&#xA;&#x9;var value = getTaggedValueElement(element, PROFILES_TAG, DEFAULT_VALUE_NO_TAG);&#xA;&#x9;if (value == DEFAULT_VALUE_NO_TAG || value.trim() == &#34;&#34;) {&#xA;&#x9;&#x9;setTaggedValueElement(element, PROFILES_TAG, profileToAdd);&#xA;&#x9;} else {&#xA;&#x9;&#x9;var profiles = value.split(PROFILES_SEPARATOR);&#xA;&#x9;&#x9;if (!profiles.includes(profileToAdd)) {&#xA;&#x9;&#x9;&#x9;profiles = profiles.concat(profileToAdd);&#xA;&#x9;&#x9;&#x9;setTaggedValueElement(element, PROFILES_TAG, profiles.join(PROFILES_SEPARATOR));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;function addProfileToAttribute(attribute, profileToAdd) {&#xA;&#x9;var value = getTaggedValueAttribute(attribute, PROFILES_TAG, DEFAULT_VALUE_NO_TAG);&#xA;&#x9;if (value == DEFAULT_VALUE_NO_TAG || value.trim() == &#34;&#34;) {&#xA;&#x9;&#x9;setTaggedValueAttribute(attribute, PROFILES_TAG, profileToAdd);&#xA;&#x9;} else {&#xA;&#x9;&#x9;var profiles = value.split(PROFILES_SEPARATOR);&#xA;&#x9;&#x9;if (!profiles.includes(profileToAdd)) {&#xA;&#x9;&#x9;&#x9;profiles = profiles.concat(profileToAdd);&#xA;&#x9;&#x9;&#x9;setTaggedValueAttribute(attribute, PROFILES_TAG, profiles.join(PROFILES_SEPARATOR));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;function addProfileToConnectorEnd(connector, profileToAdd, source) {&#xA;&#x9;var value = getTaggedValueConnectorEnd(connector, PROFILES_TAG, source, DEFAULT_VALUE_NO_TAG);&#xA;&#x9;if (value == DEFAULT_VALUE_NO_TAG || value.trim() == &#34;&#34;) {&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, PROFILES_TAG, profileToAdd, source);&#xA;&#x9;} else {&#xA;&#x9;&#x9;var profiles = value.split(PROFILES_SEPARATOR);&#xA;&#x9;&#x9;if (!profiles.includes(profileToAdd)) {&#xA;&#x9;&#x9;&#x9;profiles = profiles.concat(profileToAdd);&#xA;&#x9;&#x9;&#x9;setTaggedValueConnectorEnd(connector, PROFILES_TAG, profiles.join(PROFILES_SEPARATOR), source);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{476530C8-08A5-4b69-8B8B-C4F525BB730E}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;fix-grunddata-dkdomaenemodel-stereotype&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;&#xA;/**&#xA; * Certain older models were given stereotype Grunddata::DKDomænemodel, but for some&#xA; * reason (a bug or shortcoming in older EA versions?), the fully-qualified stereotype was not saved&#xA; * in the XMI-file.&#xA; *&#xA; * For newer models with stereotype Grunddata::DKDomænemodel, the XMI 1.1 file in SVN will contain&#xA; * a tagged value with name $ea_xref_property and a value that contains FQName=Grunddata::DKDomænemodel,&#xA; * for example:&#xA; *&#xA; * ```xml&#xA; * &lt;!-- … --&gt;&#xA; * &lt;UML:TaggedValue tag=&#34;stereotype&#34; value=&#34;DKDomænemodel&#34;/&gt;&#xA; * &lt;!-- … --&gt;&#xA; * &lt;UML:TaggedValue tag=&#34;$ea_xref_property&#34; value=&#34;…Name=DKDomænemodel;FQName=Grunddata::DKDomænemodel…&#34;/&gt;&#xA; * &lt;!-- … --&gt;&#xA; * ```&#xA; * &#xA; * For older models, the tagged value with name $ea_xref_property is not present. This gives issues&#xA; * when loading the model when the MDG containing the Grunddata2::DKDomænemodel stereotype is loaded, as&#xA; * EA then possibly assumes that the stereotype of the model is Grunddata2::DKDomænemodel, not &#xA; * Grunddata::DKDomænemodel. You can see that this is the case when the stereotype in the docked&#xA; * [Properties **Window**](https://sparxsystems.com/eahelp/proptab.html)&#xA; * is shown as Grunddata2::DKDomænemodel, whereas the &#xA; * [Properties **Dialog**](https://sparxsystems.com/eahelp/objectproperties.html)&#xA; * contains a tab &#34;Grunddata&#34;, showing the tags defined for stereotype Grunddata::DKDomænemodel.&#xA; *&#xA; * This script sets the fully-qualified stereotype of the selected package to Grunddata::DKDomænemodel directly&#xA; * in the EA project file. The package does not have to be checked out to be able to do this. This can be sufficient&#xA; * when you only want to export the model in a certain format.&#xA; *&#xA; * Note: you need to select another package and then the updated package again&#xA; * to see the change in the Properties Window.&#xA; *&#xA; * To set the correct fully-qualified stereotype in the XMI file as well, &#xA; * &#xA; * 1. make sure all the package's dependencies are present in the EA project file;&#xA; * 2. check out the package;&#xA; * 3. run this script;&#xA; * 4. check in the package again.&#xA; * &#xA; * @summary Sets the stereotype of a model to Grunddata::DKDomænemodel.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;GD2MDG&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id GD2MDG, containing UML profile Grunddata2, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;Geodata&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id Geodata, containing UML profile Geodata, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;Grunddata&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id Geodata, containing UML profile Grunddata, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;var promptResult = Session.Prompt(&#34;Set the stereotype to Grunddata::DKDomænemodel (instead of &#34; + selectedPackage.Element.FQStereotype + &#34;) in database &#34; + Repository.ConnectionString + &#34;?&#34;, promptYESNO);&#xA;&#x9;&#x9;switch (promptResult) {&#xA;&#x9;&#x9;&#x9;case resultYes:&#xA;&#x9;&#x9;&#x9;&#x9;var updateStatement = &#34;UPDATE t_xref SET description = '@STEREO;Name=DKDomænemodel;FQName=Grunddata::DKDomænemodel;@ENDSTEREO;' WHERE client = '&#34; + selectedPackage.Element.ElementGUID + &#34;' AND name = 'Stereotypes';&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;Repository.Execute(updateStatement);&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Executed &#34; + updateStatement);&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Select another package and then &#34; + selectedPackage.Name + &#34; again to see the change&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case resultNo:&#xA;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{5C4E4A76-F95B-497d-B184-55A872D3D9E0}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;remove-tagged-value&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA; &#xA;/**&#xA; * Removes all tagged values, with the name given via user input, from all classifiers&#xA; * used in data modelling, and from their properties, &#xA; * in the selected package and subpackages.&#xA; *&#xA; * @summary Remove a tagged value from the model.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on aPackage '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var taggedValue = Session.Input(&#34;Tagged value to remove&#34;);&#xA;&#x9;&#x9;if (taggedValue == null || taggedValue == &#34;&#34;) {&#xA;&#x9;&#x9;&#x9;LOGWarning(&#34;No tagged value given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Tagged value to remove: &#34; + taggedValue);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (getDataModellingClassifiers().includes(currentElement.Type)) {&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, taggedValue);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueAttribute(currentAttribute, taggedValue);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, taggedValue, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, taggedValue, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{6899B6FC-ED87-4371-A1D7-D1D9EB10798D}"/>
         <Column name="ScriptAuthor" value="{2D4D14C7-61B2-4792-8F5F-00705AFB7436}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;retrieve-process-id-of-running-ea-instance&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._command-line-utils&#xA;&#xA;/**&#xA; * Retrieves the [Windows process id](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/finding-the-process-id) &#xA; * of the EA instance from which this script is invoked. The process id can be used as an argument to one of the applications&#xA; * in the EAMT Modelling Tools Java.&#xA; *&#xA; * @summary Retrieves the Windows process id of this EA instance.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;Session.Output(determineProcessId());&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{69F88BC7-43B2-45b9-BFFB-2A2F76A093D1}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;link-the-type-on-attributes-to-a-type-in-the-model&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._messages&#xA; &#xA; /**&#xA; * Makes sure that the types of the attributes are actually &#xA; * present as classifiers in the model.&#xA; *&#xA; * @summary Change attribute type to classifier reference.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var thePackage as EA.Package;&#xA;&#x9;thePackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;LOGInfo(&#34;Working on package '&#34; + thePackage.Name + &#34;' (ID=&#34; + thePackage.PackageID + &#34;)&#34; );&#xA;&#x9;&#xA;&#x9;if (thePackage != null &amp;&amp; thePackage.ParentID != 0) {&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(thePackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Working on &#34; + currentElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Attribute &#34; + currentAttribute.Name + &#34; with classifierId &#34; + currentAttribute.ClassifierID + &#34; and type &#34; + currentAttribute.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttribute.ClassifierID == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var foundElements as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foundElements = Repository.GetElementSet(&#34;SELECT * FROM t_object WHERE Name = '&#34; + currentAttribute.Type + &#34;'&#34;, 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Count: &#34; + foundElements.Count);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (foundElements.Count == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Not found: &#34; + currentAttribute.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (foundElements.Count == 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Found: &#34; + foundElements.GetAt(0).Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = foundElements.GetAt(0).ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'Boolean') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name Boolean, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{8887B7F7-C12C-4c24-99B4-BCA7B303291F}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {8887B7F7-C12C-4c24-99B4-BCA7B303291F} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'CharacterString') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name CharacterString, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{0A614EA9-13B7-4ebe-85ED-AA187D27CBD1}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {0A614EA9-13B7-4ebe-85ED-AA187D27CBD1} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'GM_Point') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name GM_Point, choose the one from ISO 19107!:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{3CC5A3E8-2ECA-4e42-B09C-935BD5D3B64A}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {3CC5A3E8-2ECA-4e42-B09C-935BD5D3B64A} from ISO 19107:2003&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (currentAttribute.Type == 'UomWeight') {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// 19103:2015 contains two model constructs with name UomWeight, choose the right one:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var correctCharacterStringElement = Repository.GetElementByGuid(&#34;{22EB37C8-C673-4636-ACFC-6FAF355A619D}&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Picking CharacterString with GUID {22EB37C8-C673-4636-ACFC-6FAF355A619D} from ISO 19103:2015&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.ClassifierID = correctCharacterStringElement.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;More than one &#34; + currentAttribute.Type + &#34; found in model, update the attributes with that type manually (access them via model search val_attribute_type)&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;currentElement.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;thePackage.Elements.Refresh();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;LOGInfo( &#34;Done!&#34; );&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{6EDAAE4E-3B45-4bc1-B4D6-2C1740B50233}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_logging-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with logging.&#xA; *&#xA; * You can change the log level at any time during execution by setting the LOGLEVEL variable&#xA; * in your script to the desired value. Valid values for LOGLEVEL are:&#xA; * - LOGLEVEL_ERROR&#xA; * - LOGLEVEL_WARNING&#xA; * - LOGLEVEL_INFO&#xA; * - LOGLEVEL_DEBUG&#xA; * - LOGLEVEL_TRACE&#xA; *&#xA; * This script is a JavaScript version of the original JScript-Logging from Sparx, and with more logical&#xA; * log levels (ERROR - WARNING - INFO - DEBUG - TRACE instead of ERROR - INFO - WARNING - DEBUG - TRACE).&#xA; * See also https://www.sparxsystems.com/forums/smf/index.php/topic,11082.msg149186.html.&#xA; */&#xA;&#xA;// LOGLEVEL values&#xA;var LOGLEVEL_ERROR = 0;&#xA;var LOGLEVEL_WARNING = 1;&#xA;var LOGLEVEL_INFO = 2;&#xA;var LOGLEVEL_DEBUG = 3;&#xA;var LOGLEVEL_TRACE = 4;&#xA;&#xA;// The level to log at; change if needed in your own script.&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Logs a message at the ERROR level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_ERROR or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGError(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_ERROR)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [ERROR]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the INFO level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_INFO or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGInfo(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_INFO)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [INFO]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the WARNING level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_WARNING or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGWarning(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_WARNING)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [WARNING]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the DEBUG level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_DEBUG or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGDebug(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_DEBUG)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [DEBUG]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Logs a message at the TRACE level. The message will be displayed if LOGLEVEL is set to &#xA; * LOGLEVEL_TRACE or above.&#xA; *&#xA; * @param {string} message The message to log&#xA; */&#xA;function LOGTrace(message) {&#xA;&#x9;if (LOGLEVEL &gt;= LOGLEVEL_TRACE)&#xA;&#x9;&#x9;Session.Output(_LOGGetDisplayDate() + &#34; [TRACE]: &#34; + message);&#xA;}&#xA;&#xA;/**&#xA; * Returns the current date/time in a format suitable for logging.&#xA; *&#xA; * @return {string} The current date/time&#xA; * @private&#xA; */&#xA;function _LOGGetDisplayDate() {&#xA;&#x9;var now = new Date();&#xA;&#xA;&#x9;// Pad hour value&#xA;&#x9;var hours = now.getHours();&#xA;&#x9;if (hours &lt; 10)&#xA;&#x9;&#x9;hours = &#34;0&#34; + hours;&#xA;&#xA;&#x9;// Pad minute value&#xA;&#x9;var minutes = now.getMinutes();&#xA;&#x9;if (minutes &lt; 10)&#xA;&#x9;&#x9;minutes = &#34;0&#34; + minutes;&#xA;&#xA;&#x9;// Pad second value&#xA;&#x9;var seconds = now.getSeconds();&#xA;&#x9;if (seconds &lt; 10)&#xA;&#x9;&#x9;seconds = &#34;0&#34; + seconds;&#xA;&#xA;&#x9;var displayDate = now.getFullYear() + &#34;-&#34; + (now.getMonth() + 1) + &#34;-&#34; + now.getDate();&#xA;&#x9;displayDate += &#34; &#34; + hours + &#34;:&#34; + minutes + &#34;:&#34; + seconds;&#xA;&#xA;&#x9;return displayDate;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{758532AB-EBA1-4ea6-B9C3-746814C64568}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_constants&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains constants used by EA or Windows. Taken from EAConstants-JScript in Local Scripts.&#xA; */&#xA;&#xA;/*&#xA; * Prompt types for Session.Prompt().&#xA; */&#xA;var promptOK&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 1;&#xA;var promptYESNO&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 2;&#xA;var promptYESNOCANCEL&#x9;&#x9;&#x9;&#x9;= 3;&#xA;var promptOKCANCEL&#x9;&#x9;&#x9;&#x9;&#x9;= 4;&#xA;&#xA;/*&#xA; * Prompt results from Session.Prompt().&#xA; */&#xA;var resultOK&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 1;&#xA;var resultCancel&#x9;&#x9;&#x9;&#x9;&#x9;= 2;&#xA;var resultYes&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 3;&#xA;var resultNo&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 4;&#xA;&#xA;var otNone &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 0;&#xA;var otProject &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 1;&#xA;var otRepository &#x9;&#x9;&#x9;&#x9;&#x9;= 2;&#xA;var otCollection &#x9;&#x9;&#x9;&#x9;&#x9;= 3;&#xA;var otElement &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 4;&#xA;var otPackage &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 5;&#xA;var otModel &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 6;&#xA;var otConnector &#x9;&#x9;&#x9;&#x9;&#x9;= 7;&#xA;var otDiagram &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 8;&#xA;var otRequirement &#x9;&#x9;&#x9;&#x9;&#x9;= 9;&#xA;var otScenario &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 10;&#xA;var otConstraint &#x9;&#x9;&#x9;&#x9;&#x9;= 11;&#xA;var otTaggedValue &#x9;&#x9;&#x9;&#x9;&#x9;= 12;&#xA;var otFile &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 13;&#xA;var otEffort &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 14;&#xA;var otMetric &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 15;&#xA;var otIssue &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 16;&#xA;var otRisk &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 17;&#xA;var otTest &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 18;&#xA;var otDiagramObject &#x9;&#x9;&#x9;&#x9;= 19;&#xA;var otDiagramLink &#x9;&#x9;&#x9;&#x9;&#x9;= 20;&#xA;var otResource &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 21;&#xA;var otConnectorEnd &#x9;&#x9;&#x9;&#x9;&#x9;= 22;&#xA;var otAttribute &#x9;&#x9;&#x9;&#x9;&#x9;= 23;&#xA;var otMethod &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 24;&#xA;var otParameter &#x9;&#x9;&#x9;&#x9;&#x9;= 25;&#xA;var otClient &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 26;&#xA;var otAuthor &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 27;&#xA;var otDatatype &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 28;&#xA;var otStereotype &#x9;&#x9;&#x9;&#x9;&#x9;= 29;&#xA;var otTask &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 30;&#xA;var otTerm &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 31;&#xA;var otProjectIssues &#x9;&#x9;&#x9;&#x9;= 32;&#xA;var otAttributeConstraint &#x9;&#x9;&#x9;= 33;&#xA;var otAttributeTag &#x9;&#x9;&#x9;&#x9;&#x9;= 34;&#xA;var otMethodConstraint &#x9;&#x9;&#x9;&#x9;= 35;&#xA;var otMethodTag &#x9;&#x9;&#x9;&#x9;&#x9;= 36;&#xA;var otConnectorConstraint &#x9;&#x9;&#x9;= 37;&#xA;var otConnectorTag &#x9;&#x9;&#x9;&#x9;&#x9;= 38;&#xA;var otProjectResource &#x9;&#x9;&#x9;&#x9;= 39;&#xA;var otReference &#x9;&#x9;&#x9;&#x9;&#x9;= 40;&#xA;var otRoleTag&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 41;&#xA;var otCustomProperty &#x9;&#x9;&#x9;&#x9;= 42;&#xA;var otPartition &#x9;&#x9;&#x9;&#x9;&#x9;= 43;&#xA;var otTransition &#x9;&#x9;&#x9;&#x9;&#x9;= 44;&#xA;var otEventProperty &#x9;&#x9;&#x9;&#x9;= 45;&#xA;var otEventProperties &#x9;&#x9;&#x9;&#x9;= 46;&#xA;var otPropertyType &#x9;&#x9;&#x9;&#x9;&#x9;= 47;&#xA;var otProperties &#x9;&#x9;&#x9;&#x9;&#x9;= 48;&#xA;var otProperty &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 49;&#xA;var otSwimlaneDef &#x9;&#x9;&#x9;&#x9;&#x9;= 50;&#xA;var otSwimlanes &#x9;&#x9;&#x9;&#x9;&#x9;= 51;&#xA;var otSwimlane &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 52;&#xA;var otModelWatcher &#x9;&#x9;&#x9;&#x9;&#x9;= 53;&#xA;var otScenarioStep &#x9;&#x9;&#x9;&#x9;&#x9;= 54;&#xA;var otScenarioExtension &#x9;&#x9;&#x9;= 55;&#xA;var otParamTag&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;= 56;&#xA;var&#x9;otProjectRole&#x9;&#x9;&#x9;&#x9;&#x9;= 57;&#xA;var otDocumentGenerator&#x9;&#x9;&#x9;&#x9;= 58;&#xA;var otMailInterface&#x9;&#x9;&#x9;&#x9;&#x9;= 59;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{7AB639B6-0D49-4f22-9BE9-2FA1D43ACD99}"/>
         <Column name="ScriptAuthor" value="{70C0A695-3A03-4816-8FBB-A157114FA8E8}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;chg-add-profiles-tag&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;var PROFILES_TAG = &#34;profiles&#34;;&#xA;&#xA;/**&#xA; * Adds tagged value &#34;profiles&#34; to the package and/or classifier (including the classifier's properties)&#xA; * selected in the project browser, if that tagged value is not yet present.&#xA; *&#xA; * The value of tagged value &#34;profiles&#34; is set to an empty string, if the tagged value is not yet present.&#xA; *&#xA; * @summary Prepare a model for profiling.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;&#xA;&#x9;var treeSelectedType = Repository.GetTreeSelectedItemType();&#xA;    switch (treeSelectedType) {&#xA;&#x9;&#x9;case otElement:&#xA;&#x9;&#x9;&#x9;var selectedElement as EA.Element;&#xA;&#x9;&#x9;&#x9;selectedElement = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;addProfilesTagToElement(selectedElement);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case otPackage:&#xA;&#x9;&#x9;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;&#x9;&#x9;selectedPackage = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;addProfilesTagToPackage(selectedPackage);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default: LOGWarn(&#34;This script requires a package or an element to be selected in the Browser&#34;);&#xA;&#x9;}&#xA;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;}&#xA;&#xA;function addProfilesTagToPackage(aPackage) {&#xA;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#x9;var elements as EA.Collection;&#xA;&#x9;var currentElement as EA.Element;&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;addProfilesTagToElement(currentElement);&#xA;&#x9;}&#xA;}&#xA;&#xA;function addProfilesTagToElement(element) {&#xA;&#x9;if (getDataModellingClassifiers().includes(element.Type)) {&#xA;&#x9;&#x9;addTaggedValueToElement(element, PROFILES_TAG, &#34;&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;attributes = element.Attributes;&#xA;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;addTaggedValueToAttribute(currentAttribute, PROFILES_TAG, &#34;&#34;);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;connectors = element.Connectors;&#xA;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;if (isConnectorKindOfAssociation(currentConnector)) {&#xA;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, element);&#xA;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.ClientEnd.Navigable == &#34;Navigable&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addTaggedValueToConnectorEnd(currentConnector, PROFILES_TAG, &#34;&#34;, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, PROFILES_TAG, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.SupplierEnd.Navigable == &#34;Navigable&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addTaggedValueToConnectorEnd(currentConnector, PROFILES_TAG, &#34;&#34;, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, PROFILES_TAG, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{7B773725-B9B8-40e5-9D79-FDD5E7F1BDFF}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_guid-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains utility functions to assist with working with UUIDs (universally unique identifiers).&#xA; */&#xA;&#xA;/**&#xA; * @param guid {string} GUID (Microsoft UUID, enclosed in curly braces {})&#xA; * @return {string} GUID without curly braces&#xA; */&#xA;function convertGuidToStandardRepresentation(guid) {&#xA;&#x9;if (guid.length != 38) {&#xA;&#x9;&#x9;var message = &#34;Length of &#34; + guid + &#34; is not 38, expected a UUID surrounded with curly braces&#34;;&#xA;&#x9;&#x9;throw message;&#xA;&#x9;}&#xA;&#x9;return guid.toLowerCase().substring(1,36);&#xA;}&#xA;&#xA;/**&#xA; * @param connectorGuid {string} GUID of the connector the connector end belongs to&#xA; * @param source {boolean} whether the connector is the source (true) or the target (false) of the connector&#xA; * @return GUID in XML of a connector end&#xA; */&#xA;function determineGuidAsXMLOfConnectorEnd(connectorGuid /* string */, source /* boolean */) {&#xA;&#x9;var connectorGuidAsXML = Repository.GetProjectInterface().GUIDtoXML(connectorGuid);&#xA;&#x9;var connectorGuidAsXML;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;connectorGuidAsXML = connectorGuidAsXML.substring(0, 5) + &#34;src&#34; + connectorGuidAsXML.substring(7);&#xA;&#x9;} else {&#xA;&#x9;&#x9;connectorGuidAsXML = connectorGuidAsXML.substring(0, 5) + &#34;dst&#34; + connectorGuidAsXML.substring(7);&#xA;&#x9;}&#xA;&#x9;return connectorGuidAsXML;&#xA;&#x9;&#xA;}"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{81B4C325-AFBA-4885-8A0B-1C6FEE159E72}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_command-line-utils&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/**&#xA; * @file This file contains functions to provide the &#34;glue&#34; between a script in EA and a .bat file calling e.g. Java code.&#xA; */&#xA; !INC eamt-utilities._logging-utils&#xA;&#xA;var ENV_VARIABLE_LOCATION_TOOLS = &#34;EAMT_HOME&#34;;&#xA;&#xA;/**&#xA; * Provides access to aspects of the Windows Shell, such as applications, shortscuts, environment variables,&#xA; * the registry, and operating environment (from &#34;Windows Powershell Pocket References&#34; by Lee Holmes).&#xA; *&#xA; * See more on [WshShell Object](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/aew9yb99(v=vs.84))&#xA; */&#xA;var WSH_SHELL = new COMObject(&#34;WScript.Shell&#34;);&#xA;&#xA;/*&#xA; * Possible values for the type of popup (WSH_SHELL.Popup). Values can be added up to combine them.&#xA; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f(v=vs.84).&#xA; */&#xA;var PT_OK = 0;&#xA;var PT_OKCANCEL = 1;&#xA;var PT_ABORTRETRYIGNORE = 2;&#xA;var PT_YESNOCANCEL = 3;&#xA;var PT_YESNO = 4;&#xA;var PT_RETRYCANCEL = 5;&#xA;var PT_CANCELTRYCONTINUE = 6;&#xA;var PT_ICONSTOP = 16;&#xA;var PT_ICONQUESTION = 32;&#xA;var PT_ICONEXCLAMATION = 48;&#xA;var PT_ICONINFORMATION = 64;&#xA;var PT_DEFBUTTON2 = 256;&#xA;var PT_DEFBUTTON3 = 512;&#xA;&#xA;/*&#xA; * Possible return values of WSH_SHELL.Popup method.&#xA; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f(v=vs.84).&#xA; */&#xA;var BTN_NONECLICKED = -1;&#xA;var BTN_OK = 1;&#xA;var BTN_CANCEL = 2;&#xA;var BTN_ABORT = 3;&#xA;var BTN_RETRY = 4;&#xA;var BTN_IGNORE = 5;&#xA;var BTN_YES = 6;&#xA;var BTN_NO = 7;&#xA;var BTN_TRYAGAIN = 10;&#xA;var BTN_CONTINUE = 11;&#xA;&#xA;/**&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} arguments to give to the .bat file&#xA; */&#xA;function runBatFileInDefaultWorkingDirectory(batFileToInvoke, programArguments) {&#xA;&#x9;runBatFileInSpecifiedWorkingDirectory(WSH_SHELL.ExpandEnvironmentStrings(&#34;%&#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34;%&#34;), batFileToInvoke, programArguments);&#xA;}&#xA;&#xA;/**&#xA; * @param {string} workingDirectory working directory&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} arguments to give to the .bat file&#xA; */&#xA;function runBatFileInSpecifiedWorkingDirectory(workingDirectory, batFileToInvoke, programArguments) {&#xA;&#x9;var processId = determineProcessId(workingDirectory);&#xA;&#x9;if (processId != &#34;-1&#34;) {&#xA;&#x9;&#x9;runBatFileInSpecifiedWorkingDirectoryWithProcessId(workingDirectory, batFileToInvoke, processId, programArguments);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(&#34;Cannot proceed, stopping here.&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param {string} workingDirectory working directory&#xA; * @param {string} batFileToInvoke the .bat file to be invoked&#xA; * @param {string} processId the process id of the running EA instance&#xA; * @param {string} arguments to give to the .bat file&#xA; * @private&#xA; */&#xA;function runBatFileInSpecifiedWorkingDirectoryWithProcessId(workingDirectory, batFileToInvoke, processId, programArguments) {&#xA;&#x9;var environmentString = &#34;%&#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34;%&#34;;&#xA;&#x9;var locationDMT = WSH_SHELL.ExpandEnvironmentStrings(environmentString);&#xA;&#x9;if (environmentString == locationDMT) {&#xA;&#x9;&#x9;LOGError(&#34;Environment variable &#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34; not set, set this environment variable and restart Enterprise Architect&#34;);&#xA;&#x9;&#x9;throw new Error(&#34;Have you installed EA Modelling Tools Java (correctly)?&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;var command = '&#34;' + locationDMT + '\\bin\\' + batFileToInvoke + '&#34;' + &#34; -eapid &#34; + processId + &#34; &#34; + programArguments;&#xA;&#x9;&#x9;LOGInfo(&#34;command: &#34; + command);&#xA;&#x9;&#x9;runCommand(workingDirectory, command);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Determines the process id of the running EA instance based on the Windows tasklist command.&#xA; *&#xA; * @return {string} process id of the running EA instance&#xA; */&#xA;function determineProcessId() {&#xA;&#x9;var processId;&#xA;&#x9;var command = 'TASKLIST /V /FO CSV /NH /FI &#34;IMAGENAME eq EA.exe&#34; /FI &#34;WINDOWTITLE eq ' + getWindowTitleForInstanceOfEA() + '&#34;';&#xA;&#x9;LOGInfo(command);&#xA;&#x9;var wse = WSH_SHELL.Exec(command); // returns WshScriptExec Object, see https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/2f38xsxe%28v%3dvs.84%29&#xA;&#x9;while (wse.Status == 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Retrieving process id&#34;);&#xA;&#x9;&#x9;// alternative way of &#34;sleeping&#34;&#xA;&#x9;&#x9;// see also https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f%28v%3dvs.84%29&#xA;&#x9;&#x9;// see also http://www.sparxsystems.com/forums/smf/index.php/topic,6063.msg127934.html&#xA;&#x9;&#x9;WSH_SHELL.Popup(&#34;Retrieving process id&#34;, 1, &#34;Info message&#34;, PT_OK + PT_ICONINFORMATION);&#xA;&#x9;}&#xA;&#x9;if (!wse.StdOut.AtEndOfStream) {&#xA;&#x9;&#x9;var output = wse.StdOut.ReadAll();&#xA;&#x9;&#x9;LOGInfo(output);&#xA;&#x9;&#x9;if (output.indexOf(&#34;No tasks are running which match the specified criteria&#34;) != -1) {&#xA;&#x9;&#x9;&#x9;throw new Error(&#34;Is the command correct? Check the script.&#34;);&#xA;&#x9;&#x9;&#x9;processId = &#34;-1&#34;;&#xA;&#x9;&#x9;} else if (output.search(/\n&#34;EA.exe&#34;/g) != -1) {&#xA;&#x9;&#x9;&#x9;throw new Error(&#34;More than one task found. Is the command correct? Check the script.&#34;);&#xA;&#x9;&#x9;&#x9;processId = &#34;-1&#34;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;// process id is the second value: &#34;EA.exe&#34;,&#34;4852&#34;,...&#xA;&#x9;&#x9;&#x9;outputAsArray = output.split(&#34;,&#34;);&#xA;&#x9;&#x9;&#x9;processIdWithQuotes = outputAsArray[1];&#xA;&#x9;&#x9;&#x9;processId = processIdWithQuotes.substring(1, processIdWithQuotes.lastIndexOf('&#34;'));&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;process id=&#34; + processId);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (!wse.StdErr.AtEndOfStream) {&#xA;&#x9;&#x9;LOGError(wse.StdErr.ReadAll());&#xA;&#x9;&#x9;processId = -1;&#xA;&#x9;}&#xA;&#x9;return processId;&#xA;}&#xA;&#xA;/**&#xA; * Use for calling Java, that writes the output back to the Script window.&#xA; * &#xA; * @param directory {string}&#xA; * @param command {string}&#xA; */&#xA;function runCommand(directory, command) {&#xA;&#x9;var commandFinishedSuccessfully;&#xA;&#x9;&#xA;&#x9;WSH_SHELL.CurrentDirectory = directory;&#xA;&#x9;LOGInfo(&#34;Current directory: &#34;+ WSH_SHELL.CurrentDirectory);&#xA;&#xA;&#x9;/*&#xA;&#x9; * The Run command returns an integer.&#xA;&#x9; * The 3rd argument is true: wait for the program to finish executing before continuing to the next statement in your script.&#xA;&#x9; * See https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/d5fk67ky(v=vs.84)&#xA;&#x9; */&#xA;&#x9;var result = WSH_SHELL.Run(command, 1, true);&#xA;&#x9;if (result == 0) {&#xA;&#x9;&#x9;commandFinishedSuccessfully = true;&#xA;&#x9;} else {&#xA;&#x9;&#x9;commandFinishedSuccessfully = false;&#xA;&#x9;}&#xA;&#x9;return commandFinishedSuccessfully;&#xA;}&#xA;&#xA;/**&#xA; * Executes a command in the given directory (currently not used, kept for reference, comes from the earlier _ShellHelperFunctions)&#xA; *&#xA; * @param directory {string}&#xA; * @param command {string}&#xA; * @return {boolean} whether or not the command finished successfully&#xA; */&#xA;function executeCommand(directory, command) {&#xA;&#x9;var commandFinishedSuccessfully = true;&#xA;&#x9;&#xA;&#x9;WSH_SHELL.CurrentDirectory = directory;&#xA;&#x9;LOGInfo(&#34;Current directory: &#34;+ WSH_SHELL.CurrentDirectory);&#xA;&#xA;&#x9;var wse = WSH_SHELL.Exec(command);&#xA;&#x9;while (wse.Status == 0) {&#xA;&#x9;&#x9;// see also https://msdn.microsoft.com/en-us/library/x83z1d9f(v=vs.84).aspx&#xA;&#x9;&#x9;// see also http://www.sparxsystems.com/forums/smf/index.php/topic,6063.msg127934.html&#xA;&#x9;&#x9;var message = 'Waiting for command &#34;' + command + '&#34; to finish.';&#xA;&#x9;&#x9;LOGInfo(message);&#xA;&#x9;&#x9;// alternative way of &#34;sleeping&#34;&#xA;&#x9;&#x9;WSH_SHELL.Popup(message, 1, &#34;Info message&#34;, PT_OK + PT_ICONINFORMATION);&#xA;&#x9;}&#xA;&#x9;if (!wse.StdOut.AtEndOfStream) {&#xA;&#x9;&#x9;LOGInfo(wse.StdOut.ReadAll());&#xA;&#x9;}&#xA;&#x9;if (!wse.StdErr.AtEndOfStream) {&#xA;&#x9;&#x9;LOGError(wse.StdErr.ReadAll());&#xA;&#x9;&#x9;commandFinishedSuccessfully = false;&#xA;&#x9;}&#xA;&#x9;return commandFinishedSuccessfully;&#xA;}&#xA;&#xA;/**&#xA; * @return {string} &#34;test - Enterprise Architect&#34; when the model is located in C:\Users\username\Documents\test.eapx&#xA; * @private&#xA; */&#xA;function getWindowTitleForInstanceOfEA() {&#xA;&#x9;var windowTitle = getFileNameWithoutExtensionForInstanceOfEA() + &#34; - Enterprise Architect&#34;;&#xA;&#x9;return windowTitle;&#xA;}&#xA;&#xA;/**&#xA; * @return {string} &#34;test&#34; when the full path is C:\Users\username\Documents\test.eapx&#xA; * @private&#xA; */&#xA;function getFileNameWithoutExtensionForInstanceOfEA() {&#xA;&#x9;var connectionString = Repository.ConnectionString;&#xA;&#x9;LOGInfo(connectionString);&#xA;&#x9;var fileName = connectionString.substring(connectionString.lastIndexOf(&#34;\\&#34;) + 1, connectionString.lastIndexOf(&#34;.&#34;));&#xA;&#x9;return fileName;&#xA;}&#xA;&#xA;/*&#xA; * Verifies that the environment variable EAMT_HOME is set, which is an indication&#xA; * that the EA Modelling Tools Java have been correctly installed.&#xA; */&#xA;function verifyEaModellingToolsJavaInstallation() {&#xA;&#x9;var environmentString = &#34;%&#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34;%&#34;;&#xA;&#x9;var locationDMT = WSH_SHELL.ExpandEnvironmentStrings(environmentString);&#xA;&#x9;if (environmentString == locationDMT) {&#xA;&#x9;&#x9;LOGError(&#34;Environment variable &#34; + ENV_VARIABLE_LOCATION_TOOLS + &#34; not set, set this environment variable and restart Enterprise Architect&#34;);&#xA;&#x9;&#x9;throw new Error(&#34;Have you installed EA Modelling Tools Java (correctly)?&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/*&#xA; * Method does not work, but keep code here to document what has been tried.&#xA; */&#xA;// function determineProcessIdDoesNotWork(workingDirectory) {&#xA;&#x9;// var processId;&#xA;&#x9;// var locator = new COMObject(&#34;WbemScripting.SWbemLocator&#34;); // see https://docs.microsoft.com/en-us/windows/win32/wmisdk/swbemlocator&#xA;&#x9;// var service = locator.ConnectServer(&#34;.&#34;, &#34;\\root\\cimv2&#34;);&#xA;&#x9;// var query = &#34;SELECT * FROM Win32_Process WHERE Name = 'EA.exe'&#34;; // see https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process&#xA;&#x9;// var processes = service.ExecQuery(query); // ExecQuery() returns an SWbemObjectSet, see https://docs.microsoft.com/en-us/windows/win32/wmisdk/swbemobjectset&#xA;&#x9;// Session.Output(&#34;count=&#34; + processes.Count);&#xA;&#x9;// /*&#xA;&#x9; // * And now how to iterate over processes? Far from trivial using JavaScript.&#xA;&#x9; // * See https://dentrassi.de/2011/02/04/access-to-wmi-in-java-using-eclipse-swt-ole-integration/&#xA;&#x9; // * and https://stackoverflow.com/questions/20386875/iterating-over-swbempropertyset-objects&#xA;&#x9; // * and https://theroadtodelphi.com/2010/12/01/accesing-the-wmi-from-pascal-code-delphi-oxygene-freepascal/&#xA;&#x9; // * for some inspiration (but no working solution found yet for Javascript).&#xA;&#x9; // * &#xA;&#x9; // * Tried the for/of loop, but &#34;processes is not iterable&#34;.&#xA;&#x9; // */&#xA;&#x9;// return processId;&#xA;// }"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{851C8EBF-17AB-4d25-A6B9-3DD80DF7EE12}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;move-grunddata1-to-grunddata2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;!INC eamt-utilities._tagged-values-utils&#xA;!INC eamt-utilities._model-utils&#xA;&#xA;const connectorSet = new Set();&#xA;var elementNumber = 0;&#xA;var attributeNumber = 0;&#xA;var enumNumber = 0;&#xA;var roleNumber = 0;&#xA;var diagramNumber = 0;&#xA;var promptResult;&#xA;&#xA;/**&#xA; * Update a model to use the UML profile for basic data (grunddata) version 2 &#xA; * instead of the UML profile for basic data version 1. This includes:&#xA; *&#xA; * - updating the stereotypes;&#xA; * - copying the values of the tagged values, when possible;&#xA; * - updating the definitions to start with a lower case character and to end without a full stop;&#xA; * - creating classification models from enumeration, if wanted;&#xA; * - updating the diagram types.&#xA; *&#xA; * Prerequisite: The following MDGs must be installed and enabled:&#xA; * - MDG with id GD2MDG (for Basic Data v2) in file Grunddata2MDG.xml;&#xA; * - MDG with id Grunddata (for Basic Data v1) in file GrunddataMDG.xml;&#xA; * - MDG with id Geodata (for Basic Data v1) in file Geodata MDG.xml.&#xA; *&#xA; * MDG's are located in %APPDATA%\Sparx Systems\EA\MDGTechnologies;&#xA; * the id of an MDG is found in attribute id in element /MDG.Technology/Documentation/.&#xA; *&#xA; * Note: it can be neccesary to use script fix-grunddata-dkdomaenemodel-stereotype first.&#xA; *&#xA; * Note: not all mandatory version 2 tags can be filled out from the version 1 tags, &#xA; * so for a model to be version 2 compliant, more tags must be filled out.&#xA; *&#xA; * @summary Upgrade a model from the UML profile of &#34;Modelregler for Grunddata version 1&#34; to the UML profile of &#34;Modelregler for Grunddata version 2&#34;.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;GD2MDG&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id GD2MDG, containing UML profile Grunddata2, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;Geodata&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id Geodata, containing UML profile Geodata, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;if (!Repository.IsTechnologyEnabled(&#34;Grunddata&#34;)) {&#xA;&#x9;&#x9;throw new Error(&#34;The MDG with id Geodata, containing UML profile Grunddata, is not enabled.&#34;);&#xA;&#x9;}&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var packageMain as EA.Package;&#xA;&#x9;packageMain = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (packageMain != null &amp;&amp; packageMain.ParentID != 0) {&#xA;&#x9;&#x9;if (packageMain.Element.FQStereotype == &#34;Grunddata::DKDomænemodel&#34;) {&#xA;&#x9;&#x9;&#x9;promptResult = Session.Prompt(&#34;Yes: Create classification models from enumerations\r\nNo: Keep enumerations i current model&#34;, promptYESNO);&#xA;&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Upgrade model &#34; + packageMain.Name + &#34; from the Grunddata UML profile to the Grunddata2 UML profile&#34;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;/*&#xA;&#x9;&#x9;&#x9; * The following has to be done for changing the stereotype of a model element:&#xA;&#x9;&#x9;&#x9; * 1. Save the tagged values in a temporary map.&#xA;&#x9;&#x9;&#x9; * 2. Assign the fully-qualified stereotype name to property StereotypeEx;&#xA;&#x9;&#x9;&#x9; * 3. Save the new stereotype in the database by calling Update() on the model element;&#xA;&#x9;&#x9;&#x9; *    This will also result the deletion of the tagged values associated with the old stereotype&#xA;&#x9;&#x9;&#x9; *    and the addition of the tagged values associated with the new stereotype;&#xA;&#x9;&#x9;&#x9; *    Note that Repository.SynchProfile does not have to be called, this is only relevant when the tags of a stereotype have changed.&#xA;&#x9;&#x9;&#x9; * 4. Refresh the tagged values of the model element, as they have changed, see step 3;&#xA;&#x9;&#x9;&#x9; * 5. Set the tagged values using the temporary map created in step 1.&#xA;&#x9;&#x9;&#x9; */&#xA;&#xA;&#x9;&#x9;&#x9;changePackageElementStereotypeAndTags(packageMain.Element);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;upgradeDiagrams(packageMain /* EA.Package */ );&#xA;&#xA;&#x9;&#x9;&#x9;changeElementStereotypes(packageMain, packageMain);&#xA;&#xA;&#x9;&#x9;&#x9;var packages = getSubpackagesOfPackage(packageMain);&#xA;&#x9;&#x9;&#x9;var subpackage as EA.Package;&#xA;&#x9;&#x9;&#x9;for (var i = 0; i &lt; packages.length; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;subpackage = packages[i];&#xA;&#x9;&#x9;&#x9;&#x9;changeElementStereotypes(subpackage, packageMain);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;\nSummary&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Changed diagram type for &#34; + diagramNumber + &#34; diagrams&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Changed stereotype on &#34; + elementNumber + &#34; elements&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Changed stereotype on &#34; + attributeNumber + &#34; attributes&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Changed stereotype on &#34; + enumNumber + &#34; enums&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Changed stereotype on &#34; + roleNumber + &#34; roles&#34;);&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;Repository.RefreshModelView(packageMain.PackageID);&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;throw new Error(&#34;A package with stereotype Grunddata::DKDomænemodel, not &#34; + packageMain.Element.FQStereotype + &#34;, has to be selected.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;function changePackageElementStereotypeAndTags(packageElement) {&#xA;&#x9;var tagsPackageElement = new Map();&#xA;&#x9;tagsPackageElement.set(&#34;responsibleEntity&#34;, getTaggedValueElement(packageElement, &#34;registermyndighed&#34;, &#34;&#34;));&#xA;&#x9;tagsPackageElement.set(&#34;versionInfo&#34;, getTaggedValueElement(packageElement, &#34;version&#34;, &#34;&#34;));&#xA;&#x9;packageElement.StereotypeEx = &#34;Grunddata2::DKDomænemodel&#34;;&#xA;&#x9;packageElement.Update();&#xA;&#x9;packageElement.TaggedValues.Refresh();&#xA;&#x9;setTaggedValueElement(packageElement, &#34;responsibleEntity&#34;, tagsPackageElement.get(&#34;responsibleEntity&#34;));&#xA;&#x9;setTaggedValueElement(packageElement, &#34;versionInfo&#34;, tagsPackageElement.get(&#34;versionInfo&#34;));&#xA;&#x9;LOGInfo(&#34;Changed stereotype of package &#34; + packageElement.Name);&#xA;}&#xA;&#xA;&#xA;/**&#x9;&#xA; * Copies grunddata element tags to a temporary copy&#xA; *&#xA; */&#xA;function changeElementStereotypes(currentPackage, packageMain) {&#xA;&#x9;var elements = currentPackage.Elements;&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.Count; i++) {&#xA;&#x9;&#x9;currentElement = elements.GetAt(i);&#xA;&#x9;&#x9;var tagsElement;&#xA;&#xA;&#x9;&#x9;LOGDebug(&#34;Current element: &#34; + currentElement.Name + &#34; (type=&#34; + currentElement.Type + &#34;;stereotype=&#34; + currentElement.FQStereotype + &#34;)&#34;);&#xA;&#x9;&#x9;if (currentElement.FQStereotype == &#34;Grunddata::DKObjekttype&#34; || currentElement.FQStereotype == &#34;Geodata::DKFeaturetype&#34; || currentElement.FQStereotype == &#34;Geodata::DKObjekttype&#34;) {&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsElement(currentElement, &#34;Grunddata2::DKObjekttype&#34;);&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsAttribute(currentElement, &#34;Grunddata2::DKEgenskab&#34;);&#xA;&#x9;&#x9;&#x9;changeConnectorEndStereotype(currentElement);&#xA;&#x9;&#x9;} else if (currentElement.FQStereotype == &#34;Grunddata::DKKodeliste&#34;) {&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsElement(currentElement, &#34;Grunddata2::DKKodeliste&#34;);&#xA;&#x9;&#x9;} else if (currentElement.FQStereotype == &#34;Grunddata::DKDatatype&#34;) {&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsElement(currentElement, &#34;Grunddata2::DKDatatype&#34;);&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsAttribute(currentElement, &#34;Grunddata2::DKEgenskab&#34;);&#xA;&#x9;&#x9;} else if (currentElement.FQStereotype == &#34;Grunddata::DKEnumeration&#34;) {&#xA;&#x9;&#x9;&#x9;switch (promptResult) {&#xA;&#x9;&#x9;&#x9;&#x9;case resultYes:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var newPackage as EA.Package;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newPackage = packageMain.Packages.AddNew(currentElement.Name, null);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newPackage.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newPackage.Element.StereotypeEx = &#34;Grunddata2::DKKlassifikationsmodel&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newPackage.Element.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newPackage.Element.TaggedValues.Refresh();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Created new package DKKlassifikationsmodel: &#34; + currentElement.Name);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var pi = newPackage.PackageID;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentElement.PackageID = pi;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case resultNo:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// do nothing&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsElement(currentElement, &#34;Grunddata2::DKEnumeration&#34;);&#xA;&#x9;&#x9;&#x9;changeStereotypeAndTagsAttribute(currentElement, &#34;Grunddata2::DKEnumværdi&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;function changeStereotypeAndTagsElement(element, stereotypeEx) {&#xA;&#x9;LOGDebug(&#34;Change stereotype and tags on &#34; + element.Name);&#xA;&#x9;tagsElement = getGrunddataTagsElement(currentElement);&#xA;&#x9;currentElement.StereotypeEx = stereotypeEx;&#xA;&#x9;currentElement.Update();&#xA;&#x9;currentElement.TaggedValues.Refresh();&#xA;&#x9;setGrunddataTagsElement(currentElement, tagsElement);&#xA;&#x9;elementNumber++;&#xA;&#x9;LOGInfo(&#34;Changed stereotype on: &#34; + currentElement.Name);&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Copies grunddata element tags to a temporary Map.&#xA; */&#xA;function getGrunddataTagsElement(element) {&#xA;&#x9;var tagsElement = new Map();&#xA;&#x9;tagsElement.set(&#34;definition (da)&#34;, upgradeStrings(getTaggedValueElement(element, &#34;definition&#34;, &#34;&#34;)));&#xA;&#x9;tagsElement.set(&#34;comment (da)&#34;, getTaggedValueElement(element, &#34;note&#34;, &#34;&#34;));&#xA;&#x9;tagsElement.set(&#34;legalSource&#34;, getTaggedValueElement(element, &#34;lovgrundlag&#34;, &#34;&#34;));&#xA;&#x9;tagsElement.set(&#34;example (da)&#34;, getTaggedValueElement(element, &#34;eksempel&#34;, &#34;&#34;));&#xA;&#x9;tagsElement.set(&#34;altLabel (da)&#34;, getTaggedValueElement(element, &#34;alternativtNavn&#34;, &#34;&#34;));&#xA;&#x9;return tagsElement;&#xA;}&#xA;&#xA;function setGrunddataTagsElement(element, tagsElement) {&#xA;&#x9;setTaggedValueElement(element, &#34;definition (da)&#34;, tagsElement.get(&#34;definition (da)&#34;));&#xA;&#x9;setTaggedValueElement(element, &#34;comment (da)&#34;, tagsElement.get(&#34;comment (da)&#34;));&#xA;&#x9;setTaggedValueElement(element, &#34;legalSource&#34;, tagsElement.get(&#34;legalSource&#34;));&#xA;&#x9;setTaggedValueElement(element, &#34;example (da)&#34;, tagsElement.get(&#34;example (da)&#34;));&#xA;&#x9;setTaggedValueElement(element, &#34;altLabel (da)&#34;, tagsElement.get(&#34;altLabel (da)&#34;));&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Change stereotype on attributes from Grunddata::DKEgenskab to either Grunddata2::DKEgenskab or Grunddata2::DKEnumværdi.&#xA; */&#xA;function changeStereotypeAndTagsAttribute(currentElement, newStereotype) {&#xA;&#x9;var attributes as EA.Collection;&#xA;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;for (var i = 0; i &lt; attributes.Count; i++) {&#xA;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;currentAttribute = attributes.GetAt(i);&#xA;&#x9;&#x9;LOGDebug(&#34;Current attribute: &#34; + currentAttribute.Name);&#xA;&#xA;&#x9;&#x9;var tagsAttribute = new Map();&#xA;&#x9;&#x9;tagsAttribute = getGrunddataTagsAttribute(currentAttribute);&#xA;&#x9;&#x9;currentAttribute.StereotypeEx = newStereotype;&#xA;&#x9;&#x9;currentAttribute.Update();&#xA;&#x9;&#x9;currentAttribute.TaggedValues.Refresh();&#xA;&#x9;&#x9;setGrunddataTagsAttribute(currentAttribute, tagsAttribute);&#xA;&#x9;&#x9;LOGInfo(&#34;  Changed stereotype on: &#34; + currentAttribute.Name);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;switch (newStereotype) {&#xA;&#x9;&#x9;&#x9;case &#34;Grunddata2::DKEgenskab&#34;:&#xA;&#x9;&#x9;&#x9;&#x9;attributeNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case &#34;Grunddata2::DKEnumværdi&#34;:&#xA;&#x9;&#x9;&#x9;&#x9;enumNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;&#x9;throw new Error(&#34;Error in script: unknown stereotype &#34; + newStereotype);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Copies grunddata attribute tags to a temporary Map.&#xA; */&#xA;function getGrunddataTagsAttribute(attribute) {&#xA;&#x9;var tagsAttribute = new Map();&#xA;&#x9;tagsAttribute.set(&#34;definition (da)&#34;, upgradeStrings(getTaggedValueAttribute(attribute, &#34;definition&#34;, &#34;&#34;)));&#xA;&#x9;tagsAttribute.set(&#34;comment (da)&#34;, getTaggedValueAttribute(attribute, &#34;note&#34;, &#34;&#34;));&#xA;&#x9;tagsAttribute.set(&#34;legalSource&#34;, getTaggedValueAttribute(attribute, &#34;lovgrundlag&#34;, &#34;&#34;));&#xA;&#x9;tagsAttribute.set(&#34;example (da)&#34;, getTaggedValueAttribute(attribute, &#34;eksempel&#34;, &#34;&#34;));&#xA;&#x9;tagsAttribute.set(&#34;altLabel (da)&#34;, getTaggedValueAttribute(attribute, &#34;alternativtNavn&#34;, &#34;&#34;));&#xA;&#x9;return tagsAttribute;&#xA;}&#xA;&#xA;function setGrunddataTagsAttribute(attribute, tagsAttribute) {&#xA;&#x9;setTaggedValueAttribute(attribute, &#34;definition (da)&#34;, tagsAttribute.get(&#34;definition (da)&#34;));&#xA;&#x9;setTaggedValueAttribute(attribute, &#34;comment (da)&#34;, tagsAttribute.get(&#34;comment (da)&#34;));&#xA;&#x9;setTaggedValueAttribute(attribute, &#34;legalSource&#34;, tagsAttribute.get(&#34;legalSource&#34;));&#xA;&#x9;setTaggedValueAttribute(attribute, &#34;example (da)&#34;, tagsAttribute.get(&#34;example (da)&#34;));&#xA;&#x9;setTaggedValueAttribute(attribute, &#34;altLabel (da)&#34;, tagsAttribute.get(&#34;altLabel (da)&#34;));&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Change stereotype on roles on association connectors from Grunddata::DKEgenskab to Grunddata2::DKEgenskab&#xA; *&#xA; */&#xA;function changeConnectorEndStereotype(currentElement) {&#xA;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;var clientEnd as EA.ConnectorEnd;&#xA;&#x9;var supplierEnd as EA.ConnectorEnd;&#xA;&#xA;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;for (var i = 0; i &lt; connectors.Count; i++) {&#xA;&#x9;&#x9;currentConnector = connectors.GetAt(i);&#xA;&#x9;&#x9;if (currentConnector.Type == &#34;Association&#34;) {&#xA;&#x9;&#x9;&#x9;LOGDebug(&#34;  Current association: &#34; + currentConnector.Name);&#xA;&#xA;&#x9;&#x9;&#x9;if (connectorSet.has(currentConnector.ConnectorID) == false) {&#xA;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Current association end: &#34; + clientEnd.Role);&#xA;&#x9;&#x9;&#x9;&#x9;// No property ConnectorEnd.FQStereotype exists, so just checking the Stereotype property&#xA;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role.length &gt; 0 || clientEnd.Stereotype == &#34;DKEgenskab&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var tagsClientEnd = getGrunddataTagsConnectorEnd(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;setGrunddataTagsConnectorEnd(currentConnector, true, tagsClientEnd);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;  Changed stereotype on role: &#34; + clientEnd.Role);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;roleNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;Current association end: &#34; + supplierEnd.Role);&#xA;&#x9;&#x9;&#x9;&#x9;// No property ConnectorEnd.FQStereotype exists, so just checking the Stereotype property&#xA;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role.length &gt; 0 || supplierEnd.Stereotype == &#34;DKEgenskab&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var tagsSupplierEnd = getGrunddataTagsConnectorEnd(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd.StereotypeEx = &#34;Grunddata2::DKEgenskab&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd.TaggedValues.Refresh();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;setGrunddataTagsConnectorEnd(currentConnector, false, tagsSupplierEnd);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;  Changed stereotype on role: &#34; + supplierEnd.Role);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;roleNumber++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Copy role tags from grunddata1 tags to grunddata2 tags&#xA; */&#xA;function getGrunddataTagsConnectorEnd(connector, source /* boolean */) {&#xA;&#x9;var tagsConnectorEnd = new Map();&#xA;&#x9;tagsConnectorEnd.set(&#34;definition (da)&#34;, upgradeStrings(getTaggedValueConnectorEnd(connector, &#34;definition&#34;, source, &#34;&#34;)));&#xA;&#x9;tagsConnectorEnd.set(&#34;comment (da)&#34;, getTaggedValueConnectorEnd(connector, &#34;note&#34;, source, &#34;&#34;));&#xA;&#x9;tagsConnectorEnd.set(&#34;legalSource&#34;, getTaggedValueConnectorEnd(connector, &#34;lovgrundlag&#34;, source, &#34;&#34;));&#xA;&#x9;tagsConnectorEnd.set(&#34;example (da)&#34;, getTaggedValueConnectorEnd(connector, &#34;eksempel&#34;, source, &#34;&#34;));&#xA;&#x9;tagsConnectorEnd.set(&#34;altLabel (da)&#34;, getTaggedValueConnectorEnd(connector, &#34;alternativtNavn&#34;, source, &#34;&#34;));&#xA;&#x9;return tagsConnectorEnd;&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Copy role tags from grunddata1 tags to grunddata2 tags&#xA; */&#xA;function setGrunddataTagsConnectorEnd(connector, source  /* boolean */, tagsConnectorEnd /* Map */) {&#xA;&#x9;setTaggedValueConnectorEnd(connector, &#34;definition (da)&#34;, tagsConnectorEnd.get(&#34;definition (da)&#34;), source);&#xA;&#x9;setTaggedValueConnectorEnd(connector, &#34;comment (da)&#34;, tagsConnectorEnd.get(&#34;comment (da)&#34;), source);&#xA;&#x9;setTaggedValueConnectorEnd(connector, &#34;legalSource&#34;, tagsConnectorEnd.get(&#34;legalSource&#34;), source);&#xA;&#x9;setTaggedValueConnectorEnd(connector, &#34;example (da)&#34;, tagsConnectorEnd.get(&#34;example (da)&#34;), source);&#xA;&#x9;setTaggedValueConnectorEnd(connector, &#34;altLabel (da)&#34;, tagsConnectorEnd.get(&#34;altLabel (da)&#34;), source);&#xA;}&#xA;&#xA;/**&#x9;&#xA; * Upgrade definitions to Modelregler v2.0 MDG&#xA; */&#xA;function upgradeStrings(oldString) {&#xA;&#xA;&#x9;var lowerCaseString = oldString.charAt(0).toLowerCase() + oldString.slice(1);&#xA;&#x9;var lastChar = lowerCaseString.slice(-1);&#xA;&#x9;if (lastChar == &#34;.&#34;) {&#xA;&#x9;&#x9;var removeLastCarString = lowerCaseString.slice(0, -1);&#xA;&#x9;&#x9;return removeLastCarString;&#xA;&#x9;} else {&#xA;&#x9;&#x9;return lowerCaseString;&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;&#xA;/**&#x9;&#xA; * Upgrade diagrams to Modelregler v2.0 MDG&#xA; */&#xA;function upgradeDiagrams(package /* EA.Package */ ) {&#xA;&#x9;var diagrams = getDiagramsOfPackageAndSubpackages(package);&#xA;&#x9;var diagram as EA.Diagram;&#xA;&#x9;var diagramId;&#xA;&#x9;var newStyleEx;&#xA;&#x9;var MDGDgm;&#xA;&#xA;&#xA;&#x9;for (var i in diagrams) {&#xA;&#x9;&#x9;diagram = diagrams[i];&#xA;&#xA;&#x9;&#x9;LOGDebug(&#34;diagram Style1: &#34; + diagram.StyleEx + &#34; \n&#34;);&#xA;&#x9;&#x9;diagramId = diagram.DiagramID;&#xA;&#x9;&#x9;MDGDgm = false;&#xA;&#xA;&#x9;&#x9;const styleExArray = diagram.StyleEx.split(&#34;;&#34;);&#xA;&#xA;&#x9;&#x9;for (var j = 0; j &lt; styleExArray.length; j++) {&#xA;&#x9;&#x9;&#x9;var styleExValue = styleExArray[j];&#xA;&#x9;&#x9;&#x9;if (styleExValue.includes(&#34;MDGDgm=&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;MDGDgm = true;&#xA;&#x9;&#x9;&#x9;&#x9;LOGDebug(&#34;styleExArray &#34; + j + &#34; : &#34; + styleExArray[j]);&#xA;&#x9;&#x9;&#x9;&#x9;if (diagram.Type == &#34;Package&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;styleExArray[j] = &#34;MDGDgm=Grunddatadiagrammer::Pakkediagram&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (diagram.Name.includes(&#34;Oversigt&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;styleExArray[j] = &#34;MDGDgm=Grunddatadiagrammer::Oversigtsdiagram&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;styleExArray[j] = &#34;MDGDgm=Grunddatadiagrammer::Objekttypediagram&#34;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (MDGDgm == false) {&#xA;&#x9;&#x9;&#x9;styleExArray.push(&#34;MDGDgm=Grunddatadiagrammer::Objekttypediagram&#34;);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;newStyleEx = styleExArray.join(&#34;;&#34;);&#xA;&#x9;&#x9;LOGDebug(&#34;diagram Style2: &#34; + newStyleEx + &#34; \n&#34;);&#xA;&#xA;&#x9;&#x9;Repository.Execute(&#34;UPDATE t_diagram set StyleEx='&#34; + newStyleEx + &#34;' where Diagram_ID=&#34; + diagramId + &#34;;&#34;);&#xA;&#xA;&#x9;&#x9;LOGInfo(&#34;Changed diagram type of &#34; + diagram.Name);&#xA;&#x9;&#x9;diagramNumber++;&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{86ED3DF9-09DB-4ae8-99BD-FAD737C03D81}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validate-sequence-numbers&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var SEQUENCE_NUMBER_TAG_NAME = &#34;sequenceNumber&#34;;&#xA;var TAGGED_VALUE_NOT_PRESENT_VALUE = &#34;N/A&#34;;&#xA;&#xA;/**&#xA; * Validates all of the following:&#xA; *&#xA; * 1. A tagged value sequenceNumber is set on the ends of outgoing associations of classifiers having more than one outgoing association;&#xA; * 2. A classifier has no properties with the same sequenceNumber.&#xA; *&#xA; * ShapeChange ensures that in a case where sequence numbers are not explicitly set,&#xA; * attributes are placed in front of association roles by giving attributes a sufficiently&#xA; * low sequence number. Therefore, it is sufficient to have sequence numbers on associations ends only,&#xA; * attributes do not need sequence numbers (but may have sequence numbers).&#xA; *&#xA; * @summary Validates sequence numbers.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + selectedPackage.Name + &#34;' (ID=&#34; + selectedPackage.PackageID + &#34;)&#34;);&#xA;&#x9;&#x9;validateSequenceNumbersPackage(selectedPackage);&#xA;&#x9;&#x9;LOGInfo(&#34;Done.&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Main validation method, can be called from other scripts.&#xA; *&#xA; * Returns whether or not the validation succeeded.&#xA; */&#xA;function validateSequenceNumbersPackage(selectedPackage /* EA.Package */ ) {&#xA;&#x9;/*: boolean */&#xA;&#x9;LOGInfo(&#34;=== Validation results ===&#34;);&#xA;&#x9;var noOfErrorsFound = 0;&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#xA;&#x9;var element as EA.Element;&#xA;&#x9;for (var i in elements) {&#xA;&#x9;&#x9;element = elements[i];&#xA;&#x9;&#x9;if (getDataModellingClassifiers().includes(element.Type)) {&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Validating &#34; + element.Name);&#xA;&#x9;&#x9;&#x9;var connectorEnds = getNonInHeritedPropertiesThatAreAssociationEnds(element);&#xA;&#x9;&#x9;&#x9;if (connectorEnds.size &gt; 1) {&#xA;&#x9;&#x9;&#x9;&#x9;noOfErrorsFound = noOfErrorsFound + validateSequenceNumbersElement(element);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;LOGInfo(noOfErrorsFound + &#34; error(s) found in the sequence numbers.&#34;);&#xA;}&#xA;&#xA;function validateSequenceNumbersElement(element /* EA.Element */ ) {&#xA;&#x9;/*: integer */&#xA;&#x9;LOGInfo(&#34;Validating &#34; + element.Name + &#34; because it has more than 1 outgoing association.&#34;);&#xA;&#xA;&#x9;var sequenceNumbers = new Map();&#xA;&#x9;var noOfErrorsFound = 0;&#xA;&#xA;&#x9;var associationEnds = getNonInHeritedPropertiesThatAreAssociationEnds(element);&#xA;&#x9;LOGDebug(&#34;Number of association ends for &#34; + element.Name + &#34;: &#34; + associationEnds.size);&#xA;&#x9;var associationEnd as EA.ConnectorEnd;&#xA;&#x9;for (var [connectorId, associationEnd] of associationEnds) {&#xA;&#x9;&#x9;var associationEndQualifiedName = element.Name + &#34;::&#34; + associationEnd.Role;&#xA;&#x9;&#x9;LOGDebug(&#34;Connector id: &#34; + connectorId);&#xA;&#x9;&#x9;var taggedValue = getTaggedValueConnectorEnd(Repository.GetConnectorByID(connectorId), SEQUENCE_NUMBER_TAG_NAME, associationEnd.End == &#34;Client&#34;, TAGGED_VALUE_NOT_PRESENT_VALUE);&#xA;&#x9;&#x9;LOGInfo(SEQUENCE_NUMBER_TAG_NAME + &#34; for &#34; + associationEndQualifiedName + &#34;=&#34; + taggedValue);&#xA;&#x9;&#x9;if (taggedValue == TAGGED_VALUE_NOT_PRESENT_VALUE) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Association end &#34; + associationEndQualifiedName + &#34; has no tagged value sequence number&#34;);&#xA;&#x9;&#x9;&#x9;noOfErrorsFound++;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (sequenceNumbers.has(taggedValue)) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;sequenceNumber=&#34; + taggedValue + &#34; for properties &#34; + sequenceNumbers.get(taggedValue) + &#34; and &#34; + associationEnd.Role);&#xA;&#x9;&#x9;&#x9;&#x9;noOfErrorsFound++;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;sequenceNumbers.set(taggedValue, associationEndQualifiedName);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;var attributes = element.Attributes;&#xA;&#x9;var attribute as EA.Attribute;&#xA;&#xA;&#x9;for (var i = 0; i &lt; attributes.Count; i++) {&#xA;&#x9;&#x9;attribute = attributes.GetAt(i);&#xA;&#x9;&#x9;var attributeName = element.Name + &#34;::&#34; + attribute.Name;&#xA;&#x9;&#x9;var taggedValue = getTaggedValueAttribute(attribute, SEQUENCE_NUMBER_TAG_NAME, TAGGED_VALUE_NOT_PRESENT_VALUE);&#xA;&#x9;&#x9;if (taggedValue == TAGGED_VALUE_NOT_PRESENT_VALUE) {&#xA;&#x9;&#x9;&#x9;// ok, see documentation script&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if (sequenceNumbers.has(taggedValue)) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;sequenceNumber=&#34; + taggedValue + &#34; for properties &#34; + sequenceNumbers.get(taggedValue) + &#34; and &#34; + attributeName);&#xA;&#x9;&#x9;&#x9;&#x9;noOfErrorsFound++;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;sequenceNumbers.set(taggedValue, attributeName);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return noOfErrorsFound;&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{8CEA5F49-8237-42cd-821F-A5EA5A476FE7}"/>
         <Column name="ScriptAuthor" value="{AFACCECA-AC91-41a6-8B23-ABE55074DB96}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;update-version-author-status&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var newVersion;&#xA;var newAuthor;&#xA;var newStatus;&#xA;&#xA;/**&#xA; * Updates the version, author and status on all elements in this package and subpackages.&#xA; *&#xA; * If the package has stereotype Grunddata::DKDomænemodel, the tagged value version is updated.&#xA; *&#xA; * If the package has stereotype Grunddata2::DKDomænemodel, &#xA; * the tagged values versionInfo and responsibleEntity are updated.&#xA; *&#xA; * Packages with other stereotypes are not supported.&#xA; *&#xA; * @summary Updates the version, author and status.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;var testElementID = 0;&#xA;&#xA;&#x9;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + selectedPackage.Name + &#34;' (ID=&#34; +&#xA;&#x9;&#x9;&#x9;selectedPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;requestInput(selectedPackage);&#xA;&#x9;&#x9;updateVersionAuthorAndStatus(selectedPackage);&#xA;&#x9;&#x9;var subPackage as EA.Package;&#xA;&#x9;&#x9;for (var i = 0; i &lt; selectedPackage.Packages.Count; i++) {&#xA;&#x9;&#x9;&#x9;subPackage = selectedPackage.Packages.GetAt(i);&#xA;&#x9;&#x9;&#x9;updateVersionAuthorAndStatus(subPackage);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;function requestInput(selectedPackage) {&#xA;&#x9;if (selectedPackage.Element.HasStereotype(&#34;Grunddata::DKDomænemodel&#34;) &#xA;&#x9;&#x9;|| selectedPackage.Element.HasStereotype(&#34;Grunddata2::DKDomænemodel&#34;)) {&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(&#34;Package &#34; + selectedPackage.Element.Name + &#34; has stereotype(s)&#34; +&#x9;selectedPackage.Element.StereotypeEx);&#xA;&#x9;&#x9;LOGError(&#34;It should have stereotype Grunddata::DKDomænemodel or Grunddata2::DKDomænemodel&#34;);&#xA;&#x9;&#x9;throw new Error(&#34;Wrong package stereotype&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;newStatus = Session.Input(&#34;Status of &#34; + selectedPackage.Name + &#34; (Approved or Proposed)&#34;);&#xA;&#x9;if (newStatus != 'Approved' &amp;&amp; newStatus != 'Proposed') {&#xA;&#x9;&#x9;throw new Error(&#34;Wrong new status '&#34; + newStatus + &#34;', should be 'Approved' or 'Proposed'&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;newVersion = Session.Input(&#34;Version of &#34; + selectedPackage.Name);&#xA;&#x9;if (newVersion.length == 0) {&#xA;&#x9;&#x9;throw new Error(&#34;No version given&#34;);&#xA;&#x9;}&#xA;&#x9;newAuthor = Session.Input(&#34;Author of &#34; + selectedPackage.Name);&#xA;&#x9;if (newAuthor.length == 0) {&#xA;&#x9;&#x9;throw new Error(&#34;No author given&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;function updateVersionAuthorAndStatus(aPackage) {&#xA;&#x9;setFieldsOnPackage(aPackage);&#xA;&#xA;&#x9;var elements as EA.Collection;&#xA;&#x9;elements = aPackage.Elements;&#xA;&#x9;for (var i = 0; i &lt; elements.Count; i++) {&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;currentElement = elements.GetAt(i);&#xA;&#x9;&#x9;setFieldsOnElement(currentElement);&#xA;&#x9;}&#xA;&#x9;aPackage.Elements.Refresh();&#xA;&#xA;&#x9;var diagrams as EA.Collection;&#xA;&#x9;diagrams = aPackage.Diagrams;&#xA;&#x9;for (var i = 0; i &lt; diagrams.Count; i++) {&#xA;&#x9;&#x9;var currentDiagram as EA.Diagram;&#xA;&#x9;&#x9;currentDiagram = diagrams.GetAt(i);&#xA;&#x9;&#x9;setFieldsOnDiagram(currentDiagram);&#xA;&#x9;}&#xA;&#x9;aPackage.Diagrams.Refresh();&#xA;}&#xA;&#xA;function setFieldsOnPackage(aPackage) {&#xA;&#x9;aPackage.Element.Author = newAuthor;&#xA;&#x9;aPackage.Version = newVersion;&#xA;&#x9;aPackage.Element.Status = newStatus;&#xA;&#x9;if (aPackage.Element.HasStereotype(&#34;Grunddata::DKDomænemodel&#34;)) {&#xA;&#x9;&#x9;setTaggedValueElement(aPackage.Element, &#34;version&#34;, newVersion);&#xA;&#x9;} else if (aPackage.Element.HasStereotype(&#34;Grunddata2::DKDomænemodel&#34;)) {&#xA;&#x9;&#x9;setTaggedValueElement(aPackage.Element, &#34;versionInfo&#34;, newVersion);&#xA;&#x9;&#x9;setTaggedValueElement(aPackage.Element, &#34;responsibleEntity&#34;, newAuthor);&#xA;&#x9;}&#xA;&#x9;aPackage.Element.Update();&#xA;&#x9;aPackage.Update();&#xA;&#x9;aPackage.Element.Refresh();&#xA;&#x9;LOGDebug(&#34;Set author, version and status on: &#34; + aPackage.Name);&#xA;}&#xA;&#xA;function setFieldsOnElement(element) {&#xA;&#x9;element.Author = newAuthor;&#xA;&#x9;element.Version = newVersion;&#xA;&#x9;element.Status = newStatus;&#xA;&#x9;element.Update();&#xA;&#x9;LOGDebug(&#34;Set author, version and status on: &#34; + element.Name);&#xA;}&#xA;&#xA;function setFieldsOnDiagram(diagram) {&#xA;&#x9;diagram.Author = newAuthor;&#xA;&#x9;diagram.Version = newVersion;&#xA;&#x9;diagram.Update();&#xA;&#x9;LOGDebug(&#34;Set author and version on: &#34; + diagram.Name);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{8CF27427-8177-44ab-98D7-7AB69B77E214}"/>
         <Column name="ScriptAuthor" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;set-size-attribute-with-enumeration-type&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var oneByteCodes = [&#xA;&#x9;' ', '!', '&#34;', '#', '$', '%', '&amp;', '(', ')', '*', '+', ',', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',&#xA;&#x9;':', ';', '&lt;', '=', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',&#xA;&#x9;'[', ']', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' {', '|', '}'&#xA;];&#xA;var twoByteCodes = [&#xA;&#x9;'É'&#xA;];&#xA;var threeByteCodes = [&#xA;&#x9;'æ', 'Æ', 'ø', 'Ø', 'å', 'Å', 'é'&#xA;];&#xA;&#xA;var promptResult;&#xA;&#xA;/**&#xA; * Adds a tagged value &#34;size&#34; to attributes. The value is based on the &#xA; * length of the enumeration literals &#xA; * of the enumeration that is the attribute's type.&#xA; *&#xA; * You can choose whether to calculate the length in bytes (for Oracle) or&#xA; * in characters (for Oracle and PostgreSQL).&#xA; *&#xA; * Note that the size of characters in a database depends on the character set of &#xA; * the database. This script can be used for an Oracle database with &#xA; * character set AL32UTF8.&#xA; *&#xA; * See https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&#xA; * and https://docs.oracle.com/search/?q=al32utf8.&#xA; *&#xA; * @summary Sets the size tag of attributes based on the referenced enumeration.&#xA; */&#xA;function main() {&#xA;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;CHG Set tagged value size from enumeration in &#34; + selectedPackage.Name);&#xA;&#xA;&#x9;&#x9;promptResult = Session.Prompt(&#34;Yes: Calculate length in bytes (Oracle)\r\nNo: Calculate length in characters&#34;, promptYESNO);&#xA;&#xA;&#x9;&#x9;setTaggedValues(selectedPackage);&#xA;&#xA;&#x9;&#x9;var packages as EA.Collection;&#xA;&#x9;&#x9;var subpackage as EA.Package;&#xA;&#x9;&#x9;var packages = getSubpackagesOfPackage(selectedPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; packages.length; i++) {&#xA;&#x9;&#x9;&#x9;subpackage = packages[i];&#xA;&#x9;&#x9;&#x9;setTaggedValues(subpackage);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done.&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;function setTaggedValues(aPackage) {&#xA;&#x9;var elements as EA.Collection;&#xA;&#x9;var currentElement as EA.Element;&#xA;&#x9;var attributes as EA.Collection;&#xA;&#x9;var attribute as EA.Attribute;&#xA;&#xA;&#x9;if (aPackage != null) {&#xA;&#x9;&#x9;elements = aPackage.Elements;&#xA;&#xA;&#x9;&#x9;LOGInfo(&#34;Number of elements: &#34; + elements.Count);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.Count; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements.GetAt(i);&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Elementname: &#34; + currentElement.Name);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;attribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;attributename: &#34; + attribute.Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (attribute.ClassifierID == null || attribute.ClassifierID == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGWarning(&#34;Attribute &#34; + attribute.Name +&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#34; is not linked to a type, this must be fixed. Skipping this attribute.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var attributeElement as EA.Element;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;attributeElement = Repository.GetElementByID(attribute.ClassifierID);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (attributeElement == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGWarning(&#34;Could not find an element with id &#34; + attribute.ClassifierID +&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#34;, skipping &#34; + attributeElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (attributeElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var attMaxLength = findMaxSize(attributeElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;  Attribute name: &#34; + attribute.Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;  Attribute max length: &#34; + attMaxLength);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;setTaggedValueAttribute(attribute, &#34;size&#34;, String(attMaxLength));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGDebug(attribute.Name + &#34; has &#34; + attributeElement.Name +&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#34; as type, which is not an enumeration, skipping it.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;function findMaxSize(attributeElement) {&#xA;&#x9;var attributes as EA.Collection;&#xA;&#x9;var attribute as EA.Attribute;&#xA;&#x9;var attMaxLength = 0;&#xA;&#xA;&#x9;attributes = attributeElement.Attributes;&#xA;&#x9;for (var k = 0; k &lt; attributes.Count; k++) {&#xA;&#x9;&#x9;attribute = attributes.GetAt(k);&#xA;&#x9;&#x9;var enumSize = findEnumSize(attribute.Name);&#xA;&#x9;&#x9;if (enumSize &gt; attMaxLength) {&#xA;&#x9;&#x9;&#x9;attMaxLength = enumSize;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return attMaxLength;&#xA;}&#xA;&#xA;function findEnumSize(enumValue) {&#xA;&#x9;var enumLength;&#xA;&#x9;switch (promptResult) {&#xA;&#x9;&#x9;case resultYes:&#xA;&#x9;&#x9;&#x9;enumLength = 0;&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; enumValue.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;var charToTest = enumValue.substring(j, j + 1);&#xA;&#x9;&#x9;&#x9;&#x9;if (oneByteCodes.includes(charToTest)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;enumLength = enumLength + 1;&#xA;&#x9;&#x9;&#x9;&#x9;} else if (twoByteCodes.includes(charToTest)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;enumLength = enumLength + 2;&#xA;&#x9;&#x9;&#x9;&#x9;} else if (threeByteCodes.includes(charToTest)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;enumLength = enumLength + 3;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;enumLength = enumLength + 6;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case resultNo:&#xA;&#x9;&#x9;&#x9;enumLength = enumValue.length;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;throw new Error(&#34;No valid result from the prompt that was displayed earlier&#34;);&#xA;&#x9;}&#xA;&#x9;LOGDebug(&#34;Length of &#34; + enumValue + &#34;: &#34; + enumLength);&#xA;&#x9;return enumLength;&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{947114B1-6376-4c46-A6DE-E5E039EF48F9}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validate-model-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;!INC eamt-val-data-model-validation.validation-scripts-basic-data2&#xA;&#xA;/**&#xA; * Validates a model model against the &#xA; * [basic data model rules version 2](http://grunddatamodel.datafordeler.dk/modelregler/grunddatamodelregler.html).&#xA; */&#xA;function main() {&#xA;&#x9;&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;var selectedPackage as EA.Package;&#x9;&#xA;&#x9;var now = new Date();&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#x9;&#xA;&#x9;&#xA;&#x9;// set log level to error as the output should only contain the validation report, no log messages&#xA;&#x9;LOGLEVEL = -1;&#xA;&#x9;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Dette er valideringsrapporten for modellen '&#34; + selectedPackage.Name + &#34;' udarbejdet af Modelsekretariatet d. &#34; + now.getDate() + &#34;/&#34; + (now.getMonth() + 1) + &#34; &#34; + now.getFullYear() + &#34;.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;OBS: Dette script validerer KUN for modeller lavet på MDG'en Grunddata2!&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;________________________________________________________________________________________________________________&#34;)&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.1: Brug UML som det visuelle modelsprog&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.2: Brug kun udvalgte UML-elementer&#34;);&#xA;&#x9;&#x9;umlElementer(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.3: Brug UML-stereotyper&#34;);&#xA;&#x9;&#x9;stereotypes(selectedPackage,elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.4: Angiv meningsfyldte navne og beskrivelser for modellen&#34;);&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34;title (da) og description (da): &#34;);&#xA;&#x9;&#x9;modeltags1(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;language og modelScope: &#34;);&#xA;&#x9;&#x9;modeltags1_2(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Beskrivelser og titler bør kontrolleres manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.5: Angiv identifikation af modeller&#34;);&#xA;&#x9;&#x9;modeltags2(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.6: Angiv den modelansvarlige organisation&#34;);&#xA;&#x9;&#x9;modeltags3(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.7: Angiv emneområde for modellen&#34;);&#xA;&#x9;&#x9;modeltags4(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.8: Angiv modellens version&#34;);&#xA;&#x9;&#x9;modeltags5(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.9: Modellen skal godkendes&#34;);&#xA;&#x9;&#x9;modeltags6(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Efter endt kontrol og konformanstjek bør modellens status tilrettes.&#34;);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.10: Angiv modellens modelstatus&#34;);&#x9;&#xA;&#x9;&#x9;modeltags7(selectedPackage);&#xA;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.11: Angiv modellens lovgrundlag og kilde&#34;);&#xA;&#x9;&#x9;modeltags8(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens 'legalSource' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.12: Modeller klassifikationer til genbrug&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 4.13: God diagrammeringsskik&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.1: Angiv meningsfyldte UML-navne for modelelementer&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.2: Giv alle modelelementer en identifikator&#34;);&#xA;&#x9;&#x9;identifikator(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'URI' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.3: Angiv termer i et naturligt sprog&#34;);&#xA;&#x9;&#x9;prefLabel(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'prefLabel (da)' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.4: Brug standardiserede konventioner for angivelse af navne&#34;);&#xA;&#x9;&#x9;checkCamel(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.5: Udarbejd definitioner eller beskrivelser af modellens elementer&#34;);&#xA;&#x9;&#x9;checkDef(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.6: Udarbejd strukturerede definitioner på en standardiseret måde&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.7: Udarbejd anvendelsesneutrale definitioner&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Denne regel tjekkes manuelt.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.8: Angiv modelelementers lovgrundlag&#34;);&#xA;&#x9;&#x9;checkLegal(elements);&#xA;&#x9;&#x9;checkSource(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'legalSource' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.9: Brug standardiserede primitive datatyper&#34;);&#xA;&#x9;&#x9;ISOtype(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 5.10: Angiv historikmodel for grunddataobjekttyper&#34;);&#xA;&#x9;&#x9;historik(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.1: Alle grunddataobjekttyper skal modelleres med persistent, unik identifikation&#34;);&#xA;&#x9;&#x9;checkID(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.2: Alle grunddataobjekttyper skal understøtte registreringstid&#34;);&#xA;&#x9;&#x9;checkReg(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.3: Grunddataobjekttyper bør understøtte virkningstid&#34;);&#xA;&#x9;&#x9;countHistorikmodel(elements);&#xA;&#x9;&#x9;checkVirk(elements);&#xA;&#x9;&#x9;historikReg(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.4: Alle grunddataobjekttyper bør modelleres med status&#34;);&#xA;&#x9;&#x9;Session.Output(checkAttr(elements,&#34;status&#34;));&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Regel 6.5: Alle modelentiteter bør understøtte beskedfordeling&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Forretningshændelse: &#34; + checkAttr(elements,&#34;forretningshændelse&#34;));&#xA;&#x9;&#x9;Session.Output(&#34;Forretningsproces: &#34; + checkAttr(elements,&#34;forretningsproces&#34;));&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;***** Rapport afsluttet &#34; + _LOGGetDisplayDate() +&#34; *****&#34;);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;LOGInfo(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{9D708A1A-A857-481e-AFAB-9548E99618CB}"/>
         <Column name="ScriptAuthor" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;set-gml-names&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var TAG_NAME_TRANSLITERATED_NAME = &#34;transliteratedName&#34;;&#xA;var TAG_NAME_GIS_NAME = &#34;gisName&#34;;&#xA;var TAG_NAME_GML_NAME = &#34;gmlName&#34;;&#xA;&#xA;/**&#xA; * Adds tagged value &#34;gmlName&#34; containing the name to be used in the &#xA; * GML application schema for all relevant model elements (not on enumeration values).&#xA; *&#xA; * The GML name is set using the following logic: &#xA; *&#xA; * ```mermaid&#xA;flowchart LR&#xA;    %% decisions&#xA;    gisNameSet{&#34;Is tagged value&lt;br /&gt;gisName set?&#34;}&#xA;    transliteratedNameSet{Is tagged value&lt;br /&gt;transliteratedName set?}&#xA;    %% outcomes&#xA;    useGisName[Use tagged value gisName as value of tagged value gmlName]&#xA;    usetransliteratedName[Use tagged value transliteratedName as value of tagged value gmlName]&#xA;    useModelElementName[Use model element name as value of tagged value gmlName]&#xA;    %% arrows&#xA;    Start --&gt; gisNameSet&#xA;    gisNameSet --&gt; | yes | useGisName --&gt; End&#xA;    gisNameSet --&gt; | no | transliteratedNameSet&#xA;    transliteratedNameSet --&gt; | yes | usetransliteratedName --&gt; End&#xA;    transliteratedNameSet --&gt; | no | useModelElementName --&gt; End&#xA; ```&#xA; *&#xA; * Setting a GML name is useful when dealing with feature collections, &#xA; * where the GDAL/OGR [GML driver](https://gdal.org/drivers/vector/gml.html)&#xA; * expects the property name for the feature collection member to end on &#34;member&#34; or &#34;members&#34;.&#xA; * &#xA; * By using those kinds of property names, at least support for GML in QGIS is better and thus more user-friendly.&#xA; * See e.g. https://github.com/inspire-eu-validation/ets-repository/issues/142.&#xA; * &#xA; * An example:&#xA; *&#xA; * ```mermaid&#xA;classDiagram&#xA;    class MyFeatureCollection {&#xA;        …&#xA;    }&#xA;    class MyFeature {&#xA;        …&#xA;    }&#xA;    MyFeatureCollection o--&gt; &#34;myFeature 0..*&#34; MyFeature&#xA;```&#xA; *&#xA; *&#xA; * When &#xA; *&#xA; * 1. setting tagged value gisName = myFeatureMember for property myFeature&#xA; * 2. using this script&#xA; * 3. configuring ShapeChange to use the value of gmlName when present&#xA; *&#xA; * the GML application schema below is obtained.&#xA; *&#xA; * ```xml&#xA; &lt;!-- … --&gt;&#xA;&lt;element name=&#34;MyFeatureCollection&#34; substitutionGroup=&#34;gml:AbstractFeature&#34; type=&#34;ex:MyFeatureCollectionType&#34;&gt;&#xA;&lt;/element&gt;&#xA;&lt;complexType name=&#34;MyFeatureCollectionType&#34;&gt;&#xA;    &lt;complexContent&gt;&#xA;        &lt;extension base=&#34;gml:AbstractFeatureType&#34;&gt;&#xA;            &lt;sequence&gt;&#xA;                &lt;!-- … --&gt;&#xA;                &lt;element maxOccurs=&#34;unbounded&#34; minOccurs=&#34;0&#34; name=&#34;myFeatureMember&#34;&gt;&#xA;                    &lt;complexType&gt;&#xA;                        &lt;complexContent&gt;&#xA;                            &lt;extension base=&#34;gml:AbstractFeatureMemberType&#34;&gt;&#xA;                                &lt;sequence&gt;&#xA;                                    &lt;element ref=&#34;ex:MyFeature&#34;/&gt;&#xA;                                &lt;/sequence&gt;&#xA;                            &lt;/extension&gt;&#xA;                        &lt;/complexContent&gt;&#xA;                    &lt;/complexType&gt;&#xA;                &lt;/element&gt;&#xA;                &lt;!-- … --&gt;&#xA;            &lt;/sequence&gt;&#xA;        &lt;/extension&gt;&#xA;    &lt;/complexContent&gt;&#xA;&lt;/complexType&gt;&#xA;&lt;!-- … --&gt;&#xA;```&#xA; *&#xA; * A GML document specifying a feature collection of type `MyFeatureCollection`,&#xA; * containing features of type `MyFeature`, will be recognized by&#xA; * the GDAL/OGR [GML driver](https://gdal.org/drivers/vector/gml.html)&#xA; * as having a layer called `MyFeature`, and its features can be visualized in QGIS &#xA; * without doing any modifications or transformations.&#xA; *&#xA; * For more information about GML feature collections, see section 9.9 in the&#xA; * [GML 3.2.2 specification](https://portal.opengeospatial.org/files/?artifact_id=74183&amp;version=2).&#xA; *&#xA; * @summary Adds tagged values with a GML name.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;setImplementationSchemaNameTaggedValueElement(currentElement);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;setImplementationSchemaNameTaggedValueAttribute(currentAttribute);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;setImplementationSchemaNameTaggedValueConnectorEnd(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;setImplementationSchemaNameTaggedValueConnectorEnd(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else if (currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;setImplementationSchemaNameTaggedValueElement(currentElement);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;function setImplementationSchemaNameTaggedValueElement(element) {&#xA;&#x9;LOGDebug(&#34;Element: &#34; + element.Name);&#xA;&#x9;var explicitlyDefinedName, transliteratedName;&#xA;&#x9;explicitlyDefinedName = getTaggedValueElement(element, TAG_NAME_GIS_NAME, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueElement(element, TAG_NAME_TRANSLITERATED_NAME, &#34;&#34;);&#xA;&#x9;var implementationSchemaName = getImplementationSchemaName(explicitlyDefinedName, transliteratedName, element.Name);&#xA;&#x9;setTaggedValueElement(element, TAG_NAME_GML_NAME, implementationSchemaName);&#xA;&#x9;LOGDebug(&#34;Implementation schema name: &#34; + implementationSchemaName);&#xA;}&#xA;&#xA;function getImplementationSchemaName(explicitlyDefinedName, transliteratedName, name) {&#xA;&#x9;var implementationSchemaName;&#xA;&#x9;if (explicitlyDefinedName != &#34;&#34;) {&#xA;&#x9;&#x9;implementationSchemaName = explicitlyDefinedName;&#xA;&#x9;} else if (transliteratedName != &#34;&#34;) {&#xA;&#x9;&#x9;implementationSchemaName = transliteratedName;&#xA;&#x9;} else {&#xA;&#x9;&#x9;implementationSchemaName = name;&#xA;&#x9;}&#xA;&#x9;return implementationSchemaName;&#xA;}&#xA;&#xA;function setImplementationSchemaNameTaggedValueAttribute(attribute) {&#xA;&#x9;LOGDebug(&#34;Attribute: &#34; + attribute.Name);&#xA;&#x9;var explicitlyDefinedName, transliteratedName;&#xA;&#x9;explicitlyDefinedName = getTaggedValueAttribute(attribute, TAG_NAME_GIS_NAME, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueAttribute(attribute, TAG_NAME_TRANSLITERATED_NAME, &#34;&#34;);&#xA;&#x9;var implementationSchemaName = getImplementationSchemaName(explicitlyDefinedName, transliteratedName, attribute.Name);&#xA;&#x9;setTaggedValueAttribute(attribute, TAG_NAME_GML_NAME, implementationSchemaName);&#xA;&#x9;LOGDebug(&#34;Implementation schema name: &#34; + implementationSchemaName);&#xA;}&#xA;&#xA;function setImplementationSchemaNameTaggedValueConnectorEnd(connector, source) {&#xA;&#x9;var roleName = null;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;roleName = connector.ClientEnd.Role;&#xA;&#x9;} else {&#xA;&#x9;&#x9;roleName = connector.SupplierEnd.Role;&#xA;&#x9;}&#xA;&#x9;LOGDebug(&#34;Connector end role: &#34; + roleName);&#xA;&#x9;var explicitlyDefinedName, transliteratedName;&#xA;&#x9;explicitlyDefinedName = getTaggedValueConnectorEnd(connector, TAG_NAME_GIS_NAME, source, &#34;&#34;);&#xA;&#x9;transliteratedName = getTaggedValueConnectorEnd(connector, TAG_NAME_TRANSLITERATED_NAME, source, &#34;&#34;);&#xA;&#x9;var implementationSchemaName = getImplementationSchemaName(explicitlyDefinedName, transliteratedName, roleName);&#xA;&#x9;setTaggedValueConnectorEnd(connector, TAG_NAME_GML_NAME, implementationSchemaName, source);&#xA;&#x9;LOGDebug(&#34;Implementation schema name: &#34; + implementationSchemaName);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{9EBE6640-F26F-44ad-AC7D-80BA3D93ADFC}"/>
         <Column name="ScriptAuthor" value="{70C0A695-3A03-4816-8FBB-A157114FA8E8}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;chg-remove-profiles-tag&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._constants&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;var PROFILES_TAG = &#34;profiles&#34;;&#xA;&#xA;/**&#xA; * Remove tagged value &#34;profiles&#34; from all relevant model elements of the&#xA; * selected package.&#xA; *&#xA; * @summary Remove all information regarding profiles from the model.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var selectedPackage as EA.Package;&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + selectedPackage.Name + &#34;' (ID=&#34; + selectedPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (getDataModellingClassifiers().includes(currentElement.Type)) {&#xA;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueElement(currentElement, PROFILES_TAG);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueAttribute(currentAttribute, PROFILES_TAG);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, PROFILES_TAG, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deleteTaggedValueConnectorEnd(currentConnector, PROFILES_TAG, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{AC6D9C98-A6B9-4ce0-A7B5-31B8E0297320}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;validate-model-simple&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;!INC eamt-val-data-model-validation.validation-scripts-basic-data2&#xA;&#xA;/**&#xA; * Validates any model against the simplest rules for modelling in SDFI.&#xA; */&#xA;function main() {&#xA;&#x9;&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;var selectedPackage as EA.Package;&#x9;&#xA;&#x9;var now = new Date();&#xA;&#x9;selectedPackage = Repository.GetTreeSelectedPackage();&#xA;&#x9;var elements = getElementsOfPackageAndSubpackages(selectedPackage);&#x9;&#xA;&#x9;&#xA;&#x9;// set log level to error (0) as the output should only contain the validation report, no log messages&#xA;&#x9;LOGLEVEL = -1;&#xA;&#x9;&#xA;&#x9;if (selectedPackage != null &amp;&amp; selectedPackage.ParentID != 0) {&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Dette er valideringsrapporten for modellen '&#34; + selectedPackage.Name + &#34;' udarbejdet af Modelsekretariatet d. &#34; + now.getDate() + &#34;/&#34; + (now.getMonth() + 1) + &#34; &#34; + now.getFullYear() + &#34;.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;OBS: Dette script validerer KUN for modeller lavet på MDG'en Grunddata2!&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;________________________________________________________________________________________________________________&#34;)&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der kun bruges udvalgte UML-elementer (jf. regel 4.2)&#34;);&#xA;&#x9;&#x9;umlElementer(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der kun bruges UML-stereotyper (jf. regel 4.3)&#34;);&#xA;&#x9;&#x9;stereotypes(selectedPackage,elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er udfyldt navn og beskrivelse af modellen (jf. regel 4.4)&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tags \&#34;title (da)\&#34; og \&#34;description (da)\&#34;: &#34;);&#xA;&#x9;&#x9;modeltags1(selectedPackage);&#xA;&#x9;&#x9;Session.Output(&#34;Beskrivelse og titel bør kontrolleres manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet korrekt formateret modelversion (jf. regel 4.8)&#34;);&#xA;&#x9;&#x9;modeltags5(selectedPackage);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet tilladt værdi for modelstatus (jf. regel 4.10)&#34;);&#x9;&#xA;&#x9;&#x9;modeltags7(selectedPackage);&#xA;&#xA;&#x9;&#x9;/*Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at elementers tag \&#34;prefLabel (da)\&#34; er udfyldt (jf. regel 5.3)&#34;);&#xA;&#x9;&#x9;prefLabel(elements);&#xA;&#x9;&#x9;Session.Output(&#34;Elementernes 'prefLabel (da)' bør tjekkes manuelt for at sikre meningsfyldt indhold.&#34;);&#xA;*/&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet korrekt formateret elementnavne (jf. regel 5.4)&#34;);&#xA;&#x9;&#x9;checkCamel(elements);&#xA;&#x9;&#x9;Session.Output(&#34;(bemærk; stort startbogstaver i attribut- og connectornavn er i enkelte tilfælde tilladt, fx ved forkortelser såsom CVR eller DAGI.)&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet korrekt formateret elementdefinitioner (jf. regel 5.5)&#34;);&#xA;&#x9;&#x9;checkDef(elements);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er benyttet de standardiserede primitive datatyper (jf. regel 5.9)&#34;);&#xA;&#x9;&#x9;ISOtype(elements);&#xA;&#x9;&#x9;Session.Output(&#34;(bemærk; hvis der er fejl her, kør da evt. scriptet \&#34;link-the-type-on-attributes-to-a-type-in-the-model\&#34;)&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er udfyldt tagget \&#34;historikmodel\&#34; for objekttyperne (jf. regel 5.10)&#34;);&#xA;&#x9;&#x9;historik(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet en attribut med navn \&#34;id\&#34; (jf. regel 6.1)&#34;);&#xA;&#x9;&#x9;checkID(elements);&#xA;&#x9;&#x9;Session.Output(&#34;(bemærk; for nogle modeller er en id ikke obligatorisk.)&#34;); /*virkelig? skal den her så med?*/&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet attributter med navn \&#34;registreringFra\&#34; og \&#34;registreringTil\&#34; (jf. regel 6.2)&#34;);&#xA;&#x9;&#x9;checkReg(elements);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Tjek af, at der er angivet attributter med navn \&#34;virkningFra\&#34; og \&#34;virkningTil\&#34;, såfremt det er angivet i \&#34;historikmodel\&#34; (jf. regel 6.3)&#34;);&#xA;&#x9;&#x9;countHistorikmodel(elements);&#xA;&#x9;&#x9;checkVirk(elements);&#xA;&#x9;&#x9;historikReg(elements);&#xA;&#xA;&#x9;&#x9;Session.Output(&#34; &#34;);&#xA;&#x9;&#x9;Session.Output(&#34;***** Rapport afsluttet &#34; + _LOGGetDisplayDate() +&#34; *****&#34;);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;LOGInfo(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{B55CA9B1-B1B1-4c11-BE21-0FE781BAEAE7}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_validation-functions-profile-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/*&#xA; * @file Functions specifically made to test the validity of a model against the model data rules version 2.0.&#xA; */&#xA;const upperCamel = [&#34;Class&#34;, &#34;Association class&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;]; &#xA;const lowerCamel = [&#34;Aggregation&#34;, &#34;Association&#34;, &#34;Role&#34;, &#34;Attribute&#34;]; &#xA;const allowedUMLelements = [&#34;Aggregation&#34;, &#34;Class&#34;, &#34;Generalization&#34;, &#34;Association class&#34;, 'Association', &#34;Composition&#34;, &#34;Role&#34;, &#34;Attribute&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;, &#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;,&#34;Usage&#34;]; &#xA;const omitUMLelementsType = [&#34;ProxyConnector&#34;,&#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;];&#xA;const allowedstereotypesModel = [&#34;Grunddata2::DKDomænemodel&#34;, &#34;Grunddata2::DKKlassifikationsmodel&#34;];&#xA;const allowedstereotypesElement = [&#34;Grunddata2::DKObjekttype&#34;, &#34;Grunddata2::DKDatatype&#34;,&#34;Grunddata2::DKEnumeration&#34;, &#34;Grunddata2::DKKodeliste&#34;];&#xA;const allowedstereotypesAttributeRole = &#34;DKEgenskab&#34;;&#xA;var elementIDlist = []; //Is being populated in checkID()/rule 6.1&#xA;&#xA;/**&#xA; * Validate if the selected model uses the correct UML model elements following the basic data model rules version 2.&#xA; */&#xA;function umlElementer(elements, profile){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;//Vi ser KUN på en bestemt profil&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#xA;&#x9;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' og type '&#34; + currentElement.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------connectors---------------&#34;)&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//do nothing;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' og type '&#34; + currentConnector.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation'){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Name == null || currentConnector.Name == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No name on connector associated with element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Navn på connector tilknyttet elementet '&#34; + currentElement.Name + &#34;' mangler.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Direction == &#34;Unspecified&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No direction on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Retning mangler på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((clientEnd.Role == null || clientEnd.Role == &#34;&#34;) &amp;&amp; (supplierEnd.Role == null || supplierEnd.Role== &#34;&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No roles on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Rolle(r) mangler på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Cardinality == null || clientEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + clientEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + clientEnd.Role + &#34;' på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Cardinality == null || supplierEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + supplierEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + supplierEnd.Role + &#34;' på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------attributes multiplicitet---------------&#34;)&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attrMultiUpper = currentElement.Attributes.GetAt(k).UpperBound;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attrMultiLower = currentElement.Attributes.GetAt(k).LowerBound;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// No need to test for empty upper and lower bounds, 'cos EA defaults to 1 if no value is put in. Thus I will not be able to catch this error.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (attrMultiUpper != &#34;*&#34; &amp;&amp; (/\d+/.test(attrMultiLower) == false || /\d+/.test(attrMultiUpper) == false)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig på attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else if (attrMultiUpper != &#34;*&#34; &amp;&amp; attrMultiUpper &lt; attrMultiLower ){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig på attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'. Ret grænseværdier.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the selected model has stereotype following the basic data model rules version 2.&#xA; */&#xA;function stereotypes(selectedPackage,elements,profile){&#xA;&#x9;&#xA;&#x9;//Tjek af modellens stereotype&#xA;&#x9;var j = checkStereotypeModel(selectedPackage);&#x9;&#xA;&#x9;if (j==1){&#xA;&#x9;&#x9;LOGInfo(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens stereotype: OK&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;} else if (j&gt;1){&#xA;&#x9;&#x9;LOGError(&#34;Too many stereotypes on model '&#34;+ selectedPackage.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#xA;&#x9;//Tjek af modelelementernes stereotype&#x9;&#xA;&#x9;var p = 0;&#xA;&#x9;var q = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#x9;&#xA;&#x9;&#x9;&#x9;//Jeg tjekker kun på de tre typer af elementer, fordi stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;var k = checkStereotypeElement(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;p+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (k==1){&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;} else if (k&gt;1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Too many stereotypes on element '&#34; + currentElement.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (q == p){&#xA;&#x9;&#x9;Session.Output(&#34;Alle elementers stereotype: OK&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;//Tjek af attributternes stereotype, så vi looper igen&#x9;&#xA;&#x9;var o = 0;&#xA;&#x9;var w = 0;&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#x9;&#xA;&#x9;&#x9;&#x9;//Jeg tjekker kun på de to typer af elementer, fordi der kun er attributter på Class og Datatype, ikke Enumeration o.a. (her er det modelelementer, men læses som attributter, så de skal lige sorteres fra)&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;w+=1;&#xA;&#x9;&#x9;&#x9;&#x9;let param = checkStereotypeAttribute(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;var antalKorrekteAttributterPrElement = param[0];&#xA;&#x9;&#x9;&#x9;&#x9;var antalAttributterPrElement = param[1];&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (antalKorrekteAttributterPrElement==antalAttributterPrElement){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on attributes in element '&#34; + currentElement.Name + &#34;': OK.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;o += 1;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;}&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o == w){&#xA;&#x9;&#x9;Session.Output(&#34;Alle attributters stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;//Tjek af rollernes stereotype også&#xA;&#x9;var b = 0;&#xA;&#x9;var c = 0;&#xA;&#x9;var akkLenAfConnectorSet = 0;&#xA;&#x9;var errors = 0;&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#x9;&#xA;&#x9;&#x9;&#x9;//ProxyConnectoren er godt nok et element for forbindelser mellem elementer, men forbindelsernes egenskaber og endernes egenskaber ligger på elementerne. Derfor ses der bort fra Proxyen også her.&#xA;&#x9;&#x9;&#x9;if (currentElement.Type != &#34;ProxyConnector&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;let param = checkStereotypeConnectorEnd(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;var korrektClientRollePrElement = param[0];&#xA;&#x9;&#x9;&#x9;&#x9;var korrektSupplierRollePrElement = param[1];&#xA;&#x9;&#x9;&#x9;&#x9;var lenAfConnectorSet = param[2];&#xA;&#x9;&#x9;&#x9;&#x9;var fejl = param[3];&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;b = b + korrektClientRollePrElement;&#xA;&#x9;&#x9;&#x9;&#x9;c = c + korrektSupplierRollePrElement;&#xA;&#x9;&#x9;&#x9;&#x9;akkLenAfConnectorSet = akkLenAfConnectorSet + lenAfConnectorSet;&#xA;&#x9;&#x9;&#x9;&#x9;errors = errors + fejl;&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;if (b == c &amp;&amp; c == errors &amp;&amp; errors == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Der findes ingen roller i denne pakke med profil: &#34; +profile);&#xA;&#x9;&#x9;}&#xA;&#x9;else if (errors == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Alle rollers stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given model has an allowed stereotype. A number is returned; if the number is 0 the model has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the model has too many stereotypes.&#xA; *&#xA; * @param package {EA.Package}&#xA; * @return variable defining whether or not the model has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeModel(package){&#xA;&#x9;// Check if the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesModel.length; i++){&#xA;&#x9;&#x9;if (package.Element.HasStereotype(allowedstereotypesModel[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given element has an allowed stereotype. A number is returned; if the number is 0 the element has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the element has too many stereotypes.&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variable defining whether or not the element has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeElement(element){&#xA;&#x9;// Check if the elements of the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesElement.length; i++){&#xA;&#x9;&#x9;if (element.HasStereotype(allowedstereotypesElement[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the attributes of a given element have an allowed stereotype. Two numbers are returned; the number of attributes &#xA; * with correct stereotypes, and the total count of attributes&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variables [a,b] depicting the number of attributes with correct stereotypes, a, and the total count of attributes, b&#xA; */&#xA;function checkStereotypeAttribute(element){&#xA;&#x9;var j=0;&#xA;&#x9;for (var k=0; k &lt; element.Attributes.Count; k++){&#xA;&#x9;&#x9;var attr = element.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;if (String(attr.StereotypeEx).includes(',')){&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;} &#xA;&#x9;&#x9;else if (attr.Stereotype.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, element.Attributes.Count]&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the connector ends of a given element have an allowed stereotype. Four numbers are returned; the number of connector ends (client and supplier) with correct stereotypes, &#xA; * the total count of unique connector ends and an error count of any kind.&#xA; * &#xA; * @param element {EA.Element}&#xA; * @return variables [a, b, c, d]. Depicting a, b: the number of connector ends (client and supplier) with correct stereotypes, c; the total count&#xA; * of unique connector ends and d; an error count of any kind.&#xA; */&#xA;function checkStereotypeConnectorEnd(element){&#xA;&#xA;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;var clientEnd as EA.ConnectorEnd;&#xA;&#x9;var supplierEnd as EA.ConnectorEnd;&#xA;&#x9;var j=0;&#xA;&#x9;var m=0;&#xA;&#x9;var anyError=0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;connectors = element.Connectors;&#xA;&#x9;for (var i = 0 ; i &lt; connectors.Count ; i++)&#xA;&#x9;{&#xA;&#x9;&#x9;currentConnector = connectors.GetAt(i);&#xA;&#xA;&#x9;&#x9;if(currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation')&#xA;&#x9;&#x9;{&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis der er tastet et navn ind på rollen, så skal der også være en stereotype tilknyttet &#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(clientEnd.StereotypeEx.includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(String(supplierEnd.StereotypeEx).includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;m+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Hvis der er en stereotype, men intet rollenavn, så er det en fejl&#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Stereotype.length &gt; 0 &amp;&amp; clientEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Stereotype.length &gt; 0 &amp;&amp; supplierEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, m, connectorSet.size, anyError];&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [title (da), description (da), language, modelScope]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags1(selectedPackage){&#xA;&#x9;&#xA;&#x9;var title = checkTagPackage(selectedPackage, &#34;title (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var desc = checkTagPackage(selectedPackage, &#34;description (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var lang = checkTagPackage(selectedPackage, &#34;language&#34;, &#34;noTag&#34;);&#xA;&#x9;var mscope = checkTagPackage(selectedPackage, &#34;modelScope&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;if (title == null || title == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'title (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'title (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (desc == null || desc == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'description (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'description (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (lang != &#34;da&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'language' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'language' med \&#34;da\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (mscope != &#34;application model&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'modelScope' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'model scope' med \&#34;application model\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==4) {&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;&#x9;}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [namespace, namespacePrefix]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags2(selectedPackage){&#xA;&#x9;&#xA;&#x9;var nspace = checkTagPackage(selectedPackage, &#34;namespace&#34;, &#34;noTag&#34;);&#xA;&#x9;var nspacepf = checkTagPackage(selectedPackage, &#34;namespacePrefix&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;if (nspace == null || nspace == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespace'.&#34;)&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile/g.test(nspace) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'namespace' starter ikke med \&#34;https://data.gov.dk/model/profile\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (nspacepf == null || nspacepf == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespacePrefix' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespacePrefix'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==3) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [responsibleEntity]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags3(selectedPackage){&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var respent = checkTagPackage(selectedPackage, &#34;responsibleEntity&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(selectedPackage.Name + &#34;: 'responsibleEntity' = &#34; + respent);&#x9;&#xA;&#x9;if (respent == &#34;noTag&#34;){&#xA;&#x9;&#x9;//do nothing&#xA;&#x9;}&#xA;&#x9;else if (respent == null || respent == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'responsibleEntity' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'responsibleEntity'.&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;)}&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [theme]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags4(selectedPackage){&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var theme = checkTagPackage(selectedPackage, &#34;theme&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (theme == &#34;&#34; ){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'theme'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttp/.test(theme) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'theme' starter ikke med \&#34;https\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modified, versionInfo]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags5(selectedPackage){&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var modified = checkTagPackage(selectedPackage, &#34;modified&#34;, &#34;noTag&#34;);&#xA;&#x9;var versionInfo = checkTagPackage(selectedPackage, &#34;versionInfo&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;//Vi skal lige have set på den her tag. Kan den læses både som yyyy-mm-dd OG dd-mm-yyyy??&#xA;&#x9;if (/20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]/.test(modified) == false &amp;&amp; /[0-3][0-9]-[0-1][0-9]-20[0-9][0-9]/.test(modified) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modified' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modified' er ikke opbygget iht. xsd:date 26 (YYYY-MM-DD).&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(versionInfo) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'versionInfo' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'versionInfo' er ikke opbygget iht. (0-9).(0-9).(0-9)&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [approvalStatus,approvedBy]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags6(selectedPackage){&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var apprStatus = checkTagPackage(selectedPackage, &#34;approvalStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;var apprBy = checkTagPackage(selectedPackage, &#34;approvedBy&#34;, &#34;noTag&#34;);&#x9;&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;Modellens nuværende status: &#34; + apprStatus);&#xA;&#x9;if (/approved/.test(apprStatus) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvalStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvalStatus' har ikke værdi approved&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (apprBy != &#34;Grunddata Arkitekturforum&#34; &amp;&amp; apprBy != &#34;Grunddata Modelsekretariatet&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvedBy' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvedBy' har ikke værdi fra listen (Grunddata Arkitekturforum, Grunddata Modelsekretariatet).&#34;);&#xA;&#x9;} else {j += 1}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modelStatus]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags7(selectedPackage){&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var mstatus = checkTagPackage(selectedPackage, &#34;modelStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;&#xA;&#x9;if (mstatus != &#34;development&#34; &amp;&amp; mstatus != &#34;stable&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modelStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modelStatus' har ikke værdi fra listen (development, stable).&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [legalSource,source]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags8(selectedPackage){&#x9;&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;(selve modellen tjekkes ikke for profil-tag)&#34;);&#xA;&#x9;var legalSource = checkTagPackage(selectedPackage, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;var source = checkTagPackage(selectedPackage, &#34;source&#34;, &#34;noTag&#34;);&#xA;&#x9;var j=0&#xA;&#x9;&#xA;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'legalSource' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34;.&#34;);&#xA;&#x9;} else {j +=1 }&#xA;&#x9;if (source.trim().length == 0){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'source' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;('source' er tom for pakken &#34;+ selectedPackage.Name+ &#34;)&#34;);&#xA;&#x9;} &#xA;&#x9;if (j==1) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Script to check if a tag on a package exists. If it does, the value of the tag is returned.&#xA; *&#xA; * @param package, tag, default value&#xA; * @return the tagged value&#xA; */&#xA;function checkTagPackage(package, tag, defaultval) {&#xA;&#x9;var result=getTaggedValueElement(package.Element, tag, defaultval);&#xA;&#x9;if (result==defaultval){&#xA;&#x9;&#x9;LOGError(&#34;No tag called &#34;+ tag + &#34; on package &#34; + package.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Tagget '&#34; + tag + &#34;' på pakken '&#34; + package.Name+ &#34;' findes ikke.&#34;);&#xA;&#x9;&#x9;return result;&#xA;&#x9;} else { &#xA;&#x9;&#x9;LOGTrace(&#34;Value of '&#34; + tag + &#34;' on package '&#34; + package.Name + &#34;: &#34; + result);&#xA;&#x9;&#x9;return result;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'URI'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function identifikator(elements,profile)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;var URI_list = [];&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if(getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#x9;&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;var URI = getTaggedValueElement(currentElement, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URI) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on element '&#34;+ currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34; i elementet med navn '&#34; + currentElement.Name + &#34;'.&#34;)&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; URI_list.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (URI == URI_list[j]) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' i elementet med navn '&#34; + currentElement.Name + &#34;' er ikke unik i modellen.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;URI_list.push(URI);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Tjek af attributters URI&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var URIAttr = getTaggedValueAttribute(attr, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URIAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34;.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0 &amp;&amp; r==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'prefLabel (da)'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function prefLabel(elements,profile)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#x9;&#xA;&#x9;&#x9;&#x9;//Hov, hvorfor tjekker jeg kun på de tre typer af elementer?? Nok fordi at stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;var prefLabelValue = getTaggedValueElement(currentElement, &#34;prefLabel (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;if (prefLabelValue == null || prefLabelValue == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'prefLabel (da)' on element '&#34; + currentElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' mangler værdi for 'prefLabel (da)'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Tjek af attributters &#34;prefLabel (da)&#34;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var prefLabelAttr = getTaggedValueAttribute(attr, &#34;prefLabel (da)&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (prefLabelAttr == null || prefLabelAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'prefLabel (da)' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'prefLabel (da)' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' er ikke udfyldt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0 &amp;&amp; r==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate whether or not an element name is in upper camel case and an attribute name is in lower camel case.&#xA; * Only Danish letters and numbers are allowed.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkCamel(elements,profile){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;var currentElement = elements[i];&#x9;&#x9;&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#x9;&#xA;&#x9;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (upperCamel.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/^[A-Z]|^Æ|^Ø|^Å|^[0-9]/.test(currentElement.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Name not in upper camel case: &#34;+ currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' er ikke i UpperCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Tjek af connectors navne&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (lowerCamel.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(currentConnector.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Connector element not in lower camel case: (GUID) &#34;+ currentConnector.ConnectorGUID);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase.&#34;); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(clientEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ clientEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + clientEnd.Role + &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(supplierEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ supplierEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + supplierEnd.Role +  &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Tjek af attributters navne&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k).Name; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å)/.test(attr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Attribute not in lower camel case: '&#34; + attr + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten med navn '&#34; + attr + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' er ikke i lowerCamelCase.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'definition (da)' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkDef(elements,profile){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#x9;&#x9;var defElement = getTaggedValueElement(currentElement, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (defElement == &#34;noTag&#34; || defElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^æ|^ø|^å|^[0-9]/.test(defElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defElement.trim().length != defElement.length){//not an error, but inform the user (r is not increased)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defElement.charAt(defElement.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name + &#34;' ends with a period &#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var defAttr = getTaggedValueAttribute(attr, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr == &#34;noTag&#34; || defAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^æ|^ø|^å|^[0-9]/.test(defAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.trim().length != defAttr.length){ //not an error, but inform the user (r is not increased) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.charAt(defAttr.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' ends with a period.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'legalSource' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkLegal(elements,profile){&#xA;&#xA;&#x9;var o = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var legalSourceElement = getTaggedValueElement(currentElement, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;if (legalSourceElement == &#34;noTag&#34; || legalSourceElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen 'legalSource' på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'legalSource' on element '&#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34; på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Tjek af attributters &#34;legalSource&#34;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var legalSourceAttr = getTaggedValueAttribute(attr, &#34;legalSource&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceAttr) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'legalSource' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'legalSource' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34;.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o==0 &amp;&amp; r==0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check if the tagged value 'source' on model elements is filled out. Flag, if not.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkSource(elements,profile){&#xA;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var sourceElement = getTaggedValueElement(currentElement, &#34;source&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;if (sourceElement == &#34;noTag&#34; || sourceElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;(ingen 'source' på elementet '&#34; + currentElement.Name + &#34;')&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}  &#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Tjek af attributters &#34;source&#34;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var sourceAttr = getTaggedValueAttribute(attr, &#34;source&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (sourceAttr == &#34;noTag&#34; || sourceAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'source' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;(ingen 'source' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;')&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;&#xA;/**&#xA; * Check the data types of the attributes. It has to be ISO types.&#xA; *&#xA; * @param element&#xA; */&#xA;function ISOtype(elements,profile)&#xA;{&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Vi ser lige bort fra de der proxyer og enumerationer&#xA;&#x9;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector' &amp;&amp; currentElement.Type != &#34;Enumeration&#34;){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (attr.ClassifierID == null || attr.ClassifierID == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Datatype på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;' er ikke en ISO-type.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the tag 'historikmodel' for model elements is valid. It has to be either &#34;registreringshistorik&#34; or &#34;bitemporalitet&#34;&#xA; *&#xA; * @param element&#xA; */&#xA;function historik(elements,profile)&#xA;{&#x9;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#x9;&#x9;&#x9;&#x9;if (histTag == &#34;bitemporalitet&#34; || histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;alt er godt&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong or no 'historikmodel' on element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Forkert angivet 'historikmodel' for elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Check if the object type elements have an attribute called 'id' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkID(elements,profile)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var IDcount = 0; //no. id attributes in model&#xA;&#x9;var multierrors = 0; //no. cardinality errors in model&#xA;&#x9;var typeerrors = 0; //no. data type errors in model&#xA;&#x9;&#xA;&#x9;//ElementIDlisten populeres&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#x9;&#x9;&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;&#x9;var r = 0; //no. id attributes on current element&#xA;&#x9;&#x9;&#x9;&#x9;var multifejl = 0; //no. cardinality errors&#xA;&#x9;&#x9;&#x9;&#x9;var typefejl = 0; //no. datatype errors&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (r==0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten id.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'id' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben 'id' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;IDcount = IDcount + r;&#xA;&#x9;&#x9;&#x9;&#x9;multierrors = multifejl + multifejl;&#xA;&#x9;&#x9;&#x9;&#x9;typeerrors = typeerrors + typefejl;&#xA;&#x9;&#x9;&#x9;} &#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;} &#xA;&#xA;&#x9;if (IDcount == count &amp;&amp; multierrors == 0 &amp;&amp; typeerrors == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the object type elements have attributes called 'registreringFra', 'registreringTil' and 'registreringsaktør' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkReg(elements,profile)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var regcountFra = 0; //no. registreringFra attributes&#xA;&#x9;var regcountTil = 0; //no. registreringTil attributes&#xA;&#x9;var regcountAkt = 0; //no. registreringsaktør attributes&#xA;&#x9;&#xA;&#x9;//Hvis ID-listen ikke er blevet populeret tidligere:&#xA;&#x9;if (elementIDlist.length == 0){&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var multifejlFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var multifejlTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var multifejlAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var typefejlFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var typefejlTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var typefejlAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringFra.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringTil.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktør på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktør på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;regcountFra = regcountFra + rFra&#xA;&#x9;&#x9;&#x9;&#x9;regcountTil = regcountTil + rTil&#xA;&#x9;&#x9;&#x9;&#x9;regcountAkt = regcountAkt + rAkt&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;} &#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;} &#xA;&#xA;&#x9;if (regcountFra == count &amp;&amp; regcountTil == count &amp;&amp; regcountAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * To count the number of model elements where historikmodel is a tag&#xA; *&#xA; * @param element&#xA; */&#xA;function countHistorikmodel(elements,profile)&#xA;{&#x9;&#xA;&#x9;var count = 0;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;3 Elementnavn: &#34;+ currentElement.Name);&#xA;&#x9;&#x9;&#x9;if(currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; currentElement.Type != &#34;Text&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;return count;&#xA;&#x9;//if (count == 1){&#xA;&#x9;//&#x9;Session.Output(&#34;Der er &#34; + count + &#34; element i modellen.&#34;);&#xA;&#x9;//} else {Session.Output(&#34;Der er &#34; + count + &#34; elementer i modellen.&#34;);};&#xA;}&#xA;&#xA;&#xA;/**&#xA; * If a modelelement is labelled with 'bitemporalitet' virkningstid is mandatory. &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkVirk(elements,profile)&#xA;{&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with bitemporalitet&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktør attributes&#x9;&#xA;&#x9;var multifejlFra = 0;&#xA;&#x9;var multifejlTil = 0;&#xA;&#x9;var multifejlAkt = 0;&#xA;&#x9;var typefejlFra = 0;&#xA;&#x9;var typefejlTil = 0;&#xA;&#x9;var typefejlAkt = 0;&#xA;&#x9;&#xA;&#x9;//Hvis ID-listen ikke er blevet populeret tidligere:&#xA;&#x9;if (elementIDlist.length == 0){&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;bitemporalitet&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var mFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var mTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var mAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var tFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var tTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var tAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningFra' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningFra' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningTil' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningTil' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningsaktør' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningsaktør' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;&#x9;&#x9;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;&#x9;&#x9;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;multifejlFra = multifejlFra + mFra;&#xA;&#x9;&#x9;&#x9;&#x9;multifejlTil = multifejlTil + mTil;&#xA;&#x9;&#x9;&#x9;&#x9;multifejlAkt = multifejlAkt + mAkt;&#xA;&#x9;&#x9;&#x9;&#x9;typefejlFra = typefejlFra +tFra;&#xA;&#x9;&#x9;&#x9;&#x9;typefejlTil = typefejlTil + tTil;&#xA;&#x9;&#x9;&#x9;&#x9;typefejlAkt = typefejlAkt + tAkt;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;&#34; &amp;&amp; currentElement.Type != &#34;Text&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke en værdi for tagget 'historikmodel'.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = bitemporalitet.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == count &amp;&amp; countVirkTil == count &amp;&amp; countVirkAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = bitemporalitet: Element OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = bitemporalitet: Elementer OK&#34;);}&#x9;&#x9;&#xA;&#x9;} else {Session.Output(&#34;Fejlbehæftede elementer med angivet bitemporalitet. Optælling ikke mulig.&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * If modelelement is labelled with 'registreringshistorik' no virkningstid is allowed.  &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function historikReg(elements,profile)&#xA;{&#x9;&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with registreringshistorik&#x9;&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktør attributes&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTagValue');&#xA;&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (rAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = registreringshistorik.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == 0 &amp;&amp; countVirkTil == 0 &amp;&amp; countVirkAkt == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = registreringshistorik: Element OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = registreringshistorik: Elementer OK&#34;);}&#x9;&#x9;&#xA;&#x9;} else {Session.Output(&#34;Fejlbehæftede elementer med angivet registreringshistorik. Optælling ikke mulig.&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * If a model element has attribute 'status', 'forretningshændelse' or 'forretningsproces' the attribute has to have datatype 'DKEnumeration' or 'DKKodeliste'.&#x9;&#xA; * This function checks if the datatype for a given attribute is correct (input parameter).&#xA; *&#xA; * @param element, attribute name &#xA; * @return variables: OK (string)&#xA; */&#xA;function checkAttr(elements,attributnavn,profile)&#xA;{&#x9;&#x9;&#xA;&#x9;var fejl = 0;&#xA;&#x9;&#xA;&#x9;var elementIDlistAll = [];&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;elementIDlistAll.push(currentElement.ElementID);&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (getTaggedValueElement(currentElement,'profiles','noTag').includes(profile)){&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == attributnavn){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlistAll.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;ElementType: &#34;+currentElementTemp.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){ &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.Type != &#34;Enumeration&#34; &amp;&amp; currentElementTemp.Type != &#34;Kodeliste&#34; ){//Er det type eller stereotype? For navnet på en kodelistes type er også en Enumeration...&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' på elementet '&#34;+ currentElement.Name + &#34;' har ikke datatypen DKEnumeration eller DKKodeliste&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' på elementet '&#34;+ currentElement.Name + &#34;' er ikke linket til korrekt datatypeelement.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (fejl == 0){&#xA;&#x9;&#x9;return &#34;OK&#34;;&#xA;&#x9;&#x9;//Uncomment this line if run locally&#xA;&#x9;&#x9;//Session.Output(&#34;OK&#34;); &#xA;&#x9;}&#xA;}&#xA;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{BE325D69-1748-4ce6-A3EF-ACEC83808D26}"/>
         <Column name="ScriptAuthor" value="{22061E80-B992-43ee-AEBD-02863448FF60}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_validation-functions-basic-data2&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="/*&#xA; * @file Functions specifically made to test the validity of a model against the model data rules version 2.0.&#xA; */&#xA;const upperCamel = [&#34;Class&#34;, &#34;Association class&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;]; &#xA;const lowerCamel = [&#34;Aggregation&#34;, &#34;Association&#34;, &#34;Role&#34;, &#34;Attribute&#34;]; &#xA;const allowedUMLelements = [&#34;Aggregation&#34;, &#34;Class&#34;, &#34;Generalization&#34;, &#34;Association class&#34;, 'Association', &#34;Composition&#34;, &#34;Role&#34;, &#34;Attribute&#34;, &#34;DataType&#34;, &#34;Enumeration&#34;, &#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;, &#34;Usage&#34;]; &#xA;const omitUMLelementsType = [&#34;ProxyConnector&#34;,&#34;Text&#34;, &#34;Note&#34;, &#34;Notetext&#34;, &#34;NoteLink&#34;, &#34;Dependency&#34;, &#34;Boundary&#34;];&#xA;const allowedstereotypesModel = [&#34;Grunddata2::DKDomænemodel&#34;, &#34;Grunddata2::DKKlassifikationsmodel&#34;];&#xA;const allowedstereotypesElement = [&#34;Grunddata2::DKObjekttype&#34;, &#34;Grunddata2::DKDatatype&#34;,&#34;Grunddata2::DKEnumeration&#34;, &#34;Grunddata2::DKKodeliste&#34;];&#xA;const allowedstereotypesAttributeRole = &#34;DKEgenskab&#34;;&#xA;var elementIDlist = []; //Is being populated in checkID()/rule 6.1&#xA;&#xA;/**&#xA; * Validate if the selected model uses the correct UML model elements following the basic data model rules version 2.&#xA; */&#xA;function umlElementer(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' og type '&#34; + currentElement.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------connectors---------------&#34;)&#xA;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (allowedUMLelements.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//do nothing;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Type not on allowed UML type list&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' og type '&#34; + currentConnector.Type + &#34;' er ikke en tilladt UML-type&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation'){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Name == null || currentConnector.Name == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No name on connector associated with element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Navn på connector tilknyttet elementet '&#34; + currentElement.Name + &#34;' mangler.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentConnector.Direction == &#34;Unspecified&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No direction on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Retning mangler på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((clientEnd.Role == null || clientEnd.Role == &#34;&#34;) &amp;&amp; (supplierEnd.Role == null || supplierEnd.Role== &#34;&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No roles on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Rolle(r) mangler på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Cardinality == null || clientEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + clientEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + clientEnd.Role + &#34;' på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Cardinality == null || supplierEnd.Cardinality == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No multiplicity given for role '&#34; + supplierEnd.Role + &#34;' on '&#34; + currentConnector.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet mangler for rollen '&#34; + supplierEnd.Role + &#34;' på connectoren '&#34; + currentConnector.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;//Session.Output(&#34;-------------attributes multiplicitet---------------&#34;)&#xA;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attrMultiUpper = currentElement.Attributes.GetAt(k).UpperBound;&#xA;&#x9;&#x9;&#x9;&#x9;var attrMultiLower = currentElement.Attributes.GetAt(k).LowerBound;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// No need to test for empty upper and lower bounds, 'cos EA defaults to 1 if no value is put in. Thus I will not be able to catch this error.&#xA;&#x9;&#x9;&#x9;&#x9;if (attrMultiUpper != &#34;*&#34; &amp;&amp; (/\d+/.test(attrMultiLower) == false || /\d+/.test(attrMultiUpper) == false)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig på attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (attrMultiUpper != &#34;*&#34; &amp;&amp; attrMultiUpper &lt; attrMultiLower ){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Multiplicity on '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Multiplicitet ugyldig på attributten '&#34; + currentElement.Attributes.GetAt(k).Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;'. Ret grænseværdier.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the selected model has stereotype following the basic data model rules version 2.&#xA; */&#xA;function stereotypes(selectedPackage,elements){&#xA;&#x9;&#xA;&#x9;//Tjek af modellens stereotype&#xA;&#x9;var j = checkStereotypeModel(selectedPackage);&#x9;&#xA;&#x9;if (j==1){&#xA;&#x9;&#x9;LOGInfo(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellens stereotype: OK&#34;);&#xA;&#x9;} else if (j&gt;1){&#xA;&#x9;&#x9;LOGError(&#34;Too many stereotypes on model '&#34;+ selectedPackage.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(&#34;Stereotype on model '&#34;+ selectedPackage.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;Session.Output(&#34;Modellen med navn '&#34; + selectedPackage.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;//Tjek af modelelementernes stereotype&#x9;&#xA;&#x9;var p = 0;&#xA;&#x9;var q = 0;&#xA;&#x9;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Jeg tjekker kun på de tre typer af elementer, fordi stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var k = checkStereotypeElement(currentElement);&#xA;&#x9;&#x9;&#x9;p+=1;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (k==1){&#xA;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' OK.&#34;);&#xA;&#x9;&#x9;&#x9;q+=1;&#x9;&#xA;&#x9;&#x9;&#x9;} else if (k&gt;1){&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Too many stereotypes on element '&#34; + currentElement.Name + &#34;'. Only one is allowed.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har for mange stereotyper tilknyttet. Kun 1 er tilladt.&#34;);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Stereotype on element '&#34; + currentElement.Name + &#34;' not on allowed list or no stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} &#xA;&#x9;}&#xA;&#xA;&#x9;if (q == p){&#xA;&#x9;&#x9;Session.Output(&#34;Alle elementers stereotype: OK&#34;);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;//Tjek af attributternes stereotype, så vi looper igen&#x9;&#xA;&#x9;var o = 0;&#xA;&#x9;var w = 0;&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Jeg tjekker kun på de to typer af elementer, fordi der kun er attributter på Class og Datatype, ikke Enumeration o.a. (her er det modelelementer, men læses som attributter, så de skal lige sorteres fra)&#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;w+=1;&#xA;&#x9;&#x9;&#x9;let param = checkStereotypeAttribute(currentElement);&#xA;&#x9;&#x9;&#x9;var antalKorrekteAttributterPrElement = param[0];&#xA;&#x9;&#x9;&#x9;var antalAttributterPrElement = param[1];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (antalKorrekteAttributterPrElement==antalAttributterPrElement){&#xA;&#x9;&#x9;&#x9;&#x9;LOGInfo(&#34;Stereotype on attributes in element '&#34; + currentElement.Name + &#34;': OK.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;o += 1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} &#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o == w){&#xA;&#x9;&#x9;Session.Output(&#34;Alle attributters stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;//Tjek af rollernes stereotype også&#xA;&#x9;var b = 0;&#xA;&#x9;var c = 0;&#xA;&#x9;var akkLenAfConnectorSet = 0;&#xA;&#x9;var errors = 0;&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//ProxyConnectoren er godt nok et element for forbindelser mellem elementer, men forbindelsernes egenskaber og endernes egenskaber ligger på elementerne. Derfor ses der bort fra Proxyen også her.&#xA;&#x9;&#x9;if (currentElement.Type != &#34;ProxyConnector&#34;){&#xA;&#x9;&#x9;&#x9;let param = checkStereotypeConnectorEnd(currentElement);&#xA;&#x9;&#x9;&#x9;var korrektClientRollePrElement = param[0];&#xA;&#x9;&#x9;&#x9;var korrektSupplierRollePrElement = param[1];&#xA;&#x9;&#x9;&#x9;var lenAfConnectorSet = param[2];&#xA;&#x9;&#x9;&#x9;var fejl = param[3];&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;b = b + korrektClientRollePrElement;&#xA;&#x9;&#x9;&#x9;c = c + korrektSupplierRollePrElement;&#xA;&#x9;&#x9;&#x9;akkLenAfConnectorSet = akkLenAfConnectorSet + lenAfConnectorSet;&#xA;&#x9;&#x9;&#x9;errors = errors + fejl;&#xA;&#x9;&#x9;} &#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;if (b == c &amp;&amp; c == errors &amp;&amp; errors == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Der findes ingen roller i denne pakke.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;else if (errors == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Alle rollers stereotype: OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given model has an allowed stereotype. A number is returned; if the number is 0 the model has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the model has too many stereotypes.&#xA; *&#xA; * @param package {EA.Package}&#xA; * @return variable defining whether or not the model has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeModel(package){&#xA;&#x9;// Check if the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesModel.length; i++){&#xA;&#x9;&#x9;if (package.Element.HasStereotype(allowedstereotypesModel[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if a given element has an allowed stereotype. A number is returned; if the number is 0 the element has no stereotype&#xA; * if it is 1 the stereotype is correct and if it is higher than 1 the element has too many stereotypes.&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variable defining whether or not the element has no stereotype (=0), correct stereotype (=1) or too many stereotypes (&gt;1)&#xA; */&#xA;function checkStereotypeElement(element){&#xA;&#x9;// Check if the elements of the selected package has the correct stereotype, and only one stereotype&#xA;&#x9;var j=0;&#xA;&#x9;for (var i = 0; i &lt; allowedstereotypesElement.length; i++){&#xA;&#x9;&#x9;if (element.HasStereotype(allowedstereotypesElement[i])) {&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return j;&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the attributes of a given element have an allowed stereotype. Two numbers are returned; the number of attributes &#xA; * with correct stereotypes, and the total count of attributes&#xA; *&#xA; * @param element {EA.Element}&#xA; * @return variables [a,b] depicting the number of attributes with correct stereotypes, a, and the total count of attributes, b&#xA; */&#xA;function checkStereotypeAttribute(element){&#xA;&#x9;var j=0;&#xA;&#x9;for (var k=0; k &lt; element.Attributes.Count; k++){&#xA;&#x9;&#x9;var attr = element.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;if (String(attr.StereotypeEx).includes(',')){&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;} &#xA;&#x9;&#x9;else if (attr.Stereotype.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;Attribute '&#34; + attr.Name + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34; + attr.Name + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, element.Attributes.Count]&#xA;}&#xA;&#xA;/**&#xA; * Function to check if the connector ends of a given element have an allowed stereotype. Four numbers are returned; the number of connector ends (client and supplier) with correct stereotypes, &#xA; * the total count of unique connector ends and an error count of any kind.&#xA; * &#xA; * @param element {EA.Element}&#xA; * @return variables [a, b, c, d]. Depicting a, b: the number of connector ends (client and supplier) with correct stereotypes, c; the total count&#xA; * of unique connector ends and d; an error count of any kind.&#xA; */&#xA;function checkStereotypeConnectorEnd(element){&#xA;&#xA;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;var clientEnd as EA.ConnectorEnd;&#xA;&#x9;var supplierEnd as EA.ConnectorEnd;&#xA;&#x9;var j=0;&#xA;&#x9;var m=0;&#xA;&#x9;var anyError=0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;connectors = element.Connectors;&#xA;&#x9;for (var i = 0 ; i &lt; connectors.Count ; i++)&#xA;&#x9;{&#xA;&#x9;&#x9;currentConnector = connectors.GetAt(i);&#xA;&#xA;&#x9;&#x9;if(currentConnector.Type == 'Association' || currentConnector.Type == 'Aggregation')&#xA;&#x9;&#x9;{&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis der er tastet et navn ind på rollen, så skal der også være en stereotype tilknyttet &#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(clientEnd.StereotypeEx.includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (clientEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + clientEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen '&#34; + clientEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Role.length &gt; 0){&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(String(supplierEnd.StereotypeEx).includes(&#34;,&#34;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has too many stereotypes.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har for mange stereotyper.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.Stereotype.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has no stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ingen stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else if (supplierEnd.StereotypeEx.includes(allowedstereotypesAttributeRole)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;m+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role '&#34; + supplierEnd.Role + &#34;' in elementet '&#34; + element.Name + &#34;' has wrong stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen '&#34; + supplierEnd.Role + &#34;' i elementet '&#34; + element.Name + &#34;' har ikke korrekt stereotype.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;// Hvis der er en stereotype, men intet rollenavn, så er det en fejl&#xA;&#x9;&#x9;&#x9;&#x9;if(clientEnd.Stereotype.length &gt; 0 &amp;&amp; clientEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Source-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(supplierEnd.Stereotype.length &gt; 0 &amp;&amp; supplierEnd.Role.length == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Empty role in elementet '&#34; + element.Name + &#34;', but stereotype given.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Target-rollen i elementet '&#34; + element.Name + &#34;' er tom, men stereotype er angivet.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;anyError+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return [j, m, connectorSet.size, anyError];&#xA;}&#xA;&#xA;/**&#xA; * Script to check if a tag on a package exists. If it does, the value of the tag is returned.&#xA; *&#xA; * @param package, tag, default value&#xA; * @return the tagged value&#xA; */&#xA;function checkTagPackage(package, tag, defaultval) {&#xA;&#x9;var result=getTaggedValueElement(package.Element, tag, defaultval);&#xA;&#x9;if (result==defaultval){&#xA;&#x9;&#x9;LOGError(&#34;No tag called &#34;+ tag + &#34; on package &#34; + package.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Tagget '&#34; + tag + &#34;' på pakken '&#34; + package.Name+ &#34;' findes ikke.&#34;);&#xA;&#x9;&#x9;return result;&#xA;&#x9;} else { &#xA;&#x9;&#x9;LOGTrace(&#34;Value of '&#34; + tag + &#34;' on package '&#34; + package.Name + &#34;: &#34; + result);&#xA;&#x9;&#x9;return result;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [title (da), description (da)]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags1(selectedPackage){&#xA;&#x9;&#xA;&#x9;var title = checkTagPackage(selectedPackage, &#34;title (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var desc = checkTagPackage(selectedPackage, &#34;description (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (title == null || title == &#34;&#34; || title == &#34;noTag&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'title (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'title (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (desc == null || desc == &#34;&#34; || desc == &#34;noTag&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'description (da)' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'description (da)'.&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;)}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [language, modelScope]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags1_2(selectedPackage){&#xA;&#x9;&#xA;&#x9;var lang = checkTagPackage(selectedPackage, &#34;language&#34;, &#34;noTag&#34;);&#xA;&#x9;var mscope = checkTagPackage(selectedPackage, &#34;modelScope&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (lang != &#34;da&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'language' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'language' med \&#34;da\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (mscope != &#34;application model&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'modelScope' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' skal have udfyldt 'model scope' med \&#34;application model\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;)}&#x9;&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [namespace, namespacePrefix]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags2(selectedPackage){&#xA;&#x9;&#xA;&#x9;var nspace = checkTagPackage(selectedPackage, &#34;namespace&#34;, &#34;noTag&#34;);&#xA;&#x9;var nspacepf = checkTagPackage(selectedPackage, &#34;namespacePrefix&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (nspace == null || nspace == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespace'.&#34;)&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile/g.test(nspace) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'namespace' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'namespace' starter ikke med \&#34;https://data.gov.dk/model/profile\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (nspacepf == null || nspacepf == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'namespacePrefix' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'namespacePrefix'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==3) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [responsibleEntity]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags3(selectedPackage){&#xA;&#x9;&#xA;&#x9;var respent = checkTagPackage(selectedPackage, &#34;responsibleEntity&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(selectedPackage.Name + &#34;: 'responsibleEntity' = &#34; + respent);&#x9;&#xA;&#x9;if (respent == &#34;noTag&#34;){&#xA;&#x9;&#x9;//do nothing&#xA;&#x9;}&#xA;&#x9;else if (respent == null || respent == &#34;&#34;){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'responsibleEntity' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'responsibleEntity'.&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;)}&#xA;}&#x9;&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [theme]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags4(selectedPackage){&#xA;&#x9;&#xA;&#x9;var theme = checkTagPackage(selectedPackage, &#34;theme&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;if (theme == &#34;&#34; ){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;Pakken med navn '&#34; + selectedPackage.Name + &#34;' mangler 'theme'.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/\bhttp/.test(theme) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'theme' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'theme' starter ikke med \&#34;https\&#34;.&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modified, versionInfo]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags5(selectedPackage){&#xA;&#x9;&#xA;&#x9;var modified = checkTagPackage(selectedPackage, &#34;modified&#34;, &#34;noTag&#34;);&#xA;&#x9;var versionInfo = checkTagPackage(selectedPackage, &#34;versionInfo&#34;, &#34;noTag&#34;);&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;//Vi skal lige have set på den her tag. Kan den læses både som yyyy-mm-dd OG dd-mm-yyyy??&#xA;&#x9;if (/20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]/.test(modified) == false &amp;&amp; /[0-3][0-9]-[0-1][0-9]-20[0-9][0-9]/.test(modified) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modified' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modified' er ikke opbygget iht. xsd:date 26 (YYYY-MM-DD).&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(versionInfo) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'versionInfo' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'versionInfo' er ikke opbygget iht. (0-9).(0-9).(0-9)&#34;);&#xA;&#x9;} else {j += 1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [approvalStatus,approvedBy]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags6(selectedPackage){&#xA;&#x9;&#xA;&#x9;var apprStatus = checkTagPackage(selectedPackage, &#34;approvalStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;var apprBy = checkTagPackage(selectedPackage, &#34;approvedBy&#34;, &#34;noTag&#34;);&#x9;&#xA;&#x9;var j = 0&#xA;&#x9;&#xA;&#x9;Session.Output(&#34;Modellens nuværende status: &#34; + apprStatus);&#xA;&#x9;if (/approved/.test(apprStatus) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvalStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvalStatus' har ikke værdi approved&#34;);&#xA;&#x9;} else {j += 1}&#x9;&#xA;&#x9;if (apprBy != &#34;Grunddata Arkitekturforum&#34; &amp;&amp; apprBy != &#34;Grunddata Modelsekretariatet&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'approvedBy' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'approvedBy' har ikke værdi fra listen (Grunddata Arkitekturforum, Grunddata Modelsekretariatet).&#34;);&#xA;&#x9;} else {j += 1}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [modelStatus]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags7(selectedPackage){&#xA;&#x9;&#xA;&#x9;var mstatus = checkTagPackage(selectedPackage, &#34;modelStatus&#34;, &#34;noTag&#34;);&#xA;&#x9;&#xA;&#x9;if (mstatus != &#34;development&#34; &amp;&amp; mstatus != &#34;stable&#34;){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'modelStatus' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'modelStatus' har ikke værdi fra listen (development, stable).&#34;);&#xA;&#x9;} else {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate if the tagged values of the selected model follows the basic data model rules version 2.&#xA; * List of tagged values [legalSource,source]&#xA; *&#xA; * @param package {EA.Package}&#xA; * @summary Validation of model tagged values&#xA; */&#xA;function modeltags8(selectedPackage){&#x9;&#xA;&#x9;&#xA;&#x9;var legalSource = checkTagPackage(selectedPackage, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;var source = checkTagPackage(selectedPackage, &#34;source&#34;, &#34;noTag&#34;);&#xA;&#x9;var j=0&#xA;&#x9;&#xA;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSource) == false){&#xA;&#x9;&#x9;LOGError(&#34;Wrong or no value given on tagged value 'legalSource' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34;.&#34;);&#xA;&#x9;} else {j +=1 }&#xA;&#x9;if (source.trim().length == 0){&#xA;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'source' on package &#34; + selectedPackage.Name);&#xA;&#x9;&#x9;Session.Output(&#34;'source' er tom for pakken &#34;+ selectedPackage.Name);&#xA;&#x9;} else {j +=1}&#xA;&#x9;if (j==2) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'URI'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function identifikator(elements)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;var URI_list = [];&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var URI = getTaggedValueElement(currentElement, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URI) == false){&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on element '&#34;+ currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34; i elementet med navn '&#34; + currentElement.Name + &#34;'.&#34;)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; URI_list.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (URI == URI_list[j]) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' i elementet med navn '&#34; + currentElement.Name + &#34;' er ikke unik i modellen.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;URI_list.push(URI);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters URI&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;var URIAttr = getTaggedValueAttribute(attr, &#34;URI&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/data.gov.dk\/model\/profile\//g.test(URIAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'URI' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'URI' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' starter ikke med \&#34;https://data.gov.dk/model/profile/\&#34;.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0 &amp;&amp; r==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Script to check the model element tagged value 'prefLabel (da)'. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function prefLabel(elements)&#xA;{&#x9;&#xA;&#x9;var q = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;//Hov, hvorfor tjekker jeg kun på de tre typer af elementer?? Nok fordi at stregerne mellem elementerne er af typen ProxyConnector, og de har ikke stereotyper &#xA;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34; || currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;var prefLabelValue = getTaggedValueElement(currentElement, &#34;prefLabel (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;if (prefLabelValue == null || prefLabelValue == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'prefLabel (da)' on element '&#34; + currentElement.Name);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' mangler værdi for 'prefLabel (da)'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;q+=1;&#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters &#34;prefLabel (da)&#34;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;var prefLabelAttr = getTaggedValueAttribute(attr, &#34;prefLabel (da)&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (prefLabelAttr == null || prefLabelAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'prefLabel (da)' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'prefLabel (da)' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' er ikke udfyldt.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (q==0 &amp;&amp; r==0) {Session.Output(&#34;OK&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * Validate whether or not an element name is in upper camel case and an attribute name is in lower camel case.&#xA; * Only Danish letters and numbers are allowed.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkCamel(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var connectorSet = new Set();&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer.&#x9;&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector'){&#xA;&#xA;&#x9;&#x9;&#x9;if (upperCamel.includes(currentElement.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;if (/^[A-Z]|^Æ|^Ø|^Å|^[0-9]/.test(currentElement.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Name not in upper camel case: &#34;+ currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' er ikke i UpperCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;//Tjek af connectors navne&#xA;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(connectorSet.has(currentConnector.ConnectorID) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;connectorSet.add(currentConnector.ConnectorID);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (lowerCamel.includes(currentConnector.Type)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(currentConnector.Name) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Connector element not in lower camel case: (GUID) &#34;+ currentConnector.ConnectorGUID);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase.&#34;); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;clientEnd = currentConnector.ClientEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;supplierEnd = currentConnector.SupplierEnd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (clientEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(clientEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ clientEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + clientEnd.Role + &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (supplierEnd.Role){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å|^[0-9])/.test(supplierEnd.Role) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Role not in lower camel case: &#34;+ supplierEnd.Role );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Enden med rolle '&#34; + supplierEnd.Role +  &#34;' tilknyttet connectoren med navn '&#34; + currentConnector.Name + &#34;' er ikke i lowerCamelCase&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters navne&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k).Name; &#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/(^[a-z]|^æ|^ø|^å)/.test(attr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Attribute not in lower camel case: '&#34; + attr + &#34;' associated with element '&#34; + currentElement.Name +&#34;' is wrong. Upper bound is lower than lower bound.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten med navn '&#34; + attr + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' er ikke i lowerCamelCase.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'definition (da)' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkDef(elements){&#xA;&#xA;&#x9;var r = 0;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#x9;var defElement = getTaggedValueElement(currentElement, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (defElement == &#34;noTag&#34; || defElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^æ|^ø|^å|^[0-9]/.test(defElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (defElement.trim().length != defElement.length){//not an error, but inform the user (r is not increased)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (defElement.charAt(defElement.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on element '&#34; + currentElement.Name + &#34;' ends with a period &#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;var defAttr = getTaggedValueAttribute(attr, &#34;definition (da)&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;if (defAttr == &#34;noTag&#34; || defAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen definition på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/^[a-z]|^æ|^ø|^å|^[0-9]/.test(defAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' does not begin with small letter.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' begynder ikke med lille bogstav.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.trim().length != defAttr.length){ //not an error, but inform the user (r is not increased) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' begins or ends with whitespace.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' starter eller slutter med whitespace.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (defAttr.charAt(defAttr.trim().length-1) == &#34;.&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Definition on attribute '&#34; + attr.Name + &#34;' on element '&#34; + currentElement.Name  + &#34;' ends with a period.&#34; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Definitionen angivet på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name + &#34;' slutter med et punktum.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check the tagged value 'legalSource' on model element. It has to follow the basic data model rules version 2.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkLegal(elements){&#xA;&#xA;&#x9;var o = 0;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;var legalSourceElement = getTaggedValueElement(currentElement, &#34;legalSource&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;if (legalSourceElement == &#34;noTag&#34; || legalSourceElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Ingen 'legalSource' på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceElement) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong value given on tagged value 'legalSource' on element '&#34; + currentElement.Name );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'legalSource' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34; på elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters &#34;legalSource&#34;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;var legalSourceAttr = getTaggedValueAttribute(attr, &#34;legalSource&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (/\bhttps:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceAttr) == false &amp;&amp; /\bhttp:\/\/www.retsinformation.dk\/eli\/lta/i.test(legalSourceAttr) == false){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'legalSource' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;'legalSource' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;' starter ikke med enten \&#34;https://www.retsinformation.dk/eli/lta/\&#34; eller \&#34;http://www.retsinformation.dk/eli/lta/\&#34;.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (o==0 &amp;&amp; r==0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Check if the tagged value 'source' on model elements is filled out. Flag, if not.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkSource(elements){&#xA;&#xA;&#x9;var o = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra elementer, der ikke har relevans her.&#xA;&#x9;&#x9;if (omitUMLelementsType.includes(currentElement.Type) == false){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;var sourceElement = getTaggedValueElement(currentElement, &#34;source&#34;, &#34;noTag&#34;);&#xA;&#x9;&#x9;&#x9;if (sourceElement == &#34;noTag&#34; || sourceElement == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;(Ingen 'source' på elementet '&#34; + currentElement.Name + &#34;')&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;o+=1;&#xA;&#x9;&#x9;&#x9;}  &#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Tjek af attributters &#34;source&#34;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;var sourceAttr = getTaggedValueAttribute(attr, &#34;source&#34;, &#34;noTag&#34;);&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (sourceAttr == &#34;noTag&#34; || sourceAttr == &#34;&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;No value given on tagged value 'source' on the attribute '&#34; + attr.Name + &#34;' associated with element '&#34; + currentElement.Name +&#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;(Ingen 'source' på attributten med navn '&#34; + attr.Name + &#34;' tilknyttet elementet '&#34; + currentElement.Name +&#34;')&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;&#xA;/**&#xA; * Check the data types of the attributes. It has to be ISO types.&#xA; *&#xA; * @param element&#xA; */&#xA;function ISOtype(elements)&#xA;{&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;//Vi ser lige bort fra de der proxyer og enumerationer&#xA;&#x9;&#x9;if (currentElement.Type != 'ProxyConnector' &amp;&amp; currentElement.Type != &#34;Enumeration&#34;){&#xA;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var attr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (attr.ClassifierID == null || attr.ClassifierID == 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Datatype på attributten '&#34; + attr.Name + &#34;' for elementet '&#34; + currentElement.Name+ &#34;' er ikke en ISO-type.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the tag 'historikmodel' for model elements is valid. It has to be either &#34;registreringshistorik&#34; or &#34;bitemporalitet&#34;&#xA; *&#xA; * @param element&#xA; */&#xA;function historik(elements)&#xA;{&#x9;&#xA;&#x9;var r = 0;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#x9;&#x9;&#x9;if (histTag == &#34;bitemporalitet&#34; || histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;//do nothing&#xA;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;alt er godt&#34;);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&#34;Wrong or no 'historikmodel' on element '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Forkert angivet 'historikmodel' for elementet '&#34; + currentElement.Name + &#34;'.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;if (r == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Check if the object type elements have an attribute called 'id' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkID(elements)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var IDcount = 0; //no. id attributes&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#x9;&#x9;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var r = 0;&#xA;&#x9;&#x9;&#x9;var multifejl = 0;&#xA;&#x9;&#x9;&#x9;var typefejl = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;id&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;r+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejl += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (r==0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten id.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben id på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejl != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben id på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;IDcount = IDcount + r&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} &#x9;&#xA;&#x9;} &#xA;&#xA;&#x9;if (IDcount == count &amp;&amp; multifejl == 0 &amp;&amp; typefejl == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * Check if the object type elements have attributes called 'registreringFra', 'registreringTil' and 'registreringsaktør' with correct multiplicity and type. &#xA; *&#xA; * @param element&#xA; */&#xA;function checkReg(elements)&#xA;{&#x9;&#xA;&#x9;var count = 0; //no. elements&#xA;&#x9;var regcountFra = 0; //no. registreringFra attributes&#xA;&#x9;var regcountTil = 0; //no. registreringTil attributes&#xA;&#x9;var regcountAkt = 0; //no. registreringsaktør attributes&#xA;&#x9;&#xA;&#x9;//Hvis ID-listen ikke er blevet populeret tidligere:&#xA;&#x9;if (elementIDlist.length == 0){&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#x9;&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;var multifejlFra = 0;&#xA;&#x9;&#x9;&#x9;var multifejlTil = 0;&#xA;&#x9;&#x9;&#x9;var multifejlAkt = 0;&#xA;&#x9;&#x9;&#x9;var typefejlFra = 0;&#xA;&#x9;&#x9;&#x9;var typefejlTil = 0;&#xA;&#x9;&#x9;&#x9;var typefejlAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;registreringsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;registreringsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;multifejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;typefejlAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringFra på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringTil på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten registreringsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktør på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Egenskaben registreringsaktør på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;regcountFra = regcountFra + rFra&#xA;&#x9;&#x9;&#x9;regcountTil = regcountTil + rTil&#xA;&#x9;&#x9;&#x9;regcountAkt = regcountAkt + rAkt&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;} &#x9;&#xA;&#x9;} &#xA;&#xA;&#x9;if (regcountFra == count &amp;&amp; regcountTil == count &amp;&amp; regcountAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0){&#xA;&#x9;&#x9;Session.Output(&#34;OK&#34;);&#xA;&#x9;}&#x9;&#x9;&#xA;}&#xA;&#xA;/**&#xA; * To count the number of model elements where historikmodel is a tag&#xA; *&#xA; * @param element&#xA; */&#xA;function countHistorikmodel(elements)&#xA;{&#x9;&#xA;&#x9;var count = 0;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if(currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; currentElement.Type != &#34;Text&#34;){&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (count == 1){&#xA;&#x9;&#x9;Session.Output(&#34;Der er &#34; + count + &#34; element i modellen.&#34;);&#xA;&#x9;} else {Session.Output(&#34;Der er &#34; + count + &#34; elementer i modellen.&#34;);};&#xA;}&#xA;&#xA;&#xA;/**&#xA; * If a modelelement is labelled with 'bitemporalitet' virkningstid is mandatory. &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function checkVirk(elements)&#xA;{&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with bitemporalitet&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktør attributes&#x9;&#xA;&#x9;var multifejlFra = 0;&#xA;&#x9;var multifejlTil = 0;&#xA;&#x9;var multifejlAkt = 0;&#xA;&#x9;var typefejlFra = 0;&#xA;&#x9;var typefejlTil = 0;&#xA;&#x9;var typefejlAkt = 0;&#xA;&#x9;&#xA;&#x9;//Hvis ID-listen ikke er blevet populeret tidligere:&#xA;&#x9;if (elementIDlist.length == 0){&#xA;&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) || currentElement.HasStereotype(&#34;Grunddata2::DKDatatype&#34;)) {&#xA;&#x9;&#x9;&#x9;&#x9;elementIDlist.push(currentElement.ElementID);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTag');&#xA;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;bitemporalitet&#34;) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;var mFra = 0;&#xA;&#x9;&#x9;&#x9;var mTil = 0;&#xA;&#x9;&#x9;&#x9;var mAkt = 0;&#xA;&#x9;&#x9;&#x9;var tFra = 0;&#xA;&#x9;&#x9;&#x9;var tTil = 0;&#xA;&#x9;&#x9;&#x9;var tAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.AttributesEx.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.AttributesEx.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;DateTime&#34; &amp;&amp; currentAttr.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.UpperBound != 1 || currentAttr.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttr.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tFra += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 0){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;DateTime&#34; &amp;&amp; currentAttrTemp.Type != &#34;Date&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tTil += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.UpperBound != 1 || currentAttrTemp.LowerBound != 1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;mAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentAttrTemp.Type != &#34;CharacterString&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tAkt += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (rFra == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningFra' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningFra' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningTil' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen DateTime eller Date.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningTil' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt == 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype mangler at modelleres med attributten virkningsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (typefejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningsaktør' på elementet '&#34;+ currentElement.Name + &#34;' er ikke af datatypen CharacterString.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (multifejlAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten 'virkningsaktør' på elementet '&#34;+ currentElement.Name + &#34;' har ikke multiplicitet 1.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;&#x9;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;&#x9;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#x9;&#x9;multifejlFra = multifejlFra + mFra;&#xA;&#x9;&#x9;&#x9;multifejlTil = multifejlTil + mTil;&#xA;&#x9;&#x9;&#x9;multifejlAkt = multifejlAkt + mAkt;&#xA;&#x9;&#x9;&#x9;typefejlFra = typefejlFra +tFra;&#xA;&#x9;&#x9;&#x9;typefejlTil = typefejlTil + tTil;&#xA;&#x9;&#x9;&#x9;typefejlAkt = typefejlAkt + tAkt;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;&#34; &amp;&amp; currentElement.Type != &#34;Text&#34;){&#xA;&#x9;&#x9;&#x9;Session.Output(&#34;Elementet med navn '&#34; + currentElement.Name + &#34;' har ikke en værdi for tagget 'historikmodel'.&#34;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = bitemporalitet.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == count &amp;&amp; countVirkTil == count &amp;&amp; countVirkAkt == count &amp;&amp; typefejlFra == 0 &amp;&amp; multifejlFra == 0 &amp;&amp; typefejlTil == 0 &amp;&amp; multifejlTil == 0 &amp;&amp; typefejlAkt == 0 &amp;&amp; multifejlAkt == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = bitemporalitet: Element OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = bitemporalitet: Elementer OK&#34;);}&#x9;&#x9;&#xA;&#x9;} else {Session.Output(&#34;Fejlbehæftede elementer med angivet bitemporalitet. Optælling ikke mulig.&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * If modelelement is labelled with 'registreringshistorik' no virkningstid is allowed.  &#xA; * The function here checks if any attributes exist named 'virkning*'.&#xA; *&#xA; * @param element&#xA; */&#xA;function historikReg(elements)&#xA;{&#x9;&#x9;&#x9;&#xA;&#x9;var count = 0; //no. elements with registreringshistorik&#x9;&#xA;&#x9;var countVirkFra = 0; //no. virkningFra attributes&#xA;&#x9;var countVirkTil = 0; //no. virkningTil attributes&#xA;&#x9;var countVirkAkt = 0; //no. virkningsaktør attributes&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;var histTag = getTaggedValueElement(currentElement, 'historikmodel', 'noTagValue');&#xA;&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;) &amp;&amp; histTag == &#34;registreringshistorik&#34;){&#xA;&#x9;&#x9;&#x9;count+=1;&#xA;&#x9;&#x9;&#x9;var rFra = 0;&#xA;&#x9;&#x9;&#x9;var rTil = 0;&#xA;&#x9;&#x9;&#x9;var rAkt = 0;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (elementIDlist.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var l=0; l &lt; currentElementTemp.Attributes.Count; l++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttrTemp = currentElementTemp.Attributes.GetAt(l);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningFra&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rFra+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningTil&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rTil+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentAttrTemp.Name == &#34;virkningsaktør&#34;){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;rAkt+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rFra != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningFra.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rTil != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningTil.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (rAkt != 0){&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Grunddatatypen '&#34; +currentElement.Name + &#34;' af stereotypen DKObjekttype er modelleret med attributten virkningsaktør.&#34;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;countVirkFra = countVirkFra + rFra&#xA;&#x9;countVirkTil = countVirkTil + rTil&#xA;&#x9;countVirkAkt = countVirkAkt + rAkt&#x9;&#xA;&#x9;&#xA;&#x9;if (count == 0){&#xA;&#x9;&#x9;Session.Output(&#34;Ingen elementer har angivet 'historikmodel' = registreringshistorik.&#34;);&#xA;&#x9;}&#xA;&#x9;else if (count != 0 &amp;&amp; countVirkFra == 0 &amp;&amp; countVirkTil == 0 &amp;&amp; countVirkAkt == 0){&#xA;&#x9;&#x9;if (count == 1){&#xA;&#x9;&#x9;&#x9;Session.Output(count + &#34; element med 'historikmodel' = registreringshistorik: Element OK&#34;);&#xA;&#x9;&#x9;} else {Session.Output(count + &#34; elementer med 'historikmodel' = registreringshistorik: Elementer OK&#34;);}&#x9;&#x9;&#xA;&#x9;} else {Session.Output(&#34;Fejlbehæftede elementer med angivet registreringshistorik. Optælling ikke mulig.&#34;);}&#xA;}&#xA;&#xA;/**&#xA; * If a model element has attribute 'status', 'forretningshændelse' or 'forretningsproces' the attribute has to have datatype 'DKEnumeration' or 'DKKodeliste'.&#x9;&#xA; * This function checks if the datatype for a given attribute is correct (input parameter).&#xA; *&#xA; * @param element, attribute name &#xA; * @return variables: OK (string)&#xA; */&#xA;function checkAttr(elements,attributnavn)&#xA;{&#x9;&#x9;&#xA;&#x9;var fejl = 0;&#xA;&#x9;&#xA;&#x9;var elementIDlistAll = [];&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;elementIDlistAll.push(currentElement.ElementID);&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#xA;&#x9;&#x9;var currentElement = elements[i];&#xA;&#x9;&#x9;if (currentElement.HasStereotype(&#34;Grunddata2::DKObjekttype&#34;)) {&#xA;&#x9;&#x9;&#x9;for (var k=0; k &lt; currentElement.Attributes.Count; k++){&#xA;&#x9;&#x9;&#x9;&#x9;var currentAttr = currentElement.Attributes.GetAt(k);&#xA;&#x9;&#x9;&#x9;&#x9;if (currentAttr.Name == attributnavn){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (elementIDlistAll.includes(currentAttr.ClassifierID)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var j=0; j &lt; elements.length; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var currentElementTemp = elements[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Session.Output(&#34;ElementType: &#34;+currentElementTemp.Type);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.ElementID == currentAttr.ClassifierID){ &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentElementTemp.Type != &#34;Enumeration&#34; &amp;&amp; currentElementTemp.Type != &#34;Kodeliste&#34; ){//Er det type eller stereotype? For navnet på en kodelistes type er også en Enumeration...&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' på elementet '&#34;+ currentElement.Name + &#34;' har ikke datatypen DKEnumeration eller DKKodeliste&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fejl+=1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Session.Output(&#34;Attributten '&#34;+ attributnavn + &#34;' på elementet '&#34;+ currentElement.Name + &#34;' er ikke linket til korrekt datatypeelement.&#34;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (fejl == 0){&#xA;&#x9;&#x9;return &#34;OK&#34;;&#xA;&#x9;&#x9;//Uncomment this line if run locally&#xA;&#x9;&#x9;//Session.Output(&#34;OK&#34;); &#xA;&#x9;}&#xA;}&#xA;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{BFFAE836-A1AC-411c-A687-C100853E32C6}"/>
         <Column name="ScriptAuthor" value="{6FA0E69C-7CFE-4201-965D-EACB6B9F1F6F}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;set-transliterated-names&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._guid-utils&#xA;!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._model-utils&#xA;!INC eamt-utilities._tagged-values-utils&#xA;&#xA;var TAG_NAME_TRANSLITERATED_NAME = &#34;transliteratedName&#34;;&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;&#xA;/**&#xA; * Transliterates the Danish characters and the letter e with acute to &#xA; * [Basic Latin](https://unicode-table.com/en/blocks/basic-latin/) characters&#xA; * for all model elements, and puts the transliterated name in tagged value&#xA; * `transliteratedName`. Enumeration literals are not transliterated, and if&#xA; * an enumeration literal has that tagged value, it is removed.&#xA; *&#xA; * - ø → oe&#xA; * - æ → ae&#xA; * - å → aa&#xA; * - é → e&#xA; *&#xA; * @summary Transliterates the names of the model elements.&#xA; */&#xA;function main() {&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var aPackage as EA.Package;&#xA;&#x9;aPackage = Repository.GetTreeSelectedPackage();&#xA;&#xA;&#x9;LOGInfo(&#34;=======================================&#34;);&#xA;&#xA;&#x9;if (aPackage != null &amp;&amp; aPackage.ParentID != 0) {&#xA;&#x9;&#x9;LOGInfo(&#34;Working on package '&#34; + aPackage.Name + &#34;' (ID=&#34; + aPackage.PackageID + &#34;)&#34;);&#xA;&#xA;&#x9;&#x9;var elements as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;var elements = getElementsOfPackageAndSubpackages(aPackage);&#xA;&#x9;&#x9;for (var i = 0; i &lt; elements.length; i++) {&#xA;&#x9;&#x9;&#x9;currentElement = elements[i];&#xA;&#x9;&#x9;&#x9;if (currentElement.Type == &#34;Class&#34; || currentElement.Type == &#34;DataType&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueElement(currentElement);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentAttribute as EA.Attribute;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentAttribute = attributes.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueAttribute(currentAttribute);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;var connectors as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;connectors = currentElement.Connectors;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; connectors.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var currentConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;currentConnector = connectors.GetAt(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var proceed = isConnectorAssociationAndControlledInSamePackageAsElement(currentConnector, currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (proceed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueConnectorEnd(currentConnector, true);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueConnectorEnd(currentConnector, false);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else if (currentElement.Type == &#34;Enumeration&#34;) {&#xA;&#x9;&#x9;&#x9;&#x9;transliterateNameAndUpdateTaggedValueElement(currentElement);&#xA;&#x9;&#x9;&#x9;&#x9;/*&#xA;&#x9;&#x9;&#x9;&#x9; * next lines of code: update models that actually contain transliterated names for enumeration values, from earlier modelling&#xA;&#x9;&#x9;&#x9;&#x9; */&#xA;&#x9;&#x9;&#x9;&#x9;var attributes as EA.Collection;&#xA;&#x9;&#x9;&#x9;&#x9;attributes = currentElement.Attributes;&#xA;&#x9;&#x9;&#x9;&#x9;for (var j = 0; j &lt; attributes.Count; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeTaggedValueIfPresent(attributes.GetAt(j));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LOGInfo(&#34;Done!&#34;);&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param element {EA.Element}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueElement(element) {&#xA;&#x9;LOGDebug(&#34;Element: &#34; + element.Name);&#xA;&#x9;if (mustBeTransliterated(element.Name)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(element.Name);&#xA;&#x9;&#x9;setTaggedValueElement(element, TAG_NAME_TRANSLITERATED_NAME, transliteratedName);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of element &#34; + element.Name);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueIfPresent(element);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param element {EA.Attribute}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueAttribute(attribute) {&#xA;&#x9;LOGDebug(&#34;Attribute: &#34; + attribute.Name);&#xA;&#x9;if (mustBeTransliterated(attribute.Name)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(attribute.Name);&#xA;&#x9;&#x9;setTaggedValueAttribute(attribute, TAG_NAME_TRANSLITERATED_NAME, transliteratedName);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of attribute &#34; + attribute.Name);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueIfPresent(attribute);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param source {boolean}&#xA; */&#xA;function transliterateNameAndUpdateTaggedValueConnectorEnd(connector, source) {&#xA;&#x9;var roleName = null;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;roleName = connector.ClientEnd.Role;&#xA;&#x9;} else {&#xA;&#x9;&#x9;roleName = connector.SupplierEnd.Role;&#xA;&#x9;}&#xA;&#x9;LOGDebug(&#34;Connector end role: &#34; + roleName);&#xA;&#x9;if (mustBeTransliterated(roleName)) {&#xA;&#x9;&#x9;var transliteratedName = transliterate(roleName);&#xA;&#x9;&#x9;setTaggedValueConnectorEnd(connector, TAG_NAME_TRANSLITERATED_NAME, transliteratedName, source);&#xA;&#x9;&#x9;LOGInfo(&#34;Transliterated name: &#34; + transliteratedName + &#34; of connector end &#34; + roleName);&#xA;&#x9;} else {&#xA;&#x9;&#x9;removeTaggedValueConnectorEndIfPresent(connector, source);&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @param name {string}&#xA; * @return boolean&#xA; */&#xA;function mustBeTransliterated(name) {&#xA;&#x9;return name.search(/æ|ø|å|é/i) != -1;&#xA;}&#xA;&#xA;/**&#xA; * @param name {string}&#xA; * @return {string}&#xA; */&#xA;function transliterate(name) {&#xA;&#x9;return name.replace(/æ/g, &#34;ae&#34;).replace(/Æ/g, &#34;Ae&#34;).replace(/ø/g, &#34;oe&#34;).replace(/Ø/g, &#34;Oe&#34;).replace(/å/g, &#34;aa&#34;).replace(/Å/g, &#34;Aa&#34;).replace(/é/g, &#34;e&#34;).replace(/É/g, &#34;E&#34;);&#xA;}&#xA;&#xA;/**&#xA; * @param object {EA.Element or EA.Attribute}&#xA; */&#xA;function removeTaggedValueIfPresent(object) {&#xA;&#x9;for (var i = 0; i &lt; object.TaggedValues.Count; i++) {&#xA;&#x9;&#x9;var tag = object.TaggedValues.GetAt(i);&#xA;&#x9;&#x9;if (tag.Name == TAG_NAME_TRANSLITERATED_NAME) {&#xA;&#x9;&#x9;&#x9;object.TaggedValues.DeleteAt(i, true);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;object.TaggedValues.Refresh();&#xA;}&#xA;&#xA;/**&#xA; * @param connector {EA.Connector}&#xA; * @param source {boolean}&#xA; */&#xA;function removeTaggedValueConnectorEndIfPresent(connector, source /* boolean, false =&gt; target */ ) {&#xA;&#x9;var taggedValues as EA.Collection;&#xA;&#x9;if (source) {&#xA;&#x9;&#x9;taggedValues = connector.ClientEnd.TaggedValues;&#xA;&#x9;} else {&#xA;&#x9;&#x9;taggedValues = connector.SupplierEnd.TaggedValues;&#xA;&#x9;}&#xA;&#x9;for (var i = 0; i &lt; taggedValues.Count; i++) {&#xA;&#x9;&#x9;var tag = taggedValues.GetAt(i);&#xA;&#x9;&#x9;if (tag.Tag == TAG_NAME_TRANSLITERATED_NAME) {&#xA;&#x9;&#x9;&#x9;taggedValues.DeleteAt(i, true);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;taggedValues.Refresh();&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{C346DE00-4F08-4dc2-A972-9B0692521132}"/>
         <Column name="ScriptAuthor" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-eamt-scripts&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Exports the scripts in the EAMT scripts groups as&#xA; *&#xA; * 1. a EA reference data file for import in another EA instance &#xA; * 2. seperate script files&#xA; * 3. a separate README.md file, containing the documentation extracted from the scripts&#xA; * &#xA; * The scripts should be saved in folder `.../ea-modelling-tools-javascript/src`.&#xA; *&#xA; * @summary Exports the EAMT scripts&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;verifyEaModellingToolsJavaInstallation();&#xA;&#x9;&#xA;&#x9;/*&#xA;&#x9; * A backslash must be escaped in Javascript, therefore two backslashes:&#xA;&#x9; * - one because the asterisk must be escaped with a backslash when calling a Java program from the command line&#xA;&#x9; * - one because the backslash to escape the asterisk must be escaped itself when the regex is constructed in a script&#xA;&#x9; */&#xA;&#x9;var scriptGroupNameOrRegex = &#34;eamt-%&#34;;&#xA;&#x9;&#xA;&#x9;var scriptFolderPath = chooseFolderWithUI(&#34;Folder in which the script files should be saved (ea-modelling-tools-javascript/src)&#34;);&#xA;&#x9;if (scriptFolderPath.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-scripts.bat&#34;, '-sg &#34;' + scriptGroupNameOrRegex + '&#34; -o ' + scriptFolderPath + &#34; -doc -p 5&#34;);&#xA;&#x9;&#xA;&#x9;openFolderInWindowsExplorer(scriptFolderPath);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{CB885391-7623-4417-B78A-A735D90DD3DE}"/>
         <Column name="ScriptAuthor" value="{BFB6AF55-0C36-4476-91A3-D8C13D7BAE82}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;_messages&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;&#xA;"/>
         <Column name="Script"
                 value="var MESSAGE_PACKAGE_REQUIRED = &#34;This script requires a package to be selected in the Project Browser.\n&#34; +&#xA;&#x9;&#x9;&#x9;&#34;Please select a package in the Project Browser and try again.&#34;;"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{E4D53B7B-8414-40b9-9DF0-426261C791F3}"/>
         <Column name="ScriptAuthor" value="{9B88FBBA-2AEE-4828-95E3-4066B9FF9E29}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-scripts&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;&#xA;var LOGLEVEL = LOGLEVEL_INFO;&#xA;&#xA;/**&#xA; * Exports the scripts in one or more scripts groups as&#xA; *&#xA; * 1. a EA reference data file for import in another EA instance &#xA; * 2. seperate script files&#xA; * 3. a separate README.md file, containing the documentation extracted from the scripts&#xA; *&#xA; * The name/regex is used in a LIKE expression in the database of EA project file.&#xA; *&#xA; * For .qea files, see [the LIKE operator in SQLite](https://sqlite.org/lang_expr.html#the_like_glob_regexp_match_and_extract_operators).&#xA; *&#xA; * For .eapx files, see&#xA; * [the LIKE operator in Microsoft Jet SQL](https://docs.microsoft.com/en-us/previous-versions/office/developer/office2000/aa140015(v=office.10)#the-like-operator)&#xA; * Note that an asterisk (*) in a regex must be escaped with a backslash. So use `xyz\*` instead of `xyz*` to export all script groups that have a name starting with xyz.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;verifyEaModellingToolsJavaInstallation();&#xA;&#x9;&#xA;&#x9;// a backslash must be escaped in Javascript, therefore two backslashes&#xA;&#x9;var scriptGroupNameOrRegex = Session.Input(&#34;Script group name or regex for a collection of scripts groups&#34;);&#xA;&#x9;if (scriptGroupNameOrRegex.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No script group given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;var scriptFolderPath = chooseFolderWithUI(&#34;Folder in which the script files should be saved&#34;);&#xA;&#x9;if (scriptFolderPath.length == 0) {&#xA;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-scripts.bat&#34;, '-sg &#34;' + scriptGroupNameOrRegex + '&#34; -o ' + scriptFolderPath + &#34; -p 5&#34;);&#xA;&#x9;&#xA;&#x9;openFolderInWindowsExplorer(scriptFolderPath);&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
      <DataRow>
         <Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"/>
         <Column name="ScriptName" value="{EA1498EF-9F7D-49de-A09D-A44085F5A4FF}"/>
         <Column name="ScriptAuthor" value="{FC483AD9-C76F-46b2-9883-E7D1D8C4B8EB}"/>
         <Column name="Notes"
                 value="&lt;Script Name=&#34;export-data-model-da-strict&#34; Type=&#34;Internal&#34; Language=&#34;JavaScript&#34;/&gt;"/>
         <Column name="Script"
                 value="!INC eamt-utilities._logging-utils&#xA;!INC eamt-utilities._command-line-utils&#xA;!INC eamt-utilities._messages&#xA;!INC eamt-utilities._shell-application-utils&#xA;!INC eamt-utilities._constants&#xA;&#xA;/**&#xA; * Exports a data model to a CSV file.&#xA; * The package containing the data model must be selected in the Project Browser.&#xA; *&#xA; * Only the language-independent and the Danish tags are exported. If one of those tags is missing in&#xA; * the model, the called application will fail (check the log file!).&#xA; *&#xA; * Use script export-data-model-configurable for more options.&#xA; * &#xA; * This script uses one of the templates data_model_profile_csv.ftl in %EAMT_HOME%/config/templates.&#xA; *&#xA; * @summary Exports a data model with the default settings.&#xA; */&#xA;function main() {&#xA;&#x9;Repository.EnsureOutputVisible(&#34;Script&#34;);&#xA;&#x9;&#xA;&#x9;verifyEaModellingToolsJavaInstallation();&#xA;&#x9;&#xA;&#x9;// Get the currently selected package in the tree to work on&#xA;&#x9;var package as EA.Package;&#xA;&#x9;package = Repository.GetTreeSelectedPackage();&#xA;&#x9;if (package != null &amp;&amp; package.ParentID != 0) {&#xA;&#x9;&#xA;&#x9;&#x9;var outputFolder = chooseFolderWithUI(&#34;Folder in which the exported data model should be saved&#34;);&#xA;&#x9;&#x9;if (outputFolder.length == 0) {&#xA;&#x9;&#x9;&#x9;LOGError(&#34;No folder path given&#34;);&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// cvs format; in Danish; strict mode&#xA;&#x9;&#x9;var options = '-o &#34;' + outputFolder + '&#34; -pkg ' + package.PackageGUID + ' -t csv -l da -m strict';&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;runBatFileInDefaultWorkingDirectory(&#34;export-data-model.bat&#34;, options);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;openFolderInWindowsExplorer(outputFolder);&#xA;&#x9;} else {&#xA;&#x9;&#x9;throw new Error(MESSAGE_PACKAGE_REQUIRED);&#xA;&#x9;}&#xA;}&#xA;&#xA;main();"/>
      </DataRow>
   </DataSet>
</RefData>
